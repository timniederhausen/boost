Left base folder: C:\libs\boost_1_65_0_unpatched
Right base folder: C:\libs\boost_1_65_0_dod
--- boost\algorithm\cxx14\equal.hpp	2017-08-19 09:49:39.000000000 -0700
+++ boost\algorithm\cxx14\equal.hpp	2017-08-21 15:24:58.000000000 -0700
@@ -18,12 +18,15 @@
 namespace boost { namespace algorithm {
 
 namespace detail {
 
     template <class T1, class T2>
     struct eq {
+        typedef T1 first_argument_type;
+        typedef T2 second_argument_type;
+        typedef bool result_type;
         bool operator () ( const T1& v1, const T2& v2 ) const { return v1 == v2 ;}
         };
     
     template <class RandomAccessIterator1, class RandomAccessIterator2, class BinaryPredicate>
     bool equal ( RandomAccessIterator1 first1, RandomAccessIterator1 last1, 
                  RandomAccessIterator2 first2, RandomAccessIterator2 last2, BinaryPredicate pred,
--- boost\algorithm\string\detail\case_conv.hpp	2017-08-19 09:49:39.000000000 -0700
+++ boost\algorithm\string\detail\case_conv.hpp	2017-08-21 15:25:28.000000000 -0700
@@ -10,13 +10,13 @@
 
 #ifndef BOOST_STRING_CASE_CONV_DETAIL_HPP
 #define BOOST_STRING_CASE_CONV_DETAIL_HPP
 
 #include <boost/algorithm/string/config.hpp>
 #include <locale>
-#include <functional>
+#include <algorithm>
 
 #include <boost/type_traits/make_unsigned.hpp>
 
 namespace boost {
     namespace algorithm {
         namespace detail {
--- boost\algorithm\string\detail\util.hpp	2017-08-19 09:49:39.000000000 -0700
+++ boost\algorithm\string\detail\util.hpp	2017-08-21 15:25:40.000000000 -0700
@@ -9,13 +9,13 @@
 //  See http://www.boost.org/ for updates, documentation, and revision history.
 
 #ifndef BOOST_STRING_UTIL_DETAIL_HPP
 #define BOOST_STRING_UTIL_DETAIL_HPP
 
 #include <boost/algorithm/string/config.hpp>
-#include <functional>
+#include <cstddef>
 #include <boost/range/iterator_range_core.hpp>
 
 namespace boost {
     namespace algorithm {
         namespace detail {
 
--- boost\align\alignment_of.hpp	2017-08-19 09:49:39.000000000 -0700
+++ boost\align\alignment_of.hpp	2017-08-21 15:26:41.000000000 -0700
@@ -5,16 +5,17 @@
 Distributed under the Boost Software License, Version 1.0.
 (http://www.boost.org/LICENSE_1_0.txt)
 */
 #ifndef BOOST_ALIGN_ALIGNMENT_OF_HPP
 #define BOOST_ALIGN_ALIGNMENT_OF_HPP
 
+#include <boost/detail/workaround.hpp>
 #include <boost/align/detail/element_type.hpp>
 #include <boost/align/alignment_of_forward.hpp>
 
-#if defined(BOOST_MSVC)
+#if defined(BOOST_MSVC) && BOOST_WORKAROUND( BOOST_MSVC, < 1900 )
 #include <boost/align/detail/alignment_of_msvc.hpp>
 #elif defined(__GNUC__) && defined(__unix__) && !defined(__LP64__)
 #include <boost/align/detail/alignment_of.hpp>
 #elif defined(BOOST_CLANG) && !defined(__x86_64__)
 #include <boost/align/detail/alignment_of.hpp>
 #elif !defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
--- boost\archive\iterators\xml_unescape.hpp	2017-08-19 09:49:48.000000000 -0700
+++ boost\archive\iterators\xml_unescape.hpp	2017-08-21 15:28:35.000000000 -0700
@@ -14,12 +14,13 @@
 // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
 // http://www.boost.org/LICENSE_1_0.txt)
 
 //  See http://www.boost.org for updates, documentation, and revision history.
 
 #include <boost/assert.hpp>
+#include <boost/detail/workaround.hpp>
 
 #include <boost/serialization/throw_exception.hpp>
 
 #include <boost/archive/iterators/unescape.hpp>
 #include <boost/archive/iterators/dataflow_exception.hpp>
 
@@ -40,13 +41,13 @@
 
     reference_type dereference() const {
         return unescape<xml_unescape<Base>, Base>::dereference();
     }
 public:
     // workaround msvc 7.1 ICU crash
-    #if defined(BOOST_MSVC)
+    #if defined(BOOST_MSVC) && BOOST_WORKAROUND( BOOST_MSVC, < 1500 )
         typedef int value_type;
     #else
         typedef typename this_t::value_type value_type;
     #endif
 
     void drain_residue(const char *literal);
--- boost\asio\impl\use_future.hpp	2017-08-19 09:49:39.000000000 -0700
+++ boost\asio\impl\use_future.hpp	2017-08-21 15:29:10.000000000 -0700
@@ -13,12 +13,13 @@
 
 #if defined(_MSC_VER) && (_MSC_VER >= 1200)
 # pragma once
 #endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
 
 #include <boost/asio/detail/config.hpp>
+#include <exception>
 #include <future>
 #include <boost/asio/async_result.hpp>
 #include <boost/system/error_code.hpp>
 #include <boost/asio/handler_type.hpp>
 #include <boost/system/system_error.hpp>
 #include <boost/asio/detail/memory.hpp>
@@ -43,23 +44,23 @@
             BOOST_ASIO_REBIND_ALLOC(Alloc, char)(uf.get_allocator())))
     {
     }
 
     void operator()(T t)
     {
-      promise_->set_value(t);
+      promise_->set_value(BOOST_ASIO_MOVE_CAST(T)(t));
     }
 
     void operator()(const boost::system::error_code& ec, T t)
     {
       if (ec)
         promise_->set_exception(
             std::make_exception_ptr(
               boost::system::system_error(ec)));
       else
-        promise_->set_value(t);
+        promise_->set_value(BOOST_ASIO_MOVE_CAST(T)(t));
     }
 
   //private:
     std::shared_ptr<std::promise<T> > promise_;
   };
 
@@ -125,18 +126,18 @@
   // The initiating function will return a future.
   typedef std::future<T> type;
 
   // Constructor creates a new promise for the async operation, and obtains the
   // corresponding future.
   explicit async_result(detail::promise_handler<T>& h)
+    : value_(h.promise_->get_future())
   {
-    value_ = h.promise_->get_future();
   }
 
   // Obtain the future to be returned from the initiating function.
-  type get() { return std::move(value_); }
+  type get() { return BOOST_ASIO_MOVE_CAST(type)(value_); }
 
 private:
   type value_;
 };
 
 // Handler type specialisation for use_future.
--- boost\asio\buffer.hpp	2017-08-19 09:49:39.000000000 -0700
+++ boost\asio\buffer.hpp	2017-08-21 15:29:37.000000000 -0700
@@ -20,13 +20,14 @@
 #include <cstring>
 #include <string>
 #include <vector>
 #include <boost/asio/detail/array_fwd.hpp>
 
 #if defined(BOOST_ASIO_MSVC)
-# if defined(_HAS_ITERATOR_DEBUGGING) && (_HAS_ITERATOR_DEBUGGING != 0)
+# if (defined(_HAS_ITERATOR_DEBUGGING) && (_HAS_ITERATOR_DEBUGGING != 0)) \
+    || (defined(_ITERATOR_DEBUG_LEVEL) && (_ITERATOR_DEBUG_LEVEL == 2))
 #  if !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)
 #   define BOOST_ASIO_ENABLE_BUFFER_DEBUGGING
 #  endif // !defined(BOOST_ASIO_DISABLE_BUFFER_DEBUGGING)
 # endif // defined(_HAS_ITERATOR_DEBUGGING)
 #endif // defined(BOOST_ASIO_MSVC)
 
--- boost\chrono\duration.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\chrono\duration.hpp	2017-08-21 15:30:47.000000000 -0700
@@ -432,15 +432,15 @@
     private:
         rep rep_;
     public:
 
 #if  defined   BOOST_CHRONO_DURATION_DEFAULTS_TO_ZERO
         BOOST_FORCEINLINE BOOST_CONSTEXPR
-        duration() : rep_(duration_values<rep>::zero()) { }
+        duration() BOOST_NOEXCEPT_OR_NOTHROW : rep_(duration_values<rep>::zero()) { }
 #elif  defined   BOOST_NO_CXX11_DEFAULTED_FUNCTIONS
-        BOOST_CONSTEXPR duration() {}
+        BOOST_CONSTEXPR duration() BOOST_NOEXCEPT_OR_NOTHROW {}
 #else
         BOOST_CONSTEXPR duration()  = default;
 #endif
         template <class Rep2>
         BOOST_SYMBOL_VISIBLE BOOST_FORCEINLINE BOOST_CONSTEXPR
         explicit duration(const Rep2& r
@@ -455,13 +455,13 @@
                             >
                         >
                     >
                 >::type* = 0
             ) : rep_(r) { }
 #if  defined   BOOST_NO_CXX11_DEFAULTED_FUNCTIONS
-        duration& operator=(const duration& rhs)
+        duration& operator=(const duration& rhs) BOOST_NOEXCEPT_OR_NOTHROW
         {
             if (&rhs != this) rep_= rhs.rep_;
             return *this;
         }
 #else
         duration& operator=(const duration& rhs) = default;
--- boost\config\compiler\clang.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\clang.hpp	2017-08-28 19:23:29.000000000 -0700
@@ -315,13 +315,18 @@
 #  define BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS
 #endif
 
 // Clang has supported the 'unused' attribute since the first release.
 #define BOOST_ATTRIBUTE_UNUSED __attribute__((__unused__))
 
+// Type aliasing hint.
+#if __has_attribute(__may_alias__)
+#  define BOOST_MAY_ALIAS __attribute__((__may_alias__))
+#endif
+
 #ifndef BOOST_COMPILER
 #  define BOOST_COMPILER "Clang version " __clang_version__
 #endif
 
 // Macro used to identify the Clang compiler.
 #define BOOST_CLANG 1
 
--- boost\config\compiler\cray.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\cray.hpp	2017-08-28 19:23:29.000000000 -0700
@@ -7,25 +7,25 @@
 //  See http://www.boost.org for most recent version.
 
 //  Greenhills C compiler setup:
 
 #define BOOST_COMPILER "Cray C version " BOOST_STRINGIZE(_RELEASE)
 
-#if _RELEASE < 8
+#if _RELEASE_MAJOR < 8
 #  error "Boost is not configured for Cray compilers prior to version 8, please try the configure script."
 #endif
 
 //
 // Check this is a recent EDG based compiler, otherwise we don't support it here:
 //
 #ifndef __EDG_VERSION__
 #  error "Unsupported Cray compiler, please try running the configure script."
 #endif
 
+#if _RELEASE_MINOR < 5 || __cplusplus < 201100
 #include <boost/config/compiler/common_edg.hpp>
-
 
 //
 //
 #define BOOST_NO_CXX11_STATIC_ASSERT
 #define BOOST_NO_CXX11_AUTO_DECLARATIONS
 #define BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS
@@ -87,8 +87,38 @@
 #define __ATOMIC_ACQUIRE 2
 #define __ATOMIC_RELEASE 3
 #define __ATOMIC_ACQ_REL 4
 #define __ATOMIC_SEQ_CST 5
 #endif
 
+#else  /* _RELEASE_MINOR */
 
+#define BOOST_HAS_VARIADIC_TMPL
+#define BOOST_HAS_UNISTD_H
+#define BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG
+#define BOOST_HAS_TR1_COMPLEX_OVERLOADS
+#define BOOST_HAS_STDINT_H
+#define BOOST_HAS_STATIC_ASSERT
+#define BOOST_HAS_SIGACTION
+#define BOOST_HAS_SCHED_YIELD
+#define BOOST_HAS_RVALUE_REFS
+#define BOOST_HAS_PTHREADS
+#define BOOST_HAS_PTHREAD_YIELD
+#define BOOST_HAS_PTHREAD_MUTEXATTR_SETTYPE
+#define BOOST_HAS_PARTIAL_STD_ALLOCATOR
+#define BOOST_HAS_NRVO
+#define BOOST_HAS_NL_TYPES_H
+#define BOOST_HAS_NANOSLEEP
+#define BOOST_NO_CXX11_SMART_PTR
+#define BOOST_NO_CXX11_HDR_FUNCTIONAL
+#define BOOST_NO_CXX14_CONSTEXPR
+#define BOOST_HAS_LONG_LONG
+#define BOOST_HAS_FLOAT128
 
+#if __cplusplus < 201400
+#define BOOST_NO_CXX11_DECLTYPE_N3276
+#endif /* __cpluspus */
+
+#endif /* _RELEASE_MINOR */
+
+
+
--- boost\config\compiler\gcc.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\gcc.hpp	2017-08-28 19:23:29.000000000 -0700
@@ -312,12 +312,16 @@
 
 //
 // Unused attribute:
 #if __GNUC__ >= 4
 #  define BOOST_ATTRIBUTE_UNUSED __attribute__((__unused__))
 #endif
+
+// Type aliasing hint. Supported since gcc 3.3.
+#define BOOST_MAY_ALIAS __attribute__((__may_alias__))
+
 //
 // __builtin_unreachable:
 #if BOOST_GCC_VERSION >= 40800
 #define BOOST_UNREACHABLE_RETURN(x) __builtin_unreachable();
 #endif
 
@@ -335,17 +339,17 @@
 // versions check:
 // we don't know gcc prior to version 3.30:
 #if (BOOST_GCC_VERSION< 30300)
 #  error "Compiler not configured - please reconfigure"
 #endif
 //
-// last known and checked version is 4.9:
-#if (BOOST_GCC_VERSION > 40900)
+// last known and checked version is 7.1:
+#if (BOOST_GCC_VERSION > 70100)
 #  if defined(BOOST_ASSERT_CONFIG)
-#     error "Unknown compiler version - please run the configure tests and report the results"
+#     error "Boost.Config is older than your compiler - please check for an updated Boost release."
 #  else
 // we don't emit warnings here anymore since there are no defect macros defined for
 // gcc post 3.4, so any failures are gcc regressions...
 //#     warning "Unknown compiler version - please run the configure tests and report the results"
 #  endif
 #endif
 
--- boost\config\compiler\intel.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\intel.hpp	2017-08-28 19:23:29.000000000 -0700
@@ -308,12 +308,18 @@
 //
 #if defined(__GNUC__) && (__GNUC__ >= 4)
 #  define BOOST_SYMBOL_EXPORT __attribute__((visibility("default")))
 #  define BOOST_SYMBOL_IMPORT
 #  define BOOST_SYMBOL_VISIBLE __attribute__((visibility("default")))
 #endif
+
+// Type aliasing hint
+#if defined(__GNUC__) && (BOOST_INTEL_CXX_VERSION >= 1300)
+#  define BOOST_MAY_ALIAS __attribute__((__may_alias__))
+#endif
+
 //
 // C++0x features
 // For each feature we need to check both the Intel compiler version, 
 // and the version of MSVC or GCC that we are emulating.
 // See http://software.intel.com/en-us/articles/c0x-features-supported-by-intel-c-compiler/
 // for a list of which features were implemented in which Intel releases.
@@ -542,16 +548,16 @@
 
 #endif // defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1500) && (defined(_MSC_VER) || defined(__GNUC__))
 //
 // last known and checked version:
 #if (BOOST_INTEL_CXX_VERSION > 1700)
 #  if defined(BOOST_ASSERT_CONFIG)
-#     error "Unknown compiler version - please run the configure tests and report the results"
+#     error "Boost.Config is older than your compiler - please check for an updated Boost release."
 #  elif defined(_MSC_VER)
 //
 //      We don't emit this warning any more, since we have so few
 //      defect macros set anyway (just the one).
 //
 //#     pragma message("Unknown compiler version - please run the configure tests and report the results")
 #  endif
 #endif
 
--- boost\config\compiler\nvcc.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\nvcc.hpp	2017-08-24 14:56:41.000000000 -0700
@@ -8,25 +8,32 @@
 //  NVIDIA CUDA C++ compiler setup
 
 #ifndef BOOST_COMPILER
 #  define BOOST_COMPILER "NVIDIA CUDA C++ Compiler"
 #endif
 
+#if defined(__CUDACC_VER_MAJOR__) && defined(__CUDACC_VER_MINOR__) && defined(__CUDACC_VER_BUILD__)
+#  define BOOST_CUDA_VERSION __CUDACC_VER_MAJOR__ * 1000000 + __CUDACC_VER_MINOR__ * 10000 + __CUDACC_VER_BUILD__
+#else
+// We don't really know what the CUDA version is, but it's definitely before 7.5:
+#  define BOOST_CUDA_VERSION 7000000
+#endif
+
 // NVIDIA Specific support
 // BOOST_GPU_ENABLED : Flag a function or a method as being enabled on the host and device
 #define BOOST_GPU_ENABLED __host__ __device__
 
 // A bug in version 7.0 of CUDA prevents use of variadic templates in some occasions
 // https://svn.boost.org/trac/boost/ticket/11897
 // This is fixed in 7.5. As the following version macro was introduced in 7.5 an existance
 // check is enough to detect versions < 7.5
-#if !defined(__CUDACC_VER__) || (__CUDACC_VER__ < 70500)
+#if BOOST_CUDA_VERSION < 7050000
 #   define BOOST_NO_CXX11_VARIADIC_TEMPLATES
 #endif
 // The same bug is back again in 8.0:
-#if (__CUDACC_VER__ > 80000) && (__CUDACC_VER__ < 80100)
+#if (BOOST_CUDA_VERSION > 8000000) && (BOOST_CUDA_VERSION < 8010000)
 #   define BOOST_NO_CXX11_VARIADIC_TEMPLATES
 #endif
 // Most recent CUDA (8.0) has no constexpr support in msvc mode:
 #if defined(_MSC_VER)
 #  define BOOST_NO_CXX11_CONSTEXPR
 #endif
@@ -40,12 +47,12 @@
 #  define BOOST_NO_CXX11_UNICODE_LITERALS
 #endif
 //
 // And this one effects the NVCC front end,
 // See https://svn.boost.org/trac/boost/ticket/13049
 //
-#if (__CUDACC_VER__ >= 80000) && (__CUDACC_VER__ < 80100)
+#if (BOOST_CUDA_VERSION >= 8000000) && (BOOST_CUDA_VERSION < 8010000)
 #  define BOOST_NO_CXX11_NOEXCEPT
 #endif
 
 #endif
 
--- boost\config\compiler\pgi.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\pgi.hpp	2017-08-28 19:23:29.000000000 -0700
@@ -1,168 +1,23 @@
 //  (C) Copyright Noel Belcourt 2007.
+//  Copyright 2017, NVIDIA CORPORATION.
 //  Use, modification and distribution are subject to the
 //  Boost Software License, Version 1.0. (See accompanying file
 //  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 //  See http://www.boost.org for most recent version.
 
 //  PGI C++ compiler setup:
 
 #define BOOST_COMPILER_VERSION __PGIC__##__PGIC_MINOR__
 #define BOOST_COMPILER "PGI compiler version " BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
 
-//
-// Threading support:
-// Turn this on unconditionally here, it will get turned off again later
-// if no threading API is detected.
-//
-
-#if __PGIC__ >= 11
-
-// options requested by configure --enable-test
-#define BOOST_HAS_PTHREADS
-#define BOOST_HAS_THREADS
-#define BOOST_HAS_PTHREAD_YIELD
-#define BOOST_HAS_NRVO
-#define BOOST_HAS_LONG_LONG
+// PGI is mostly GNU compatible.  So start with that.
+#include <boost/config/compiler/gcc.hpp>
 
-// options --enable-test wants undefined
-#undef BOOST_NO_STDC_NAMESPACE
-#undef BOOST_NO_EXCEPTION_STD_NAMESPACE
-#undef BOOST_DEDUCED_TYPENAME
+// Now adjust for things that are different.
 
-#define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
-#define BOOST_NO_TWO_PHASE_NAME_LOOKUP
-#define BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS
-#define BOOST_NO_CXX11_AUTO_DECLARATIONS
-
-#elif __PGIC__ >= 10
-
-// options requested by configure --enable-test
-#define BOOST_HAS_THREADS
-#define BOOST_HAS_NRVO
-#define BOOST_HAS_LONG_LONG
-#if defined(linux) || defined(__linux) || defined(__linux__)
-#  define BOOST_HAS_STDINT_H
-#endif
+// __float128 is a typedef, not a distinct type.
+#undef BOOST_HAS_FLOAT128
 
-// options --enable-test wants undefined
-#undef BOOST_NO_STDC_NAMESPACE
-#undef BOOST_NO_EXCEPTION_STD_NAMESPACE
-#undef BOOST_DEDUCED_TYPENAME
-
-#elif __PGIC__ >= 7
-
-#define BOOST_FUNCTION_SCOPE_USING_DECLARATION_BREAKS_ADL
-#define BOOST_NO_TWO_PHASE_NAME_LOOKUP
-#define BOOST_NO_SWPRINTF
-#define BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS
-#define BOOST_NO_CXX11_AUTO_DECLARATIONS
-
-#else
-
-#  error "Pgi compiler not configured - please reconfigure"
-
-#endif
-//
-// C++0x features
-//
-//   See boost\config\suffix.hpp for BOOST_NO_LONG_LONG
-//
-#define BOOST_NO_CXX11_CHAR16_T
-#define BOOST_NO_CXX11_CHAR32_T
-#define BOOST_NO_CXX11_CONSTEXPR
-#define BOOST_NO_CXX11_DECLTYPE
-#define BOOST_NO_CXX11_DECLTYPE_N3276
-#define BOOST_NO_CXX11_DEFAULTED_FUNCTIONS
-#define BOOST_NO_CXX11_DELETED_FUNCTIONS
-#define BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS
-#define BOOST_NO_CXX11_EXTERN_TEMPLATE
-#define BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS
-#define BOOST_NO_CXX11_LAMBDAS
-#define BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS
-#define BOOST_NO_CXX11_NOEXCEPT
-#define BOOST_NO_CXX11_NULLPTR
-#define BOOST_NO_CXX11_NUMERIC_LIMITS
-#define BOOST_NO_CXX11_RANGE_BASED_FOR
-#define BOOST_NO_CXX11_RAW_LITERALS
-#define BOOST_NO_CXX11_RVALUE_REFERENCES
-#define BOOST_NO_CXX11_SCOPED_ENUMS
-#define BOOST_NO_SFINAE_EXPR
-#define BOOST_NO_CXX11_SFINAE_EXPR
-#define BOOST_NO_CXX11_STATIC_ASSERT
-#define BOOST_NO_SWPRINTF
-#define BOOST_NO_CXX11_TEMPLATE_ALIASES
-#define BOOST_NO_CXX11_UNICODE_LITERALS
-#define BOOST_NO_CXX11_VARIADIC_TEMPLATES
-#define BOOST_NO_CXX11_VARIADIC_MACROS
-#define BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX
-
-#define BOOST_NO_CXX11_HDR_UNORDERED_SET
-#define BOOST_NO_CXX11_HDR_UNORDERED_MAP
-#define BOOST_NO_CXX11_HDR_TYPEINDEX
-#define BOOST_NO_CXX11_HDR_TYPE_TRAITS
-#define BOOST_NO_CXX11_HDR_TUPLE
-#define BOOST_NO_CXX11_HDR_THREAD
-#define BOOST_NO_CXX11_HDR_SYSTEM_ERROR
-#define BOOST_NO_CXX11_HDR_REGEX
-#define BOOST_NO_CXX11_HDR_RATIO
-#define BOOST_NO_CXX11_HDR_RANDOM
-#define BOOST_NO_CXX11_HDR_MUTEX
-#define BOOST_NO_CXX11_HDR_INITIALIZER_LIST
-#define BOOST_NO_CXX11_HDR_FUTURE
-#define BOOST_NO_CXX11_HDR_FORWARD_LIST
-#define BOOST_NO_CXX11_HDR_CONDITION_VARIABLE
-#define BOOST_NO_CXX11_HDR_CODECVT
-#define BOOST_NO_CXX11_HDR_CHRONO
-#define BOOST_NO_CXX11_HDR_ARRAY
-#define BOOST_NO_CXX11_USER_DEFINED_LITERALS
-#define BOOST_NO_CXX11_ALIGNAS
-#define BOOST_NO_CXX11_TRAILING_RESULT_TYPES
-#define BOOST_NO_CXX11_INLINE_NAMESPACES
-#define BOOST_NO_CXX11_REF_QUALIFIERS
-#define BOOST_NO_CXX11_FINAL
-#define BOOST_NO_CXX11_THREAD_LOCAL
-
-// C++ 14:
-#if !defined(__cpp_aggregate_nsdmi) || (__cpp_aggregate_nsdmi < 201304)
-#  define BOOST_NO_CXX14_AGGREGATE_NSDMI
-#endif
-#if !defined(__cpp_binary_literals) || (__cpp_binary_literals < 201304)
-#  define BOOST_NO_CXX14_BINARY_LITERALS
-#endif
-#if !defined(__cpp_constexpr) || (__cpp_constexpr < 201304)
-#  define BOOST_NO_CXX14_CONSTEXPR
-#endif
-#if !defined(__cpp_decltype_auto) || (__cpp_decltype_auto < 201304)
-#  define BOOST_NO_CXX14_DECLTYPE_AUTO
-#endif
-#if (__cplusplus < 201304) // There's no SD6 check for this....
-#  define BOOST_NO_CXX14_DIGIT_SEPARATORS
-#endif
-#if !defined(__cpp_generic_lambdas) || (__cpp_generic_lambdas < 201304)
-#  define BOOST_NO_CXX14_GENERIC_LAMBDAS
-#endif
-#if !defined(__cpp_init_captures) || (__cpp_init_captures < 201304)
-#  define BOOST_NO_CXX14_INITIALIZED_LAMBDA_CAPTURES
-#endif
-#if !defined(__cpp_return_type_deduction) || (__cpp_return_type_deduction < 201304)
-#  define BOOST_NO_CXX14_RETURN_TYPE_DEDUCTION
-#endif
-#if !defined(__cpp_variable_templates) || (__cpp_variable_templates < 201304)
-#  define BOOST_NO_CXX14_VARIABLE_TEMPLATES
-#endif
-
-// C++17
-#if !defined(__cpp_structured_bindings) || (__cpp_structured_bindings < 201606)
-#  define BOOST_NO_CXX17_STRUCTURED_BINDINGS
-#endif
-#if !defined(__cpp_inline_variables) || (__cpp_inline_variables < 201606)
-#  define BOOST_NO_CXX17_INLINE_VARIABLES
-#endif
-#if !defined(__cpp_fold_expressions) || (__cpp_fold_expressions < 201603)
-#  define BOOST_NO_CXX17_FOLD_EXPRESSIONS
-#endif
-//
-// version check:
-// probably nothing to do here?
-
+// __int128 is not supported.
+#undef BOOST_HAS_INT128
--- boost\config\compiler\sunpro_cc.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\sunpro_cc.hpp	2017-08-24 14:59:12.000000000 -0700
@@ -199,12 +199,12 @@
 // versions check:
 // we don't support sunpro prior to version 4:
 #if __SUNPRO_CC < 0x400
 #error "Compiler not supported or configured - please reconfigure"
 #endif
 //
-// last known and checked version is 0x590:
-#if (__SUNPRO_CC > 0x590)
+// last known and checked version:
+#if (__SUNPRO_CC > 0x5150)
 #  if defined(BOOST_ASSERT_CONFIG)
-#     error "Unknown compiler version - please run the configure tests and report the results"
+#     error "Boost.Config is older than your compiler - please check for an updated Boost release."
 #  endif
 #endif
--- boost\config\compiler\vacpp.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\vacpp.hpp	2017-08-28 19:23:29.000000000 -0700
@@ -62,12 +62,17 @@
 
 // Some versions of the compiler have issues with default arguments on partial specializations
 #if __IBMCPP__ <= 1010
 #define BOOST_NO_PARTIAL_SPECIALIZATION_IMPLICIT_DEFAULT_ARGS
 #endif
 
+// Type aliasing hint. Supported since XL C++ 13.1
+#if (__IBMCPP__ >= 1310)
+#  define BOOST_MAY_ALIAS __attribute__((__may_alias__))
+#endif
+
 //
 // C++0x features
 //
 //   See boost\config\suffix.hpp for BOOST_NO_LONG_LONG
 //
 #if ! __IBMCPP_AUTO_TYPEDEDUCTION
--- boost\config\compiler\visualc.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\visualc.hpp	2017-08-24 15:01:53.000000000 -0700
@@ -104,17 +104,26 @@
 #  define BOOST_NO_RTTI
 #endif
 
 //
 // TR1 features:
 //
-#if (_MSC_VER >= 1700) && defined(_HAS_CXX17) && (_HAS_CXX17 > 0)
-// # define BOOST_HAS_TR1_HASH			// don't know if this is true yet.
-// # define BOOST_HAS_TR1_TYPE_TRAITS	// don't know if this is true yet.
-# define BOOST_HAS_TR1_UNORDERED_MAP
-# define BOOST_HAS_TR1_UNORDERED_SET
+#if (_MSC_VER >= 1700)
+#  define BOOST_HAS_TR1_HASH
+#  define BOOST_HAS_TR1_TYPE_TRAITS
+#  define BOOST_HAS_TR1_UNORDERED_MAP
+#  define BOOST_HAS_TR1_UNORDERED_SET
+#endif
+#if (_MSC_FULL_VER >= 190024210) && \
+    ((defined(_HAS_TR1_NAMESPACE) && !_HAS_TR1_NAMESPACE) || (!defined(_HAS_TR1_NAMESPACE) && \
+        ((defined(_HAS_CXX17) && _HAS_CXX17) || (!defined(_HAS_CXX17) && \
+            defined(_MSVC_LANG) && (_MSVC_LANG > 201402)))))
+#  undef BOOST_HAS_TR1_HASH
+#  undef BOOST_HAS_TR1_TYPE_TRAITS
+#  undef BOOST_HAS_TR1_UNORDERED_MAP
+#  undef BOOST_HAS_TR1_UNORDERED_SET
 #endif
 
 //
 // C++0x features
 //
 //   See above for BOOST_NO_LONG_LONG
@@ -187,16 +196,27 @@
 #if (_MSC_FULL_VER < 190024210)
 #  define BOOST_NO_CXX14_VARIABLE_TEMPLATES
 #  define BOOST_NO_SFINAE_EXPR
 #  define BOOST_NO_CXX11_CONSTEXPR
 #endif
 
-// C++14 features supported by VC++ 14.1 (Visual Studio 2017)
+// C++14 features supported by VC++ 14.10 (Visual Studio 2017)
 //
 #if (_MSC_VER < 1910)
 #  define BOOST_NO_CXX14_AGGREGATE_NSDMI
+#endif
+
+// C++17 features supported by VC++ 14.11 (Visual Studio 2017 Update 3)
+//
+#if (_MSC_VER < 1911)
+#  define BOOST_NO_CXX11_SFINAE_EXPR
+#  define BOOST_NO_CXX14_CONSTEXPR
+#  define BOOST_NO_CXX17_STRUCTURED_BINDINGS
+#elif (defined(_HAS_CXX17) && !_HAS_CXX17) || (!defined(_HAS_CXX17) && \
+        (!defined(_MSVC_LANG) || (_MSVC_LANG <= 201402)))
+#  define BOOST_NO_CXX17_STRUCTURED_BINDINGS
 #endif
 
 // MSVC including version 14 has not yet completely
 // implemented value-initialization, as is reported:
 // "VC++ does not value-initialize members of derived classes without
 // user-declared constructor", reported in 2009 by Sylvester Hesp:
@@ -209,21 +229,15 @@
 // https://connect.microsoft.com/VisualStudio/feedback/details/100744
 // Reported again by John Maddock in 2015 for VC14:
 // https://connect.microsoft.com/VisualStudio/feedback/details/1582233/c-subobjects-still-not-value-initialized-correctly
 // See also: http://www.boost.org/libs/utility/value_init.htm#compiler_issues
 // (Niels Dekker, LKEB, May 2010)
 #define BOOST_NO_COMPLETE_VALUE_INITIALIZATION
-//
-// C++ 11:
-//
+// C++:
 #define BOOST_NO_TWO_PHASE_NAME_LOOKUP
-#define BOOST_NO_CXX11_SFINAE_EXPR
-// C++ 14:
-#  define BOOST_NO_CXX14_CONSTEXPR
 // C++ 17:
-#define BOOST_NO_CXX17_STRUCTURED_BINDINGS
 #define BOOST_NO_CXX17_INLINE_VARIABLES
 #define BOOST_NO_CXX17_FOLD_EXPRESSIONS
 
 //
 // Things that don't work in clr mode:
 //
@@ -286,13 +300,13 @@
 #         error "Unknown EVC++ compiler version - please run the configure tests and report the results"
 #      else
 #         pragma message("Unknown EVC++ compiler version - please run the configure tests and report the results")
 #      endif
 #   endif
 # else
-#   if _MSC_VER < 1310
+#   if _MSC_VER < 1200
       // Note: Versions up to 7.0 aren't supported.
 #     define BOOST_COMPILER_VERSION 5.0
 #   elif _MSC_VER < 1300
 #     define BOOST_COMPILER_VERSION 6.0
 #   elif _MSC_VER < 1310
 #     define BOOST_COMPILER_VERSION 7.0
@@ -307,25 +321,27 @@
 #   elif _MSC_VER < 1800 
 #     define BOOST_COMPILER_VERSION 11.0
 #   elif _MSC_VER < 1900
 #     define BOOST_COMPILER_VERSION 12.0
 #   elif _MSC_VER < 1910
 #     define BOOST_COMPILER_VERSION 14.0
+#   elif _MSC_VER < 1911
+#     define BOOST_COMPILER_VERSION 14.10
 #   elif _MSC_VER < 1920
-#     define BOOST_COMPILER_VERSION 14.1
+#     define BOOST_COMPILER_VERSION 14.11
 #   else
 #     define BOOST_COMPILER_VERSION _MSC_VER
 #   endif
 # endif
 
 #  define BOOST_COMPILER "Microsoft Visual C++ version " BOOST_STRINGIZE(BOOST_COMPILER_VERSION)
 #endif
 
 //
-// last known and checked version is 19.10.25017 (VC++ 2017):
-#if (_MSC_VER > 1910)
+// last known and checked version is 19.11.25506 (VC++ 2017.3):
+#if (_MSC_VER > 1911)
 #  if defined(BOOST_ASSERT_CONFIG)
-#     error "Unknown compiler version - please run the configure tests and report the results"
-#  else
-#     pragma message("Unknown compiler version - please run the configure tests and report the results")
+#     error "Boost.Config is older than your current compiler version."
+#  elif !defined(BOOST_CONFIG_SUPPRESS_OUTDATED_MESSAGE)
+#     pragma message("Info: Boost.Config is older than your compiler version - probably nothing bad will happen - but you may wish to look for an update Boost version.  Define BOOST_CONFIG_SUPPRESS_OUTDATED_MESSAGE to suppress this message.")
 #  endif
 #endif
--- boost\config\compiler\xlcpp.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\xlcpp.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -264,13 +264,18 @@
 
 // Unused attribute:
 #if defined(__GNUC__) && (__GNUC__ >= 4)
 #  define BOOST_ATTRIBUTE_UNUSED __attribute__((unused))
 #endif
 
+// Type aliasing hint.
+#if __has_attribute(__may_alias__)
+#  define BOOST_MAY_ALIAS __attribute__((__may_alias__))
+#endif
+
 #ifndef BOOST_COMPILER
 #  define BOOST_COMPILER "Clang version " __clang_version__
 #endif
 
 // Macro used to identify the Clang compiler.
 #define BOOST_CLANG 1
 
--- boost\config\compiler\xlcpp_zos.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\compiler\xlcpp_zos.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -156,13 +156,14 @@
 
 // -------------------------------------
 
 #if defined(__IBM_ATTRIBUTES)
 #  define BOOST_FORCEINLINE inline __attribute__ ((__always_inline__))
 #  define BOOST_NOINLINE __attribute__ ((__noinline__))
+#  define BOOST_MAY_ALIAS __attribute__((__may_alias__))
 // No BOOST_ALIGNMENT - explicit alignment support is broken (V2R1).
 #endif
 
 extern "builtin" long __builtin_expect(long, long);
 
 #define BOOST_LIKELY(x) __builtin_expect((x) && true, 1)
 #define BOOST_UNLIKELY(x) __builtin_expect((x) && true, 0)
--- boost\config\detail\select_compiler_config.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\detail\select_compiler_config.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -49,12 +49,16 @@
 #   define BOOST_COMPILER_CONFIG "boost/config/compiler/digitalmars.hpp"
 
 #elif defined __DCC__
 //  Wind River Diab C++
 #   define BOOST_COMPILER_CONFIG "boost/config/compiler/diab.hpp"
 
+#elif defined(__PGI)
+//  Portland Group Inc.
+#   define BOOST_COMPILER_CONFIG "boost/config/compiler/pgi.hpp"
+
 # elif defined(__GNUC__) && !defined(__ibmxl__)
 //  GNU C++:
 #   define BOOST_COMPILER_CONFIG "boost/config/compiler/gcc.hpp"
 
 #elif defined __KCC
 //  Kai C++
@@ -105,16 +109,12 @@
 #   define BOOST_COMPILER_CONFIG "boost/config/compiler/xlcpp.hpp"
 
 #elif defined(__IBMCPP__)
 //  IBM Visual Age or IBM XL C/C++ for Linux (Big Endian)
 #   define BOOST_COMPILER_CONFIG "boost/config/compiler/vacpp.hpp"
 
-#elif defined(__PGI)
-//  Portland Group Inc.
-#   define BOOST_COMPILER_CONFIG "boost/config/compiler/pgi.hpp"
-
 #elif defined _MSC_VER
 //  Microsoft Visual C++
 //
 //  Must remain the last #elif since some other vendors (Metrowerks, for
 //  example) also #define _MSC_VER
 #   define BOOST_COMPILER_CONFIG "boost/config/compiler/visualc.hpp"
--- boost\config\detail\suffix.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\detail\suffix.hpp	2017-08-28 19:27:01.000000000 -0700
@@ -599,12 +599,20 @@
 #    if !defined(BOOST_NO_RESTRICT_REFERENCES)
 #      define BOOST_NO_RESTRICT_REFERENCES
 #    endif
 #  endif
 #endif
 
+// BOOST_MAY_ALIAS -----------------------------------------------//
+// The macro expands to an attribute to mark a type that is allowed to alias other types.
+// The macro is defined in the compiler-specific headers.
+#if !defined(BOOST_MAY_ALIAS)
+#  define BOOST_NO_MAY_ALIAS
+#  define BOOST_MAY_ALIAS
+#endif
+
 // BOOST_FORCEINLINE ---------------------------------------------//
 // Macro to use in place of 'inline' to force a function to be inline
 #if !defined(BOOST_FORCEINLINE)
 #  if defined(_MSC_VER)
 #    define BOOST_FORCEINLINE __forceinline
 #  elif defined(__GNUC__) && __GNUC__ > 3
@@ -1022,17 +1030,23 @@
 // BOOST_NO_CXX11_VARIADIC_TEMPLATES is set:
 //
 #if defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS)
 #  define BOOST_NO_CXX11_FIXED_LENGTH_VARIADIC_TEMPLATE_EXPANSION_PACKS
 #endif
 
+#if defined(BOOST_MSVC) && BOOST_MSVC_FULL_VER >= 190023918
+#  define BOOST_EMPTYBASES __declspec(empty_bases)
+#else
+#  define BOOST_EMPTYBASES
+#endif
+
 //
 // Finish off with checks for macros that are depricated / no longer supported,
 // if any of these are set then it's very likely that much of Boost will no
 // longer work.  So stop with a #error for now, but give the user a chance
 // to continue at their own risk if they really want to:
 //
 #if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_CONFIG_ALLOW_DEPRECATED)
 #  error "You are using a compiler which lacks features which are now a minimum requirement in order to use Boost, define BOOST_CONFIG_ALLOW_DEPRECATED if you want to continue at your own risk!!!"
 #endif
 
 #endif
--- boost\config\stdlib\dinkumware.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\dinkumware.hpp	2017-08-28 20:38:02.000000000 -0700
@@ -145,15 +145,15 @@
 #  define BOOST_NO_CXX11_ALLOCATOR
 // 540 has std::align but it is not a conforming implementation
 #  define BOOST_NO_CXX11_STD_ALIGN
 #endif
 
 // Before 650 std::pointer_traits has a broken rebind template
-#if !defined(_CPPLIB_VER) || _CPPLIB_VER < 650
+#if !defined(_CPPLIB_VER) || (_CPPLIB_VER < 650)
 #  define BOOST_NO_CXX11_POINTER_TRAITS
-#elif defined(BOOST_MSVC) && BOOST_MSVC < 1910
+#elif (defined(BOOST_MSVC) || (defined(__clang__) && defined(_MSC_VER))) && (_MSC_VER < 1910)
 #  define BOOST_NO_CXX11_POINTER_TRAITS
 #endif
 
 #if defined(__has_include)
 #if !__has_include(<shared_mutex>)
 #  define BOOST_NO_CXX14_HDR_SHARED_MUTEX
@@ -167,17 +167,22 @@
 // C++14 features
 #if !defined(_CPPLIB_VER) || (_CPPLIB_VER < 650)
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 #endif
 
 // C++17 features
-#if !defined(_CPPLIB_VER) || (_CPPLIB_VER < 650) || !defined(BOOST_MSVC) || (BOOST_MSVC < 1910) || !defined(_HAS_CXX17) || (_HAS_CXX17 == 0)
+#if !(defined(_CPPLIB_VER) && (_CPPLIB_VER >= 650) && \
+      defined(_MSC_VER) && (_MSC_VER >= 1910) && \
+      ((defined(__clang__) && (__cplusplus > 201402)) || \
+       (defined(BOOST_MSVC) && ((defined(_HAS_CXX17) && _HAS_CXX17) || (!defined(_HAS_CXX17) && \
+          defined(_MSVC_LANG) && (_MSVC_LANG > 201402))))))
 #  define BOOST_NO_CXX17_STD_APPLY
 #endif
 #if !defined(_CPPLIB_VER) || (_CPPLIB_VER < 650)
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 #endif
 
 #if defined(BOOST_INTEL) && (BOOST_INTEL <= 1400)
 // Intel's compiler can't handle this header yet:
 #  define BOOST_NO_CXX11_HDR_ATOMIC
 #endif
@@ -197,13 +202,16 @@
 #endif
 
 #if defined(_CPPLIB_VER) && (_CPPLIB_VER >= 650)
 // If _HAS_AUTO_PTR_ETC is defined to 0, std::auto_ptr and std::random_shuffle are not available.
 // See https://www.visualstudio.com/en-us/news/vs2015-vs.aspx#C++
 // and http://blogs.msdn.com/b/vcblog/archive/2015/06/19/c-11-14-17-features-in-vs-2015-rtm.aspx
-#  if defined(_HAS_AUTO_PTR_ETC) && (_HAS_AUTO_PTR_ETC == 0)
+#  if (defined(_HAS_AUTO_PTR_ETC) && !_HAS_AUTO_PTR_ETC) || (!defined(_HAS_AUTO_PTR_ETC) && \
+        ((defined(_HAS_CXX17) && _HAS_CXX17) || (!defined(_HAS_CXX17) && \
+          ((defined(BOOST_MSVC) && defined(_MSVC_LANG) && (_MSVC_LANG > 201402)) || \
+           (defined(__clang__) && (__cplusplus > 201402))))))
 #    define BOOST_NO_AUTO_PTR
 #    define BOOST_NO_CXX98_RANDOM_SHUFFLE
 #    define BOOST_NO_CXX98_FUNCTION_BASE
 #    define BOOST_NO_CXX98_BINDERS
 #  endif
 #endif
--- boost\config\stdlib\libcomo.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\libcomo.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -76,16 +76,17 @@
 // C++14 features
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 
 // C++17 features
 #  define BOOST_NO_CXX17_STD_APPLY
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 
 //
 // Intrinsic type_traits support.
 // The SGI STL has it's own __type_traits class, which
 // has intrinsic compiler support with SGI's compilers.
 // Whatever map SGI style type traits to boost equivalents:
 //
 #define BOOST_HAS_SGI_TYPE_TRAITS
 
 #define BOOST_STDLIB "Comeau standard library " BOOST_STRINGIZE(__LIBCOMO_VERSION__)
--- boost\config\stdlib\libcpp.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\libcpp.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -100,12 +100,14 @@
 #  define BOOST_NO_CXX98_RANDOM_SHUFFLE
 #endif
 #if (_LIBCPP_VERSION > 4000) && (__cplusplus > 201402L) && !defined(_LIBCPP_ENABLE_CXX17_REMOVED_BINDERS)
 #  define BOOST_NO_CXX98_BINDERS
 #endif
 
+#define BOOST_NO_CXX17_ITERATOR_TRAITS
+
 #if (_LIBCPP_VERSION <= 1101) && !defined(BOOST_NO_CXX11_THREAD_LOCAL)
 // This is a bit of a sledgehammer, because really it's just libc++abi that has no
 // support for thread_local, leading to linker errors such as
 // "undefined reference to `__cxa_thread_atexit'".  It is fixed in the
 // most recent releases of libc++abi though...
 #  define BOOST_NO_CXX11_THREAD_LOCAL
--- boost\config\stdlib\libstdcpp3.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\libstdcpp3.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -244,12 +244,13 @@
 
 //  C++0x features in GCC 4.6.0 and later
 //
 #if (BOOST_LIBSTDCXX_VERSION < 40600) || !defined(BOOST_LIBSTDCXX11)
 #  define BOOST_NO_CXX11_HDR_TYPEINDEX
 #  define BOOST_NO_CXX11_ADDRESSOF
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 #endif
 
 //  C++0x features in GCC 4.7.0 and later
 //
 #if (BOOST_LIBSTDCXX_VERSION < 40700) || !defined(BOOST_LIBSTDCXX11)
 // Note that although <chrono> existed prior to 4.7, "steady_clock" is spelled "monotonic_clock"
--- boost\config\stdlib\modena.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\modena.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -65,13 +65,14 @@
 // C++14 features
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 
 // C++17 features
 #  define BOOST_NO_CXX17_STD_APPLY
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 
 #define BOOST_STDLIB "Modena C++ standard library"
 
 
 
 
 
--- boost\config\stdlib\msl.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\msl.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -89,8 +89,9 @@
 // C++14 features
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 
 // C++17 features
 #  define BOOST_NO_CXX17_STD_APPLY
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 
 #define BOOST_STDLIB "Metrowerks Standard Library version " BOOST_STRINGIZE(__MSL_CPP__)
--- boost\config\stdlib\roguewave.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\roguewave.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -201,6 +201,7 @@
 // C++14 features
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 
 // C++17 features
 #  define BOOST_NO_CXX17_STD_APPLY
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
--- boost\config\stdlib\sgi.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\sgi.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -159,8 +159,9 @@
 // C++14 features
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 
 // C++17 features
 #  define BOOST_NO_CXX17_STD_APPLY
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 
 #define BOOST_STDLIB "SGI standard library"
--- boost\config\stdlib\stlport.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\stlport.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -249,8 +249,9 @@
 // C++14 features
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 
 // C++17 features
 #  define BOOST_NO_CXX17_STD_APPLY
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 
 #define BOOST_STDLIB "STLPort standard library version " BOOST_STRINGIZE(__SGI_STL_PORT)
--- boost\config\stdlib\vacpp.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\vacpp.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -65,8 +65,9 @@
 // C++14 features
 #  define BOOST_NO_CXX14_STD_EXCHANGE
 
 // C++17 features
 #  define BOOST_NO_CXX17_STD_APPLY
 #  define BOOST_NO_CXX17_STD_INVOKE
+#  define BOOST_NO_CXX17_ITERATOR_TRAITS
 
 #define BOOST_STDLIB "Visual Age default standard library"
--- boost\config\stdlib\xlcpp_zos.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\config\stdlib\xlcpp_zos.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -54,6 +54,7 @@
 
 #define BOOST_NO_CXX14_STD_EXCHANGE
 #define BOOST_NO_CXX14_HDR_SHARED_MUTEX
 
 #define BOOST_NO_CXX17_STD_INVOKE
 #define BOOST_NO_CXX17_STD_APPLY
+#define BOOST_NO_CXX17_ITERATOR_TRAITS
--- boost\container\flat_map.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\container\flat_map.hpp	2017-08-21 15:37:00.000000000 -0700
@@ -196,12 +196,13 @@
    //
    //////////////////////////////////////////////
 
    //! <b>Effects</b>: Default constructs an empty flat_map.
    //!
    //! <b>Complexity</b>: Constant.
+   BOOST_CONTAINER_FORCEINLINE
    flat_map() BOOST_NOEXCEPT_IF(container_detail::is_nothrow_default_constructible<Allocator>::value &&
                                 container_detail::is_nothrow_default_constructible<Compare>::value)
       : m_flat_tree()
    {}
 
    //! <b>Effects</b>: Constructs an empty flat_map using the specified allocator.
--- boost\container\flat_set.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\container\flat_set.hpp	2017-08-21 15:37:53.000000000 -0700
@@ -124,14 +124,14 @@
    //////////////////////////////////////////////
 
    //! <b>Effects</b>: Default constructs an empty container.
    //!
    //! <b>Complexity</b>: Constant.
    BOOST_CONTAINER_FORCEINLINE
-   explicit flat_set() BOOST_NOEXCEPT_IF(container_detail::is_nothrow_default_constructible<Allocator>::value &&
-                                         container_detail::is_nothrow_default_constructible<Compare>::value)
+   flat_set() BOOST_NOEXCEPT_IF(container_detail::is_nothrow_default_constructible<Allocator>::value &&
+                                container_detail::is_nothrow_default_constructible<Compare>::value)
       : base_t()
    {}
 
    //! <b>Effects</b>: Constructs an empty container using the specified
    //! comparison object.
    //!
@@ -1078,14 +1078,15 @@
    typedef typename BOOST_CONTAINER_IMPDEF(base_t::const_iterator)                     const_iterator;
    typedef typename BOOST_CONTAINER_IMPDEF(base_t::reverse_iterator)                   reverse_iterator;
    typedef typename BOOST_CONTAINER_IMPDEF(base_t::const_reverse_iterator)             const_reverse_iterator;
    typedef typename BOOST_CONTAINER_IMPDEF(base_t::sequence_type)                      sequence_type;
 
    //! @copydoc ::boost::container::flat_set::flat_set()
-   BOOST_CONTAINER_FORCEINLINE explicit flat_multiset() BOOST_NOEXCEPT_IF(container_detail::is_nothrow_default_constructible<Allocator>::value &&
-                                              container_detail::is_nothrow_default_constructible<Compare>::value)
+   BOOST_CONTAINER_FORCEINLINE
+   flat_multiset() BOOST_NOEXCEPT_IF(container_detail::is_nothrow_default_constructible<Allocator>::value &&
+                                     container_detail::is_nothrow_default_constructible<Compare>::value)
       : base_t()
    {}
 
    //! @copydoc ::boost::container::flat_set::flat_set(const Compare&)
    BOOST_CONTAINER_FORCEINLINE explicit flat_multiset(const Compare& comp)
       : base_t(comp)
--- boost\context\detail\config.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\context\detail\config.hpp	2017-08-21 15:38:39.000000000 -0700
@@ -62,16 +62,16 @@
 // use rd6 macros for std::integer_sequence
 #if defined(__cpp_lib_integer_sequence) && __cpp_lib_integer_sequence >= 201304
 # undef BOOST_CONTEXT_NO_CXX14_INTEGER_SEQUENCE
 #endif
 // workaroud: MSVC 14 does not provide macros to test for compile-time integer sequence
 #if _MSC_VER > 1800 // _MSC_VER == 1800 -> MS Visual Studio 2013
-# undef BOOST_CONTEXT_NO_INDEX_SEQUENCE
+# undef BOOST_CONTEXT_NO_CXX14_INTEGER_SEQUENCE
 #endif
 // workaround: Xcode clang feature detection
-#if ! defined(__cpp_lib_integer_sequence) && __cpp_lib_integer_sequence >= 201304
+#if ! defined(__cpp_lib_integer_sequence) && defined(_LIBCPP_STD_VER)
 # if _LIBCPP_STD_VER > 11
 #  undef BOOST_CONTEXT_NO_CXX14_INTEGER_SEQUENCE
 # endif
 #endif
 
 // workaroud: MSVC 14 does support constexpr
--- boost\context\continuation_fcontext.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\context\continuation_fcontext.hpp	2017-08-25 01:20:20.000000000 -0700
@@ -92,13 +92,13 @@
     auto p = static_cast< std::tuple< Fn > * >( t.data);
     BOOST_ASSERT( nullptr != p);
     typename std::decay< Fn >::type fn = std::get< 0 >( * p);
     t.data = nullptr;
     Ctx c{ t.fctx };
     // execute function, pass continuation via reference
-    fn( std::move( c) );
+    c = fn( std::move( c) );
 #if defined(BOOST_NO_CXX14_STD_EXCHANGE)
     return { exchange( c.fctx_, nullptr), nullptr };
 #else
     return { std::exchange( c.fctx_, nullptr), nullptr };
 #endif
 }
--- boost\context\continuation_ucontext.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\context\continuation_ucontext.hpp	2017-08-25 01:21:28.000000000 -0700
@@ -81,24 +81,24 @@
     record->run();
 }
 
 struct BOOST_CONTEXT_DECL activation_record {
     thread_local static activation_record   *   current_rec;
 
-    ucontext_t                                  uctx{};
-    stack_context                               sctx{};
-    bool                                        main_ctx{ true };
-	activation_record                       *	from{ nullptr };
-    std::function< void(activation_record*&) >  ontop{};
-    bool                                        terminated{ false };
-    bool                                        force_unwind{ false };
+    ucontext_t                                                  uctx{};
+    stack_context                                               sctx{};
+    bool                                                        main_ctx{ true };
+	activation_record                                       *	from{ nullptr };
+    std::function< activation_record*(activation_record*&) >    ontop{};
+    bool                                                        terminated{ false };
+    bool                                                        force_unwind{ false };
 #if defined(BOOST_USE_ASAN)
-    void                                    *   fake_stack{ nullptr };
-    void                                    *   stack_bottom{ nullptr };
-    std::size_t                                 stack_size{ 0 };
-    bool                                        started{ false };
+    void                                                    *   fake_stack{ nullptr };
+    void                                                    *   stack_bottom{ nullptr };
+    std::size_t                                                 stack_size{ 0 };
+    bool                                                        started{ false };
 #endif
 
     static activation_record *& current() noexcept;
 
     // used for toplevel-context
     // (e.g. main context, thread-entry context)
@@ -165,26 +165,36 @@
         // returned by continuation::current()
         current() = this;
 #if defined(BOOST_NO_CXX14_GENERIC_LAMBDAS)
         current()->ontop = std::bind(
                 [](typename std::decay< Fn >::type & fn, activation_record *& ptr){
                     Ctx c{ ptr };
-                    fn( std::move( c) );
+                    c = fn( std::move( c) );
                     if ( ! c) {
                         ptr = nullptr;
                     }
+#if defined(BOOST_NO_CXX14_STD_EXCHANGE)
+                    return exchange( c.ptr_, nullptr);
+#else
+                    return std::exchange( c.ptr_, nullptr);
+#endif
                 },
                 std::forward< Fn >( fn),
                 std::placeholders::_1);
 #else
         current()->ontop = [fn=std::forward<Fn>(fn)](activation_record *& ptr){
             Ctx c{ ptr };
-            fn( std::move( c) );
+            c = fn( std::move( c) );
             if ( ! c) {
                 ptr = nullptr;
             }
+#if defined(BOOST_NO_CXX14_STD_EXCHANGE)
+            return exchange( c.ptr_, nullptr);
+#else
+            return std::exchange( c.ptr_, nullptr);
+#endif
         };
 #endif
 #if defined(BOOST_USE_SEGMENTED_STACKS)
         // adjust segmented stack properties
         __splitstack_getcontext( from->sctx.segments_ctx);
         __splitstack_setcontext( sctx.segments_ctx);
@@ -405,13 +415,13 @@
 #else
         detail::activation_record * ptr = std::exchange( ptr_, nullptr)->resume();
 #endif
         if ( BOOST_UNLIKELY( detail::activation_record::current()->force_unwind) ) {
             throw detail::forced_unwind{ ptr};
         } else if ( BOOST_UNLIKELY( nullptr != detail::activation_record::current()->ontop) ) {
-            detail::activation_record::current()->ontop( ptr);
+            ptr = detail::activation_record::current()->ontop( ptr);
             detail::activation_record::current()->ontop = nullptr;
         }
         return continuation{ ptr };
     }
 
     template< typename Fn >
@@ -423,13 +433,13 @@
         detail::activation_record * ptr =
             std::exchange( ptr_, nullptr)->resume_with< continuation >( std::forward< Fn >( fn) );
 #endif
         if ( BOOST_UNLIKELY( detail::activation_record::current()->force_unwind) ) {
             throw detail::forced_unwind{ ptr};
         } else if ( BOOST_UNLIKELY( nullptr != detail::activation_record::current()->ontop) ) {
-            detail::activation_record::current()->ontop( ptr);
+            ptr = detail::activation_record::current()->ontop( ptr);
             detail::activation_record::current()->ontop = nullptr;
         }
         return continuation{ ptr };
     }
 
     explicit operator bool() const noexcept {
--- boost\context\continuation_winfib.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\context\continuation_winfib.hpp	2017-08-25 01:22:26.000000000 -0700
@@ -62,19 +62,19 @@
     record->run();
 }
 
 struct BOOST_CONTEXT_DECL activation_record {
     thread_local static activation_record   *   current_rec;
 
-    LPVOID                                      fiber{ nullptr };
-    stack_context                               sctx{};
-    bool                                        main_ctx{ true };
-    activation_record                       *   from{ nullptr };
-    std::function< void(activation_record*&) >  ontop{};
-    bool                                        terminated{ false };
-    bool                                        force_unwind{ false };
+    LPVOID                                                      fiber{ nullptr };
+    stack_context                                               sctx{};
+    bool                                                        main_ctx{ true };
+    activation_record                                       *   from{ nullptr };
+    std::function< activation_record*(activation_record*&) >    ontop{};
+    bool                                                        terminated{ false };
+    bool                                                        force_unwind{ false };
 
     static activation_record *& current() noexcept;
 
     // used for toplevel-context
     // (e.g. main context, thread-entry context)
     activation_record() noexcept {
@@ -139,26 +139,36 @@
         // returned by continuation::current()
         current() = this;
 #if defined(BOOST_NO_CXX14_GENERIC_LAMBDAS)
         current()->ontop = std::bind(
                 [](typename std::decay< Fn >::type & fn, activation_record *& ptr){
                     Ctx c{ ptr };
-                    fn( std::move( c) );
+                    c = fn( std::move( c) );
                     if ( ! c) {
                         ptr = nullptr;
                     }
+#if defined(BOOST_NO_CXX14_STD_EXCHANGE)
+                    return exchange( c.ptr_, nullptr);
+#else
+                    return std::exchange( c.ptr_, nullptr);
+#endif
                 },
                 std::forward< Fn >( fn),
                 std::placeholders::_1);
 #else
         current()->ontop = [fn=std::forward<Fn>(fn)](activation_record *& ptr){
             Ctx c{ ptr };
-            fn( std::move( c) );
+            c = fn( std::move( c) );
             if ( ! c) {
                 ptr = nullptr;
             }
+#if defined(BOOST_NO_CXX14_STD_EXCHANGE)
+            return exchange( c.ptr_, nullptr);
+#else
+            return std::exchange( c.ptr_, nullptr);
+#endif
         };
 #endif
         // context switch
         ::SwitchToFiber( fiber);
 #if defined(BOOST_NO_CXX14_STD_EXCHANGE)
         return detail::exchange( current()->from, nullptr);
@@ -333,13 +343,13 @@
 #else
         detail::activation_record * ptr = std::exchange( ptr_, nullptr)->resume();
 #endif
         if ( BOOST_UNLIKELY( detail::activation_record::current()->force_unwind) ) {
             throw detail::forced_unwind{ ptr};
         } else if ( BOOST_UNLIKELY( nullptr != detail::activation_record::current()->ontop) ) {
-            detail::activation_record::current()->ontop( ptr);
+            ptr = detail::activation_record::current()->ontop( ptr);
             detail::activation_record::current()->ontop = nullptr;
         }
         return continuation{ ptr };
     }
 
     template< typename Fn >
@@ -351,13 +361,13 @@
         detail::activation_record * ptr =
             std::exchange( ptr_, nullptr)->resume_with< continuation >( std::forward< Fn >( fn) );
 #endif
         if ( BOOST_UNLIKELY( detail::activation_record::current()->force_unwind) ) {
             throw detail::forced_unwind{ ptr};
         } else if ( BOOST_UNLIKELY( nullptr != detail::activation_record::current()->ontop) ) {
-            detail::activation_record::current()->ontop( ptr);
+            ptr = detail::activation_record::current()->ontop( ptr);
             detail::activation_record::current()->ontop = nullptr;
         }
         return continuation{ ptr };
     }
 
     explicit operator bool() const noexcept {
--- boost\coroutine\detail\push_coroutine_impl.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\coroutine\detail\push_coroutine_impl.hpp	2017-08-25 01:26:08.000000000 -0700
@@ -51,12 +51,14 @@
         caller_( caller),
         callee_( callee)
     {
         if ( unwind) flags_ |= flag_force_unwind;
     }
 
+    virtual ~push_coroutine_impl() {}
+
     bool force_unwind() const BOOST_NOEXCEPT
     { return 0 != ( flags_ & flag_force_unwind); }
 
     bool unwind_requested() const BOOST_NOEXCEPT
     { return 0 != ( flags_ & flag_unwind_stack); }
 
@@ -141,12 +143,14 @@
         caller_( caller),
         callee_( callee)
     {
         if ( unwind) flags_ |= flag_force_unwind;
     }
 
+    virtual ~push_coroutine_impl() {}
+
     bool force_unwind() const BOOST_NOEXCEPT
     { return 0 != ( flags_ & flag_force_unwind); }
 
     bool unwind_requested() const BOOST_NOEXCEPT
     { return 0 != ( flags_ & flag_unwind_stack); }
 
@@ -214,12 +218,14 @@
         caller_( caller),
         callee_( callee)
     {
         if ( unwind) flags_ |= flag_force_unwind;
     }
 
+    virtual ~push_coroutine_impl() {}
+
     inline bool force_unwind() const BOOST_NOEXCEPT
     { return 0 != ( flags_ & flag_force_unwind); }
 
     inline bool unwind_requested() const BOOST_NOEXCEPT
     { return 0 != ( flags_ & flag_unwind_stack); }
 
--- boost\coroutine2\detail\pull_control_block_cc.ipp	2017-08-19 09:49:40.000000000 -0700
+++ boost\coroutine2\detail\pull_control_block_cc.ipp	2017-08-25 01:28:52.000000000 -0700
@@ -100,12 +100,15 @@
                // set termination flags
                state |= state_t::complete;
                // jump back
                return other->c.resume();
             });
 #endif
+    if ( except) {
+        std::rethrow_exception( except);
+    }
 }
 
 template< typename T >
 pull_coroutine< T >::control_block::control_block( typename push_coroutine< T >::control_block * cb,
                                                    boost::context::continuation & c_) noexcept :
     c{ std::move( c_) },
@@ -247,12 +250,15 @@
                // set termination flags
                state |= state_t::complete;
                // jump back
                return other->c.resume();
             });
 #endif
+    if ( except) {
+        std::rethrow_exception( except);
+    }
 }
 
 template< typename T >
 pull_coroutine< T & >::control_block::control_block( typename push_coroutine< T & >::control_block * cb,
                                                      boost::context::continuation & c_) noexcept :
     c{ std::move( c_) },
@@ -368,12 +374,15 @@
                // set termination flags
                state |= state_t::complete;
                // jump back to ctx
                return other->c.resume();
             });
 #endif
+    if ( except) {
+        std::rethrow_exception( except);
+    }
 }
 
 inline
 pull_coroutine< void >::control_block::control_block( push_coroutine< void >::control_block * cb,
                                                       boost::context::continuation & c_) noexcept :
     c{ std::move( c_) },
--- boost\date_time\gregorian\greg_year.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\date_time\gregorian\greg_year.hpp	2017-08-28 19:11:27.000000000 -0700
@@ -27,16 +27,16 @@
   //! Policy class that declares error handling gregorian year type
   typedef CV::simple_exception_policy<unsigned short, 1400, 10000, bad_year> greg_year_policies;
 
   //! Generated representation for gregorian year
   typedef CV::constrained_value<greg_year_policies> greg_year_rep;
 
-  //! Represent a day of the month (range 1900 - 10000) 
+  //! Represent a year (range 1400 - 10000) 
   /*! This small class allows for simple conversion an integer value into
       a year for the gregorian calendar.  This currently only allows a
-      range of 1900 to 10000.  Both ends of the range are a bit arbitrary
+      range of 1400 to 10000.  Both ends of the range are a bit arbitrary
       at the moment, but they are the limits of current testing of the 
       library.  As such they may be increased in the future.
   */
   class BOOST_SYMBOL_VISIBLE greg_year : public greg_year_rep {
   public:
     greg_year(unsigned short year) : greg_year_rep(year) {}
--- boost\date_time\posix_time\conversion.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\date_time\posix_time\conversion.hpp	2017-08-28 19:15:39.000000000 -0700
@@ -77,13 +77,13 @@
    *
    * \note FILETIME is part of the Win32 API, so it is not portable to non-windows
    * platforms.
    *
    * \note The function is templated on the FILETIME type, so that
    *       it can be used with both native FILETIME and the ad-hoc
-   *       boost::date_time::winapi::file_time type.
+   *       boost::detail::winapi::FILETIME_ type.
    */
   template< typename TimeT, typename FileTimeT >
   inline
   TimeT from_ftime(const FileTimeT& ft)
   {
     return boost::date_time::time_from_ftime<TimeT>(ft);
--- boost\date_time\adjust_functors.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\date_time\adjust_functors.hpp	2017-08-28 19:11:26.000000000 -0700
@@ -1,69 +1,69 @@
 #ifndef _DATE_TIME_ADJUST_FUNCTORS_HPP___
 #define _DATE_TIME_ADJUST_FUNCTORS_HPP___
 
 /* Copyright (c) 2002,2003 CrystalClear Software, Inc.
- * Use, modification and distribution is subject to the 
+ * Use, modification and distribution is subject to the
  * Boost Software License, Version 1.0. (See accompanying
  * file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)
  * Author: Jeff Garland, Bart Garst
  * $Date$
  */
 
 #include "boost/date_time/date.hpp"
 #include "boost/date_time/wrapping_int.hpp"
 
 namespace boost {
 namespace date_time {
-  
+
 
   //! Functor to iterate a fixed number of days
   template<class date_type>
-  class day_functor 
+  class day_functor
   {
   public:
     typedef typename date_type::duration_type duration_type;
     day_functor(int f) : f_(f) {}
-    duration_type get_offset(const date_type& d) const 
+    duration_type get_offset(const date_type& d) const
     {
       // why is 'd' a parameter???
       // fix compiler warnings
       d.year();
       return duration_type(f_);
     }
-    duration_type get_neg_offset(const date_type& d) const 
+    duration_type get_neg_offset(const date_type& d) const
     {
       // fix compiler warnings
       d.year();
       return duration_type(-f_);
     }
   private:
     int f_;
   };
 
 
   //! Provides calculation to find next nth month given a date
   /*! This adjustment function provides the logic for 'month-based'
-   *  advancement on a ymd based calendar.  The policy it uses 
+   *  advancement on a ymd based calendar.  The policy it uses
    *  to handle the non existant end of month days is to back
    *  up to the last day of the month.  Also, if the starting
    *  date is the last day of a month, this functor will attempt
    *  to adjust to the end of the month.
 
    */
   template<class date_type>
-  class month_functor 
+  class month_functor
   {
   public:
     typedef typename date_type::duration_type duration_type;
     typedef typename date_type::calendar_type cal_type;
     typedef typename cal_type::ymd_type ymd_type;
     typedef typename cal_type::day_type day_type;
 
     month_functor(int f) : f_(f), origDayOfMonth_(0) {}
-    duration_type get_offset(const date_type& d) const 
+    duration_type get_offset(const date_type& d) const
     {
       ymd_type ymd(d.year_month_day());
       if (origDayOfMonth_ == 0) {
         origDayOfMonth_ = ymd.day;
         day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
         if (endOfMonthDay == ymd.day) {
@@ -71,13 +71,13 @@
         }
       }
       typedef date_time::wrapping_int2<short,1,12> wrap_int2;
       typedef typename wrap_int2::int_type int_type;
       wrap_int2 wi(ymd.month);
       //calc the year wrap around, add() returns 0 or 1 if wrapped
-      int_type year = wi.add(static_cast<int_type>(f_)); 
+      int_type year = wi.add(f_);
       year = static_cast<int_type>(year + ymd.year); //calculate resulting year
 //       std::cout << "trace wi: " << wi.as_int() << std::endl;
 //       std::cout << "trace year: " << year << std::endl;
       //find the last day for the new month
       day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));
       //original was the end of month -- force to last day of month
@@ -88,13 +88,13 @@
       if (dayOfMonth > resultingEndOfMonthDay) {
         dayOfMonth = resultingEndOfMonthDay;
       }
       return date_type(year, wi.as_int(), dayOfMonth) - d;
     }
     //! Returns a negative duration_type
-    duration_type get_neg_offset(const date_type& d) const 
+    duration_type get_neg_offset(const date_type& d) const
     {
       ymd_type ymd(d.year_month_day());
       if (origDayOfMonth_ == 0) {
         origDayOfMonth_ = ymd.day;
         day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
         if (endOfMonthDay == ymd.day) {
@@ -102,13 +102,13 @@
         }
       }
       typedef date_time::wrapping_int2<short,1,12> wrap_int2;
       typedef typename wrap_int2::int_type int_type;
       wrap_int2 wi(ymd.month);
       //calc the year wrap around, add() returns 0 or 1 if wrapped
-      int_type year = wi.subtract(static_cast<int_type>(f_)); 
+      int_type year = wi.subtract(f_);
       year = static_cast<int_type>(year + ymd.year); //calculate resulting year
       //find the last day for the new month
       day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));
       //original was the end of month -- force to last day of month
       if (origDayOfMonth_ == -1) {
         return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
@@ -124,55 +124,55 @@
     mutable short origDayOfMonth_;
   };
 
 
   //! Functor to iterate a over weeks
   template<class date_type>
-  class week_functor 
+  class week_functor
   {
   public:
     typedef typename date_type::duration_type duration_type;
     typedef typename date_type::calendar_type calendar_type;
     week_functor(int f) : f_(f) {}
-    duration_type get_offset(const date_type& d) const 
+    duration_type get_offset(const date_type& d) const
     {
       // why is 'd' a parameter???
       // fix compiler warnings
       d.year();
       return duration_type(f_*calendar_type::days_in_week());
     }
-    duration_type get_neg_offset(const date_type& d) const 
+    duration_type get_neg_offset(const date_type& d) const
     {
       // fix compiler warnings
       d.year();
       return duration_type(-f_*calendar_type::days_in_week());
     }
   private:
     int f_;
   };
 
   //! Functor to iterate by a year adjusting for leap years
   template<class date_type>
-  class year_functor 
+  class year_functor
   {
   public:
     //typedef typename date_type::year_type year_type;
     typedef typename date_type::duration_type duration_type;
     year_functor(int f) : _mf(f * 12) {}
-    duration_type get_offset(const date_type& d) const 
+    duration_type get_offset(const date_type& d) const
     {
       return _mf.get_offset(d);
     }
-    duration_type get_neg_offset(const date_type& d) const 
+    duration_type get_neg_offset(const date_type& d) const
     {
       return _mf.get_neg_offset(d);
     }
   private:
     month_functor<date_type> _mf;
   };
 
-  
+
 } }//namespace date_time
 
 
 #endif
 
--- boost\date_time\filetime_functions.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\date_time\filetime_functions.hpp	2017-08-28 19:15:39.000000000 -0700
@@ -16,139 +16,53 @@
  */
 
 #include <boost/date_time/compiler_config.hpp>
 
 #if defined(BOOST_HAS_FTIME) // skip this file if no FILETIME
 
-#if defined(BOOST_USE_WINDOWS_H)
-#  include <windows.h>
-#endif
-
 #include <boost/cstdint.hpp>
 #include <boost/date_time/time.hpp>
 #include <boost/date_time/date_defs.hpp>
 
 namespace boost {
 
 namespace date_time {
 
-namespace winapi {
-
-#if !defined(BOOST_USE_WINDOWS_H)
-
-    extern "C" {
-
-        struct FILETIME
-        {
-            boost::uint32_t dwLowDateTime;
-            boost::uint32_t dwHighDateTime;
-        };
-        struct SYSTEMTIME
-        {
-            boost::uint16_t wYear;
-            boost::uint16_t wMonth;
-            boost::uint16_t wDayOfWeek;
-            boost::uint16_t wDay;
-            boost::uint16_t wHour;
-            boost::uint16_t wMinute;
-            boost::uint16_t wSecond;
-            boost::uint16_t wMilliseconds;
-        };
-
-        __declspec(dllimport) void __stdcall GetSystemTimeAsFileTime(FILETIME* lpFileTime);
-        __declspec(dllimport) int __stdcall FileTimeToLocalFileTime(const FILETIME* lpFileTime, FILETIME* lpLocalFileTime);
-        __declspec(dllimport) void __stdcall GetSystemTime(SYSTEMTIME* lpSystemTime);
-        __declspec(dllimport) int __stdcall SystemTimeToFileTime(const SYSTEMTIME* lpSystemTime, FILETIME* lpFileTime);
-
-    } // extern "C"
-
-#endif // defined(BOOST_USE_WINDOWS_H)
-
-    typedef FILETIME file_time;
-    typedef SYSTEMTIME system_time;
-
-    inline void get_system_time_as_file_time(file_time& ft)
-    {
-#if BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3205))
-        // Some runtime library implementations expect local times as the norm for ctime.
-        file_time ft_utc;
-        GetSystemTimeAsFileTime(&ft_utc);
-        FileTimeToLocalFileTime(&ft_utc, &ft);
-#elif defined(BOOST_HAS_GETSYSTEMTIMEASFILETIME)
-        GetSystemTimeAsFileTime(&ft);
-#else
-        system_time st;
-        GetSystemTime(&st);
-        SystemTimeToFileTime(&st, &ft);
-#endif
-    }
-
-    /*!
-     * The function converts file_time into number of microseconds elapsed since 1970-Jan-01
-     *
-     * \note Only dates after 1970-Jan-01 are supported. Dates before will be wrapped.
-     *
-     * \note The function is templated on the FILETIME type, so that
-     *       it can be used with both native FILETIME and the ad-hoc
-     *       boost::date_time::winapi::file_time type.
-     */
-    template< typename FileTimeT >
-    inline boost::uint64_t file_time_to_microseconds(FileTimeT const& ft)
-    {
-        /* shift is difference between 1970-Jan-01 & 1601-Jan-01
-        * in 100-nanosecond intervals */
-        const uint64_t shift = 116444736000000000ULL; // (27111902 << 32) + 3577643008
-
-        union {
-            FileTimeT as_file_time;
-            uint64_t as_integer; // 100-nanos since 1601-Jan-01
-        } caster;
-        caster.as_file_time = ft;
-
-        caster.as_integer -= shift; // filetime is now 100-nanos since 1970-Jan-01
-        return (caster.as_integer / 10); // truncate to microseconds
-    }
-
-} // namespace winapi
-
 //! Create a time object from an initialized FILETIME struct.
 /*!
  * Create a time object from an initialized FILETIME struct.
  * A FILETIME struct holds 100-nanosecond units (0.0000001). When
  * built with microsecond resolution the file_time's sub second value
  * will be truncated. Nanosecond resolution has no truncation.
  *
  * \note The function is templated on the FILETIME type, so that
  *       it can be used with both native FILETIME and the ad-hoc
- *       boost::date_time::winapi::file_time type.
+ *       boost::detail::winapi::FILETIME_ type.
  */
 template< typename TimeT, typename FileTimeT >
 inline
 TimeT time_from_ftime(const FileTimeT& ft)
 {
     typedef typename TimeT::date_type date_type;
     typedef typename TimeT::date_duration_type date_duration_type;
     typedef typename TimeT::time_duration_type time_duration_type;
 
     // https://svn.boost.org/trac/boost/ticket/2523
     // Since this function can be called with arbitrary times, including ones that
     // are before 1970-Jan-01, we'll have to cast the time a bit differently,
-    // than it is done in the file_time_to_microseconds function. This allows to
+    // than it is done in the microsec_clock::file_time_to_microseconds function. This allows to
     // avoid integer wrapping for dates before 1970-Jan-01.
-    union {
-        FileTimeT as_file_time;
-        uint64_t as_integer; // 100-nanos since 1601-Jan-01
-    } caster;
-    caster.as_file_time = ft;
-
-    uint64_t sec = caster.as_integer / 10000000UL;
-    uint32_t sub_sec = (caster.as_integer % 10000000UL) // 100-nanoseconds since the last second
+
+    // 100-nanos since 1601-Jan-01
+    uint64_t ft_as_integer = (static_cast< uint64_t >(ft.dwHighDateTime) << 32) | static_cast< uint64_t >(ft.dwLowDateTime);
+    uint64_t sec = ft_as_integer / 10000000UL;
+    uint32_t sub_sec = static_cast< uint32_t >(ft_as_integer % 10000000UL) // 100-nanoseconds since the last second
 #if !defined(BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG)
-        / 10; // microseconds since the last second
+        / 10U; // microseconds since the last second
 #else
-        * 100; // nanoseconds since the last second
+        * 100U; // nanoseconds since the last second
 #endif
 
     // split sec into usable chunks: days, hours, minutes, & seconds
     const uint32_t sec_per_day = 86400; // seconds per day
     uint32_t days = static_cast< uint32_t >(sec / sec_per_day);
     uint32_t tmp = static_cast< uint32_t >(sec % sec_per_day);
--- boost\date_time\microsec_time_clock.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\date_time\microsec_time_clock.hpp	2017-08-28 19:15:39.000000000 -0700
@@ -17,13 +17,15 @@
 #include <boost/cstdint.hpp>
 #include <boost/shared_ptr.hpp>
 #include <boost/detail/workaround.hpp>
 #include <boost/date_time/compiler_config.hpp>
 #include <boost/date_time/c_time.hpp>
 #include <boost/date_time/time_clock.hpp>
-#include <boost/date_time/filetime_functions.hpp>
+#if defined(BOOST_HAS_FTIME)
+#include <boost/detail/winapi/time.hpp>
+#endif
 
 #ifdef BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK
 
 namespace boost {
 namespace date_time {
 
@@ -82,16 +84,25 @@
 #ifdef BOOST_HAS_GETTIMEOFDAY
       timeval tv;
       gettimeofday(&tv, 0); //gettimeofday does not support TZ adjust on Linux.
       std::time_t t = tv.tv_sec;
       boost::uint32_t sub_sec = tv.tv_usec;
 #elif defined(BOOST_HAS_FTIME)
-      winapi::file_time ft;
-      winapi::get_system_time_as_file_time(ft);
-      uint64_t micros = winapi::file_time_to_microseconds(ft); // it will not wrap, since ft is the current time
-                                                               // and cannot be before 1970-Jan-01
+      boost::detail::winapi::FILETIME_ ft;
+      boost::detail::winapi::GetSystemTimeAsFileTime(&ft);
+#if BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3205))
+      // Some runtime library implementations expect local times as the norm for ctime functions.
+      {
+        boost::detail::winapi::FILETIME_ local_ft;
+        boost::detail::winapi::FileTimeToLocalFileTime(&ft, &local_ft);
+        ft = local_ft;
+      }
+#endif
+
+      boost::uint64_t micros = file_time_to_microseconds(ft); // it will not wrap, since ft is the current time
+                                                              // and cannot be before 1970-Jan-01
       std::time_t t = static_cast<std::time_t>(micros / 1000000UL); // seconds since epoch
       // microseconds -- static casts suppress warnings
       boost::uint32_t sub_sec = static_cast<boost::uint32_t>(micros % 1000000UL);
 #else
 #error Internal Boost.DateTime error: BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK is defined, however neither gettimeofday nor FILETIME support is detected.
 #endif
@@ -112,16 +123,36 @@
                             static_cast< typename time_duration_type::min_type >(curr_ptr->tm_min),
                             static_cast< typename time_duration_type::sec_type >(curr_ptr->tm_sec),
                             sub_sec * adjust);
 
       return time_type(d,td);
     }
+
+#if defined(BOOST_HAS_FTIME)
+    /*!
+     * The function converts file_time into number of microseconds elapsed since 1970-Jan-01
+     *
+     * \note Only dates after 1970-Jan-01 are supported. Dates before will be wrapped.
+     */
+    static boost::uint64_t file_time_to_microseconds(boost::detail::winapi::FILETIME_ const& ft)
+    {
+      // shift is difference between 1970-Jan-01 & 1601-Jan-01
+      // in 100-nanosecond units
+      const boost::uint64_t shift = 116444736000000000ULL; // (27111902 << 32) + 3577643008
+
+      // 100-nanos since 1601-Jan-01
+      boost::uint64_t ft_as_integer = (static_cast< boost::uint64_t >(ft.dwHighDateTime) << 32) | static_cast< boost::uint64_t >(ft.dwLowDateTime);
+
+      ft_as_integer -= shift; // filetime is now 100-nanos since 1970-Jan-01
+      return (ft_as_integer / 10U); // truncate to microseconds
+    }
+#endif
   };
 
 
 } } //namespace date_time
 
 #endif //BOOST_DATE_TIME_HAS_HIGH_PRECISION_CLOCK
 
 
 #endif
 
--- boost\detail\winapi\basic_types.hpp	2017-08-19 09:49:50.000000000 -0700
+++ boost\detail\winapi\basic_types.hpp	2017-08-28 21:02:22.000000000 -0700
@@ -64,17 +64,13 @@
 struct _SECURITY_ATTRIBUTES;
 BOOST_DETAIL_WINAPI_DECLARE_HANDLE(HINSTANCE);
 typedef HINSTANCE HMODULE;
 }
 #endif
 
-#if defined(__GNUC__)
-#define BOOST_DETAIL_WINAPI_MAY_ALIAS __attribute__ ((__may_alias__))
-#else
-#define BOOST_DETAIL_WINAPI_MAY_ALIAS
-#endif
+#define BOOST_DETAIL_WINAPI_MAY_ALIAS BOOST_MAY_ALIAS
 
 // MinGW64 gcc 4.8.2 fails to compile function declarations with boost::detail::winapi::VOID_ arguments even though
 // the typedef expands to void. In Windows SDK, VOID is a macro which unfolds to void. We use our own macro in such cases.
 #define BOOST_DETAIL_WINAPI_VOID void
 
 namespace boost {
--- boost\detail\bitmask.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\detail\bitmask.hpp	2017-08-28 20:31:37.000000000 -0700
@@ -3,45 +3,56 @@
 //  Copyright Beman Dawes 2006
 
 //  Distributed under the Boost Software License, Version 1.0
 //  http://www.boost.org/LICENSE_1_0.txt
 
 //  Usage:  enum foo { a=1, b=2, c=4 };
-//          BOOST_BITMASK( foo );
+//          BOOST_BITMASK( foo )
 //
 //          void f( foo arg );
 //          ...
 //          f( a | c );
+//
+//  See [bitmask.types] in the C++ standard for the formal specification
 
 #ifndef BOOST_BITMASK_HPP
 #define BOOST_BITMASK_HPP
 
+#include <boost/config.hpp>
 #include <boost/cstdint.hpp>
 
 #define BOOST_BITMASK(Bitmask)                                            \
                                                                           \
-  inline Bitmask operator| (Bitmask x , Bitmask y )                       \
+  inline BOOST_CONSTEXPR Bitmask operator| (Bitmask x , Bitmask y )       \
   { return static_cast<Bitmask>( static_cast<boost::int_least32_t>(x)     \
       | static_cast<boost::int_least32_t>(y)); }                          \
                                                                           \
-  inline Bitmask operator& (Bitmask x , Bitmask y )                       \
+  inline BOOST_CONSTEXPR Bitmask operator& (Bitmask x , Bitmask y )       \
   { return static_cast<Bitmask>( static_cast<boost::int_least32_t>(x)     \
       & static_cast<boost::int_least32_t>(y)); }                          \
                                                                           \
-  inline Bitmask operator^ (Bitmask x , Bitmask y )                       \
+  inline BOOST_CONSTEXPR Bitmask operator^ (Bitmask x , Bitmask y )       \
   { return static_cast<Bitmask>( static_cast<boost::int_least32_t>(x)     \
       ^ static_cast<boost::int_least32_t>(y)); }                          \
                                                                           \
-  inline Bitmask operator~ (Bitmask x )                                   \
+  inline BOOST_CONSTEXPR Bitmask operator~ (Bitmask x )                   \
   { return static_cast<Bitmask>(~static_cast<boost::int_least32_t>(x)); } \
                                                                           \
-  inline Bitmask & operator&=(Bitmask & x , Bitmask y)                    \
+  inline Bitmask & operator&=(Bitmask& x , Bitmask y)                     \
   { x = x & y ; return x ; }                                              \
                                                                           \
-  inline Bitmask & operator|=(Bitmask & x , Bitmask y)                    \
+  inline Bitmask & operator|=(Bitmask& x , Bitmask y)                     \
   { x = x | y ; return x ; }                                              \
                                                                           \
-  inline Bitmask & operator^=(Bitmask & x , Bitmask y)                    \
-  { x = x ^ y ; return x ; }                                              
+  inline Bitmask & operator^=(Bitmask& x , Bitmask y)                     \
+  { x = x ^ y ; return x ; }                                              \
+                                                                          \
+  /* Boost extensions to [bitmask.types] */                               \
+                                                                          \
+  inline BOOST_CONSTEXPR bool operator!(Bitmask x)                        \
+  { return !static_cast<int>(x); }                                        \
+                                                                          \
+  inline BOOST_CONSTEXPR bool bitmask_set(Bitmask x)                      \
+  { return !!x; }
 
 #endif // BOOST_BITMASK_HPP
 
--- boost\detail\compressed_pair.hpp	2017-08-19 09:49:50.000000000 -0700
+++ boost\detail\compressed_pair.hpp	2017-08-21 15:39:43.000000000 -0700
@@ -32,13 +32,13 @@
 # pragma warning(disable:4512)
 #endif 
 namespace boost
 {
 
 template <class T1, class T2>
-class compressed_pair;
+class BOOST_EMPTYBASES compressed_pair;
 
 
 // compressed_pair
 
 namespace details
 {
@@ -67,13 +67,13 @@
       {static const int value = 4;};
 
    template <class T1, class T2>
    struct compressed_pair_switch<T1, T2, true, false, false>
       {static const int value = 5;};
 
-   template <class T1, class T2, int Version> class compressed_pair_imp;
+   template <class T1, class T2, int Version> class BOOST_EMPTYBASES compressed_pair_imp;
 
 #ifdef __GNUC__
    // workaround for GCC (JM):
    using std::swap;
 #endif
    //
@@ -90,13 +90,13 @@
       swap(t1, t2);
    }
 
    // 0    derive from neither
 
    template <class T1, class T2>
-   class compressed_pair_imp<T1, T2, 0>
+   class BOOST_EMPTYBASES compressed_pair_imp<T1, T2, 0>
    {
    public:
       typedef T1                                                 first_type;
       typedef T2                                                 second_type;
       typedef typename call_traits<first_type>::param_type       first_param_type;
       typedef typename call_traits<second_type>::param_type      second_param_type;
@@ -132,13 +132,13 @@
       second_type second_;
    };
 
    // 1    derive from T1
 
    template <class T1, class T2>
-   class compressed_pair_imp<T1, T2, 1>
+   class BOOST_EMPTYBASES compressed_pair_imp<T1, T2, 1>
       : protected ::boost::remove_cv<T1>::type
    {
    public:
       typedef T1                                                 first_type;
       typedef T2                                                 second_type;
       typedef typename call_traits<first_type>::param_type       first_param_type;
@@ -174,13 +174,13 @@
       second_type second_;
    };
 
    // 2    derive from T2
 
    template <class T1, class T2>
-   class compressed_pair_imp<T1, T2, 2>
+   class BOOST_EMPTYBASES compressed_pair_imp<T1, T2, 2>
       : protected ::boost::remove_cv<T2>::type
    {
    public:
       typedef T1                                                 first_type;
       typedef T2                                                 second_type;
       typedef typename call_traits<first_type>::param_type       first_param_type;
@@ -217,13 +217,13 @@
       first_type first_;
    };
 
    // 3    derive from T1 and T2
 
    template <class T1, class T2>
-   class compressed_pair_imp<T1, T2, 3>
+   class BOOST_EMPTYBASES compressed_pair_imp<T1, T2, 3>
       : protected ::boost::remove_cv<T1>::type,
         protected ::boost::remove_cv<T2>::type
    {
    public:
       typedef T1                                                 first_type;
       typedef T2                                                 second_type;
@@ -260,13 +260,13 @@
    //      Originally this did not store an instance of T2 at all
    //      but that led to problems beause it meant &x.first() == &x.second()
    //      which is not true for any other kind of pair, so now we store an instance
    //      of T2 just in case the user is relying on first() and second() returning
    //      different objects (albeit both empty).
    template <class T1, class T2>
-   class compressed_pair_imp<T1, T2, 4>
+   class BOOST_EMPTYBASES compressed_pair_imp<T1, T2, 4>
       : protected ::boost::remove_cv<T1>::type
    {
    public:
       typedef T1                                                 first_type;
       typedef T2                                                 second_type;
       typedef typename call_traits<first_type>::param_type       first_param_type;
@@ -295,13 +295,13 @@
       T2 m_second;
    };
 
    // 5    T1 == T2 and are not empty:   //JM
 
    template <class T1, class T2>
-   class compressed_pair_imp<T1, T2, 5>
+   class BOOST_EMPTYBASES compressed_pair_imp<T1, T2, 5>
    {
    public:
       typedef T1                                                 first_type;
       typedef T2                                                 second_type;
       typedef typename call_traits<first_type>::param_type       first_param_type;
       typedef typename call_traits<second_type>::param_type      second_param_type;
@@ -334,13 +334,13 @@
       second_type second_;
    };
 
 }  // details
 
 template <class T1, class T2>
-class compressed_pair
+class BOOST_EMPTYBASES compressed_pair
    : private ::boost::details::compressed_pair_imp<T1, T2,
              ::boost::details::compressed_pair_switch<
                     T1,
                     T2,
                     ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value,
                     ::boost::is_empty<T1>::value,
@@ -379,13 +379,13 @@
 };
 
 // JM
 // Partial specialisation for case where T1 == T2:
 //
 template <class T>
-class compressed_pair<T, T>
+class BOOST_EMPTYBASES compressed_pair<T, T>
    : private details::compressed_pair_imp<T, T,
              ::boost::details::compressed_pair_switch<
                     T,
                     T,
                     ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value,
                     ::boost::is_empty<T>::value,
--- boost\detail\ob_compressed_pair.hpp	2017-08-19 09:49:50.000000000 -0700
+++ boost\detail\ob_compressed_pair.hpp	2017-08-21 15:40:07.000000000 -0700
@@ -45,13 +45,13 @@
 // each of the compressed_pair versions that follow
 // have one template single-argument constructor
 // in place of two specific constructors:
 //
 
 template <class T1, class T2>
-class compressed_pair;
+class BOOST_EMPTYBASES compressed_pair;
 
 namespace detail{
 
 template <class A, class T1, class T2>
 struct best_conversion_traits
 {
@@ -138,13 +138,13 @@
       swap(_second, y._second);
    }
 };
 
 // T1 != T2, T2 empty
 template <class T1, class T2>
-class compressed_pair_1 : T2
+class BOOST_EMPTYBASES compressed_pair_1 : T2
 {
 private:
    T1 _first;
 public:
    typedef T1                                                 first_type;
    typedef T2                                                 second_type;
@@ -180,13 +180,13 @@
       swap(_first, y._first);
    }
 };
 
 // T1 != T2, T1 empty
 template <class T1, class T2>
-class compressed_pair_2 : T1
+class BOOST_EMPTYBASES compressed_pair_2 : T1
 {
 private:
    T2 _second;
 public:
    typedef T1                                                 first_type;
    typedef T2                                                 second_type;
@@ -229,13 +229,13 @@
       swap(_second, y._second);
    }
 };
 
 // T1 != T2, both empty
 template <class T1, class T2>
-class compressed_pair_3 : T1, T2
+class BOOST_EMPTYBASES compressed_pair_3 : T1, T2
 {
 public:
    typedef T1                                                 first_type;
    typedef T2                                                 second_type;
    typedef typename call_traits<first_type>::param_type       first_param_type;
    typedef typename call_traits<second_type>::param_type      second_param_type;
@@ -265,13 +265,13 @@
       // no need to swap empty base classes:
    }
 };
 
 // T1 == T2, and empty
 template <class T1, class T2>
-class compressed_pair_4 : T1
+class BOOST_EMPTYBASES compressed_pair_4 : T1
 {
 public:
    typedef T1                                                 first_type;
    typedef T2                                                 second_type;
    typedef typename call_traits<first_type>::param_type       first_param_type;
    typedef typename call_traits<second_type>::param_type      second_param_type;
@@ -409,13 +409,13 @@
    typedef typename bound_type::type type;
 };
 
 } // namespace detail
 
 template <class T1, class T2>
-class compressed_pair : public detail::compressed_pair_traits<T1, T2>::type
+class BOOST_EMPTYBASES compressed_pair : public detail::compressed_pair_traits<T1, T2>::type
 {
 private:
    typedef typename detail::compressed_pair_traits<T1, T2>::type base_type;
 public:
    typedef T1                                                 first_type;
    typedef T2                                                 second_type;
--- boost\fiber\context.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\fiber\context.hpp	2017-08-27 02:44:29.000000000 -0700
@@ -420,15 +420,15 @@
         {
             // fn and tpl must be destroyed before calling terminate()
             auto fn = std::move( fn_);
             auto arg = std::move( arg_);
             c.resume();
 #if defined(BOOST_NO_CXX17_STD_APPLY)
-           boost::context::detail::apply( std::move( fn_), std::move( arg_) );
+           boost::context::detail::apply( std::move( fn), std::move( arg) );
 #else
-           std::apply( std::move( fn_), std::move( arg_) );
+           std::apply( std::move( fn), std::move( arg) );
 #endif
         }
         // terminate context
         return terminate();
     }
 
--- boost\filesystem\operations.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\filesystem\operations.hpp	2017-08-21 15:40:51.000000000 -0700
@@ -886,13 +886,13 @@
 //                                directory_iterator                                    //
 //                                                                                      //
 //--------------------------------------------------------------------------------------//
 
   class directory_iterator
     : public boost::iterator_facade< directory_iterator,
-                                     directory_entry,
+                                     const directory_entry,
                                      boost::single_pass_traversal_tag >
   {
   public:
 
     directory_iterator() BOOST_NOEXCEPT {}  // creates the "end" iterator
 
@@ -926,13 +926,13 @@
     boost::shared_ptr< detail::dir_itr_imp >  m_imp;
 
     friend class boost::iterator_core_access;
 
     boost::iterator_facade<
       directory_iterator,
-      directory_entry,
+      const directory_entry,
       boost::single_pass_traversal_tag >::reference dereference() const 
     {
       BOOST_ASSERT_MSG(m_imp.get(), "attempt to dereference end iterator");
       return m_imp->dir_entry;
     }
 
@@ -1141,13 +1141,13 @@
 //                                                                                      //
 //--------------------------------------------------------------------------------------//
 
   class recursive_directory_iterator
     : public boost::iterator_facade<
         recursive_directory_iterator,
-        directory_entry,
+        const directory_entry,
         boost::single_pass_traversal_tag >
   {
   public:
 
     recursive_directory_iterator() BOOST_NOEXCEPT {}  // creates the "end" iterator
 
@@ -1266,13 +1266,13 @@
     boost::shared_ptr< detail::recur_dir_itr_imp >  m_imp;
 
     friend class boost::iterator_core_access;
 
     boost::iterator_facade< 
       recursive_directory_iterator,
-      directory_entry,
+      const directory_entry,
       boost::single_pass_traversal_tag >::reference
     dereference() const 
     {
       BOOST_ASSERT_MSG(m_imp.get(),
         "dereference of end recursive_directory_iterator");
       return *m_imp->m_stack.top();
--- boost\format\detail\config_macros.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\format\detail\config_macros.hpp	2017-08-21 15:41:24.000000000 -0700
@@ -42,13 +42,13 @@
    || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT( 0x570 ) )  )
 // some future __BORLANDC__ >0x564  versions might not need this
 // 0x570 is Borland's kylix branch
 #define BOOST_NO_LOCALE_ISDIGIT
 #endif
 
-#if  BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x570) ) || BOOST_WORKAROUND( BOOST_MSVC, BOOST_TESTED_AT(1300))
+#if  BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x570) ) || BOOST_WORKAROUND( BOOST_MSVC, < 1900 )
 #define BOOST_NO_OVERLOAD_FOR_NON_CONST
 #endif
 
 // **** Workaround for io streams, stlport and msvc.
 #ifdef BOOST_IO_NEEDS_USING_DECLARATION
 namespace boost {
--- boost\functional\hash\hash.hpp	2017-08-19 09:49:41.000000000 -0700
+++ boost\functional\hash\hash.hpp	2017-08-21 15:41:47.000000000 -0700
@@ -14,13 +14,12 @@
 // domain. The author hereby disclaims copyright to this source code.
 
 #if !defined(BOOST_FUNCTIONAL_HASH_HASH_HPP)
 #define BOOST_FUNCTIONAL_HASH_HASH_HPP
 
 #include <boost/functional/hash/hash_fwd.hpp>
-#include <functional>
 #include <boost/functional/hash/detail/hash_float.hpp>
 #include <string>
 #include <boost/limits.hpp>
 #include <boost/type_traits/is_enum.hpp>
 #include <boost/type_traits/is_integral.hpp>
 #include <boost/utility/enable_if.hpp>
@@ -59,23 +58,18 @@
 #endif
 
 namespace boost
 {
     namespace hash_detail
     {
-#if defined(_HAS_AUTO_PTR_ETC) && !_HAS_AUTO_PTR_ETC
         template <typename T>
         struct hash_base
         {
             typedef T argument_type;
             typedef std::size_t result_type;
         };
-#else
-        template <typename T>
-        struct hash_base : std::unary_function<T, std::size_t> {};
-#endif
 
         struct enable_hash_value { typedef std::size_t type; };
 
         template <typename T> struct basic_numbers {};
         template <typename T> struct long_numbers;
         template <typename T> struct ulong_numbers;
@@ -437,23 +431,23 @@
     // BOOST_HASH_SPECIALIZE_REF - define a specialization for a type which is
     // passed by const reference.
     //
     // These are undefined later.
 
 #define BOOST_HASH_SPECIALIZE(type) \
-    template <> struct hash<type> \
+    template <> struct BOOST_EMPTYBASES hash<type> \
          : public boost::hash_detail::hash_base<type> \
     { \
         std::size_t operator()(type v) const \
         { \
             return boost::hash_value(v); \
         } \
     };
 
 #define BOOST_HASH_SPECIALIZE_REF(type) \
-    template <> struct hash<type> \
+    template <> struct BOOST_EMPTYBASES hash<type> \
          : public boost::hash_detail::hash_base<type> \
     { \
         std::size_t operator()(type const& v) const \
         { \
             return boost::hash_value(v); \
         } \
@@ -513,13 +507,13 @@
 
 // Specializing boost::hash for pointers.
 
 #if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
 
     template <class T>
-    struct hash<T*>
+    struct BOOST_EMPTYBASES hash<T*>
         : public boost::hash_detail::hash_base<T*>
     {
         std::size_t operator()(T* v) const
         {
 #if !BOOST_WORKAROUND(__SUNPRO_CC, <= 0x590)
             return boost::hash_value(v);
@@ -546,13 +540,13 @@
         struct hash_impl;
 
         template <>
         struct hash_impl<true>
         {
             template <class T>
-            struct inner
+            struct BOOST_EMPTYBASES inner
                 : public boost::hash_detail::hash_base<T>
             {
                 std::size_t operator()(T val) const
                 {
 #if !BOOST_WORKAROUND(__SUNPRO_CC, <= 590)
                     return boost::hash_value(val);
@@ -564,13 +558,13 @@
 #endif
                 }
             };
         };
     }
 
-    template <class T> struct hash
+    template <class T> struct BOOST_EMPTYBASES hash
         : public boost::hash_detail::hash_impl<boost::is_pointer<T>::value>
             ::BOOST_NESTED_TEMPLATE inner<T>
     {
     };
 
 #endif
--- boost\hana\config.hpp	2017-08-19 09:49:42.000000000 -0700
+++ boost\hana\config.hpp	2017-08-22 19:22:39.000000000 -0700
@@ -127,13 +127,15 @@
 // BOOST_HANA_CONFIG_HAS_CONSTEXPR_LAMBDA enables some constructs requiring
 // `constexpr` lambdas, which are not in the language (yet).
 // Currently always disabled.
 //
 // BOOST_HANA_CONSTEXPR_LAMBDA expands to `constexpr` if constexpr lambdas
 // are supported and to nothing otherwise.
-#if 0
+#if (defined(__cpp_constexpr) && (__cpp_constexpr >= 201603)) ||            \
+        (defined(_MSC_VER) && (_MSC_VER >= 1911) &&                         \
+            defined(_MSVC_LANG) && (_MSVC_LANG > 201402))
 #   define BOOST_HANA_CONFIG_HAS_CONSTEXPR_LAMBDA
 #   define BOOST_HANA_CONSTEXPR_LAMBDA constexpr
 #else
 #   define BOOST_HANA_CONSTEXPR_LAMBDA /* nothing */
 #endif
 
--- boost\multiprecision\cpp_int\add.hpp	2017-08-19 09:49:44.000000000 -0700
+++ boost\multiprecision\cpp_int\add.hpp	2017-08-21 15:43:40.000000000 -0700
@@ -61,13 +61,13 @@
    // Now where only a has digits:
    while(pr != pr_end)
    {
       if(!carry)
       {
          if(pa != pr)
-#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600)
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600) && !defined(NDEBUG)
             std::copy(pa, pa + (pr_end - pr), stdext::checked_array_iterator<limb_type*>(pr, result.size()));
 #else
             std::copy(pa, pa + (pr_end - pr), pr);
 #endif
          break;
       }
@@ -198,13 +198,13 @@
       pr[i] = static_cast<limb_type>(borrow);
       borrow = (borrow >> CppInt1::limb_bits) & 1u;
       ++i;
    }
    // Any remaining digits are the same as those in pa:
    if((x != i) && (pa != pr))
-#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600)
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600) && !defined(NDEBUG)
       std::copy(pa + i, pa + x, stdext::checked_array_iterator<limb_type*>(pr + i, result.size() - i));
 #else
       std::copy(pa + i, pa + x, pr + i);
 #endif
    BOOST_ASSERT(0 == borrow);
 
@@ -230,13 +230,13 @@
    typename CppInt2::const_limb_pointer pa = a.limbs();
    if(*pa >= b)
    {
       *pr = *pa - b;
       if(&result != &a)
       {
-#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600)
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600) && !defined(NDEBUG)
          std::copy(pa + 1, pa + a.size(), stdext::checked_array_iterator<limb_type*>(pr + 1, result.size() - 1));
 #else
          std::copy(pa + 1, pa + a.size(), pr + 1);
 #endif
          result.sign(a.sign());
       }
@@ -260,13 +260,13 @@
          ++i;
       }
       pr[i] = pa[i] - 1;
       if(&result != &a)
       {
          ++i;
-#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600)
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600) && !defined(NDEBUG)
          std::copy(pa + i, pa + a.size(), stdext::checked_array_iterator<limb_type*>(pr + i, result.size() - i));
 #else
          std::copy(pa + i, pa + a.size(), pr + i);
 #endif
       }
       result.normalize();
--- boost\multiprecision\cpp_int\comparison.hpp	2017-08-19 09:49:44.000000000 -0700
+++ boost\multiprecision\cpp_int\comparison.hpp	2017-08-21 15:43:52.000000000 -0700
@@ -24,13 +24,13 @@
 BOOST_MP_FORCEINLINE typename enable_if_c<
       !is_trivial_cpp_int<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator> >::value, 
       bool
    >::type 
    eval_eq(const cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& a, const cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>& b) BOOST_NOEXCEPT
 {
-#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600)
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600) && !defined(NDEBUG)
    return (a.sign() == b.sign())
       && (a.size() == b.size())
       && std::equal(a.limbs(), a.limbs() + a.size(), 
          stdext::checked_array_iterator<cpp_int_backend<MinBits, MaxBits, SignType, Checked, Allocator>::const_limb_pointer>(b.limbs(), b.size()));
 #else
    return (a.sign() == b.sign())
@@ -43,13 +43,13 @@
       !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value 
       && !is_trivial_cpp_int<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2> >::value,
       bool
    >::type 
    eval_eq(const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& a, const cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>& b) BOOST_NOEXCEPT
 {
-#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600)
+#if BOOST_WORKAROUND(BOOST_MSVC, >= 1600) && !defined(NDEBUG)
    return (a.sign() == b.sign())
       && (a.size() == b.size())
       && std::equal(a.limbs(), a.limbs() + a.size(), stdext::checked_array_iterator<cpp_int_backend<MinBits2, MaxBits2, SignType2, Checked2, Allocator2>::const_limb_pointer>(b.limbs(), b.size()));
 #else
    return (a.sign() == b.sign())
       && (a.size() == b.size())
--- boost\numeric\conversion\detail\converter.hpp	2017-08-19 09:49:44.000000000 -0700
+++ boost\numeric\conversion\detail\converter.hpp	2017-08-26 22:06:39.000000000 -0700
@@ -7,17 +7,17 @@
 //
 // Contact the author at: fernando_cacciola@hotmail.com
 //
 #ifndef BOOST_NUMERIC_CONVERSION_DETAIL_CONVERTER_FLC_12NOV2002_HPP
 #define BOOST_NUMERIC_CONVERSION_DETAIL_CONVERTER_FLC_12NOV2002_HPP
 
-#include <functional>
-
 #include "boost/numeric/conversion/detail/meta.hpp"
 #include "boost/numeric/conversion/detail/conversion_traits.hpp"
 #include "boost/numeric/conversion/bounds.hpp"
+
+#include "boost/limits.hpp"
 
 #include "boost/type_traits/is_same.hpp"
 
 #include "boost/mpl/integral_c.hpp"
 
 namespace boost { namespace numeric { namespace convdetail
@@ -447,19 +447,16 @@
 //--------------------------------------------------------------------------
 
   //
   // Trivial Converter : used when (cv-unqualified) T == (cv-unqualified)  S
   //
   template<class Traits>
-  struct trivial_converter_impl : public std::unary_function<  BOOST_DEDUCED_TYPENAME Traits::argument_type
-                                                              ,BOOST_DEDUCED_TYPENAME Traits::result_type
-                                                            >
-                                 ,public dummy_range_checker<Traits>
+  struct trivial_converter_impl : public dummy_range_checker<Traits>
   {
     typedef Traits traits ;
-
+    
     typedef typename Traits::source_type   source_type   ;
     typedef typename Traits::argument_type argument_type ;
     typedef typename Traits::result_type   result_type   ;
 
     static result_type low_level_convert ( argument_type s ) { return s ; }
     static source_type nearbyint         ( argument_type s ) { return s ; }
@@ -468,16 +465,13 @@
 
 
   //
   // Rounding Converter : used for float to integral conversions.
   //
   template<class Traits,class RangeChecker,class RawConverter,class Float2IntRounder>
-  struct rounding_converter : public std::unary_function<  BOOST_DEDUCED_TYPENAME Traits::argument_type
-                                                          ,BOOST_DEDUCED_TYPENAME Traits::result_type
-                                                        >
-                             ,public RangeChecker
+  struct rounding_converter : public RangeChecker
                              ,public Float2IntRounder
                              ,public RawConverter
   {
     typedef RangeChecker     RangeCheckerBase ;
     typedef Float2IntRounder Float2IntRounderBase ;
     typedef RawConverter     RawConverterBase ;
@@ -498,16 +492,13 @@
 
 
   //
   // Non-Rounding Converter : used for all other conversions.
   //
   template<class Traits,class RangeChecker,class RawConverter>
-  struct non_rounding_converter : public std::unary_function< BOOST_DEDUCED_TYPENAME Traits::argument_type
-                                                             ,BOOST_DEDUCED_TYPENAME Traits::result_type
-                                                           >
-                                 ,public RangeChecker
+  struct non_rounding_converter : public RangeChecker
                                  ,public RawConverter
   {
     typedef RangeChecker RangeCheckerBase ;
     typedef RawConverter RawConverterBase ;
 
     typedef Traits traits ;
--- boost\poly_collection\detail\is_constructible.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\poly_collection\detail\is_constructible.hpp	2017-08-21 15:44:47.000000000 -0700
@@ -13,14 +13,16 @@
 #pragma once
 #endif
 
 #include <boost/config.hpp>
 #include <boost/detail/workaround.hpp>
 
-#if BOOST_WORKAROUND(BOOST_MSVC,BOOST_TESTED_AT(1900))
-/* https://connect.microsoft.com/VisualStudio/Feedback/Details/2118677 */
+#if defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC_FULL_VER, < 190023918 )
+/* https://connect.microsoft.com/VisualStudio/Feedback/Details/2118677
+    - fixed in VS2015U2 according to
+   https://blogs.msdn.microsoft.com/vcblog/2016/03/31/visual-c-2015-update-2-bug-fixes/ */
 
 #include <boost/type_traits/is_constructible.hpp>
 
 namespace boost{
 
 namespace poly_collection{
--- boost\pool\object_pool.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\pool\object_pool.hpp	2017-08-21 15:45:08.000000000 -0700
@@ -18,13 +18,13 @@
 #include <boost/pool/poolfwd.hpp>
 
 // boost::pool
 #include <boost/pool/pool.hpp>
 
 // The following code will be put into Boost.Config in a later revision
-#if defined(BOOST_MSVC) || defined(__KCC)
+#if (defined(BOOST_MSVC) && BOOST_MSVC < 1900) || defined(__KCC)
 # define BOOST_NO_TEMPLATE_CV_REF_OVERLOADS
 #endif
 
 // The following code might be put into some Boost.Config header in a later revision
 #ifdef __BORLANDC__
 # pragma option push -w-inl
--- boost\process\detail\posix\basic_pipe.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\basic_pipe.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -26,13 +26,13 @@
 class basic_pipe
 {
     int _source = -1;
     int _sink   = -1;
 public:
     explicit basic_pipe(int source, int sink) : _source(source), _sink(sink) {}
-    explicit basic_pipe(int source, int sink, const std::string & name) : _source(source), _sink(sink) {}
+    explicit basic_pipe(int source, int sink, const std::string&) : _source(source), _sink(sink) {}
     typedef CharT                      char_type  ;
     typedef          Traits            traits_type;
     typedef typename Traits::int_type  int_type   ;
     typedef typename Traits::pos_type  pos_type   ;
     typedef typename Traits::off_type  off_type   ;
     typedef          int               native_handle_type;
--- boost\process\detail\posix\child_handle.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\child_handle.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -41,13 +41,13 @@
 
     int id() const
     {
         return pid;
     }
     bool in_group() const {return true;}
-    bool in_group(std::error_code &ec) const noexcept {return true;}
+    bool in_group(std::error_code&) const noexcept {return true;}
 
     typedef int process_handle_t;
     process_handle_t process_handle() const { return pid; }
 
     bool valid() const
     {
--- boost\process\detail\posix\executor.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\executor.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -177,13 +177,13 @@
 
 
 template<typename Sequence>
 class executor
 {
     template<typename HasHandler, typename UseVFork>
-    void internal_error_handle(const std::error_code &ec, const char* msg, HasHandler, boost::mpl::true_, UseVFork) {}
+    void internal_error_handle(const std::error_code&, const char*, HasHandler, boost::mpl::true_, UseVFork) {}
 
     int _pipe_sink = -1;
 
     void write_error(const std::error_code & ec, const char * msg)
     {
         //I am the child
--- boost\process\detail\posix\group_ref.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\group_ref.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -25,13 +25,13 @@
 
     explicit group_ref(group_handle & g) :
                 grp(g)
     {}
 
     template <class Executor>
-    void on_exec_setup(Executor& exec) const
+    void on_exec_setup(Executor&) const
     {
         if (grp.grp == -1)
             ::setpgid(0, 0);
         else
             ::setpgid(0, grp.grp);
     }
--- boost\process\detail\posix\io_service_ref.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\io_service_ref.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -6,20 +6,21 @@
 #ifndef BOOST_PROCESS_POSIX_IO_SERVICE_REF_HPP_
 #define BOOST_PROCESS_POSIX_IO_SERVICE_REF_HPP_
 
 #include <boost/process/detail/posix/handler.hpp>
 #include <boost/process/detail/posix/async_handler.hpp>
 #include <boost/asio/io_service.hpp>
-#include <boost/asio/signal_set.hpp>
 
 #include <boost/fusion/algorithm/iteration/for_each.hpp>
 #include <boost/fusion/algorithm/transformation/filter_if.hpp>
 #include <boost/fusion/algorithm/transformation/transform.hpp>
 #include <boost/fusion/view/transform_view.hpp>
 #include <boost/fusion/container/vector/convert.hpp>
 
+
+#include <boost/process/detail/posix/sigchld_service.hpp>
 
 #include <functional>
 #include <type_traits>
 #include <memory>
 #include <vector>
 #include <sys/wait.h>
@@ -70,17 +71,15 @@
 {
     io_service_ref(boost::asio::io_service & ios) : ios(ios)
     {
 
     }
     boost::asio::io_service &get() {return ios;};
-
-    boost::asio::signal_set *signal_p = nullptr;
-
+    
     template <class Executor>
-    void on_setup(Executor& exec)
+    void on_success(Executor& exec)
     {
         //must be on the heap so I can move it into the lambda.
         auto asyncs = boost::fusion::filter_if<
                         is_async_handler<
                         typename std::remove_reference< boost::mpl::_ > ::type
                         >>(exec.seq);
@@ -90,66 +89,26 @@
             return;
 
         std::vector<std::function<void(int, const std::error_code & ec)>> funcs;
         funcs.reserve(boost::fusion::size(asyncs));
         boost::fusion::for_each(asyncs, async_handler_collector<Executor>(exec, funcs));
 
-        wait_handler wh(std::move(funcs), ios, exec.exit_status);
-
-        signal_p = wh.signal_.get();
-        signal_p->async_wait(std::move(wh));
-
-    }
-
-    template <class Executor>
-    void on_error(Executor & exec, const std::error_code & ec) const
-    {
-        if (signal_p != nullptr)
-        {
-            boost::system::error_code ec;
-            signal_p->cancel(ec);
-        }
-    }
-
-    struct wait_handler
-    {
-        std::shared_ptr<boost::asio::signal_set> signal_;
-        std::vector<std::function<void(int, const std::error_code & ec)>> funcs;
-        std::shared_ptr<std::atomic<int>> exit_status;
-
-        wait_handler(const wait_handler & ) = default;
-        wait_handler(wait_handler && )      = default;
-        wait_handler(
-                std::vector<std::function<void(int, const std::error_code & ec)>> && funcs,
-                boost::asio::io_service & ios,
-                const std::shared_ptr<std::atomic<int>> &exit_status)
-            : signal_(new boost::asio::signal_set(ios, SIGCHLD)),
-              funcs(std::move(funcs)),
-              exit_status(exit_status)
-        {
+        auto & es = exec.exit_status;
 
-        }
-        void operator()(const boost::system::error_code & ec_in, int /*signal*/)
-        {
-            if (ec_in.value() == boost::asio::error::operation_aborted)
-                return;
-
-
-            int status;
-            ::wait(&status);
-
-            std::error_code ec(ec_in.value(), std::system_category());
-            int val = WEXITSTATUS(status);
-            exit_status->store(status);
-
-            for (auto & func : funcs)
-                func(val, ec);
-        }
+        auto wh = [funcs, es](int val, const std::error_code & ec)
+				{
+        			es->store(val);
+                    for (auto & func : funcs)
+                        func(WEXITSTATUS(val), ec);
+				};
+
+        sigchld_service.async_wait(exec.pid, std::move(wh));
+    }
 
-    };
 private:
     boost::asio::io_service &ios;
+    boost::process::detail::posix::sigchld_service &sigchld_service = boost::asio::use_service<boost::process::detail::posix::sigchld_service>(ios);
 };
 
 }}}}
 
 #endif /* BOOST_PROCESS_WINDOWS_IO_SERVICE_REF_HPP_ */
--- boost\process\detail\posix\on_exit.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\on_exit.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -20,16 +20,16 @@
     on_exit_(const std::function<void(int, const std::error_code&)> & handler) : handler(handler)
     {
 
     }
 
     template<typename Executor>
-    std::function<void(int, const std::error_code&)> on_exit_handler(Executor & exec)
+    std::function<void(int, const std::error_code&)> on_exit_handler(Executor&) 
     {
         return handler;
 
     };
 };
 
 
 }}}}
 #endif /* BOOST_PROCESS_POSIX_ON_EXIT_HPP_ */
--- 
+++ boost\process\detail\posix\sigchld_service.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -0,0 +1,113 @@
+// Copyright (c) 2017 Klemens D. Morgenstern
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+
+#ifndef BOOST_PROCESS_DETAIL_POSIX_SIGCHLD_SERVICE_HPP_
+#define BOOST_PROCESS_DETAIL_POSIX_SIGCHLD_SERVICE_HPP_
+
+#include <boost/asio/signal_set.hpp>
+#include <boost/asio/strand.hpp>
+#include <boost/optional.hpp>
+#include <signal.h>
+#include <functional>
+#include <sys/wait.h>
+
+namespace boost { namespace process { namespace detail { namespace posix {
+
+class sigchld_service : public boost::asio::detail::service_base<sigchld_service>
+{
+    boost::asio::io_service::strand _strand{get_io_service()};
+    boost::asio::signal_set _signal_set{get_io_service(), SIGCHLD};
+
+    std::vector<std::pair<::pid_t, std::function<void(int, std::error_code)>>> _receivers;
+    inline void _handle_signal(const boost::system::error_code & ec);
+public:
+    sigchld_service(boost::asio::io_service & io_service)
+        : boost::asio::detail::service_base<sigchld_service>(io_service)
+    {
+    }
+
+    template <typename SignalHandler>
+    BOOST_ASIO_INITFN_RESULT_TYPE(SignalHandler,
+        void (int, std::error_code))
+    async_wait(::pid_t pid, SignalHandler && handler)
+    {
+        boost::asio::detail::async_result_init<
+        SignalHandler, void(boost::system::error_code)> init{std::forward<SignalHandler>(handler)};
+        auto & h = init.handler;
+        _strand.post(
+                [this, pid, h]
+                {
+                    if (_receivers.empty())
+                        _signal_set.async_wait(
+                                [this](const boost::system::error_code & ec, int)
+                                {
+                                    _strand.post([this,ec]{this->_handle_signal(ec);});
+                                });
+                    _receivers.emplace_back(pid, h);
+                });
+
+        return init.result.get();
+    }
+    void shutdown_service() override
+    {
+        _receivers.clear();
+    }
+
+    void cancel()
+    {
+        _signal_set.cancel();
+    }
+    void cancel(boost::system::error_code & ec)
+    {
+        _signal_set.cancel(ec);
+    }
+};
+
+
+void sigchld_service::_handle_signal(const boost::system::error_code & ec)
+{
+    std::error_code ec_{ec.value(), std::system_category()};
+
+    if (ec_)
+    {
+        for (auto & r : _receivers)
+            r.second(-1, ec_);
+        return;
+    }
+    int status;
+    int pid = ::waitpid(0, &status, WNOHANG);
+
+    auto itr = std::find_if(_receivers.cbegin(), _receivers.cend(),
+            [&pid](const std::pair<::pid_t, std::function<void(int, std::error_code)>> & p)
+            {
+                return p.first == pid;
+            });
+    if (itr != _receivers.cend())
+    {
+        _strand.get_io_service().wrap(itr->second)(status, ec_);
+        _receivers.erase(itr);
+    }
+    if (!_receivers.empty())
+    {
+        _signal_set.async_wait(
+            [this](const boost::system::error_code & ec, int)
+            {
+                _strand.post([ec]{});
+                this->_handle_signal(ec);
+            });
+    }
+}
+
+
+}
+}
+}
+}
+
+
+
+
+#endif
--- boost\process\detail\posix\wait_for_exit.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\wait_for_exit.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -12,39 +12,41 @@
 
 #include <boost/process/detail/config.hpp>
 #include <boost/process/detail/posix/child_handle.hpp>
 #include <system_error>
 #include <sys/types.h>
 #include <sys/wait.h>
-
+#include <unistd.h>
 
 namespace boost { namespace process { namespace detail { namespace posix {
 
 inline void wait(const child_handle &p, int & exit_code)
 {
     pid_t ret;
     int status;
     do
     {
         ret = ::waitpid(p.pid, &status, 0);
-    } while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status)));
+    } while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status) && !WIFSIGNALED(status)));
     if (ret == -1)
         boost::process::detail::throw_last_error("waitpid(2) failed");
+    if (WIFSIGNALED(status))
+        throw process_error(std::error_code(), "process terminated due to receipt of a signal");
      exit_code = status;
 }
 
 inline void wait(const child_handle &p, int & exit_code, std::error_code &ec) noexcept
 {
     pid_t ret;
     int status;
 
     do
     {
         ret = ::waitpid(p.pid, &status, 0);
     } 
-    while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status)));
+    while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status) && !WIFSIGNALED(status)));
     
     if (ret == -1)
         ec = boost::process::detail::get_last_error();
     else
     {
         ec.clear();
@@ -64,32 +66,33 @@
     pid_t ret;
     int status;
 
     auto start = std::chrono::system_clock::now();
     auto time_out = start + rel_time;
 
-    bool time_out_occured = false;
+    bool timed_out;
     do
     {
-        ret = ::waitpid(p.pid, &status, WUNTRACED | WNOHANG);
-        if (std::chrono::system_clock::now() >= time_out)
+        ret = ::waitpid(p.pid, &status, WNOHANG);
+        if (ret == 0)
         {
-            time_out_occured = true;
-            break;
+            timed_out = std::chrono::system_clock::now() >= time_out;    
+            if (timed_out)
+                return false;
         }
     } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    while ((ret == 0) ||
+           ((ret == -1) && errno == EINTR) ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status)));
 
-
     if (ret == -1)
         boost::process::detail::throw_last_error("waitpid(2) failed");
-     
+
     exit_code = status;
 
-    return !time_out_occured;
+    return true;
 }
 
 
 template< class Rep, class Period >
 inline bool wait_for(
         const child_handle &p,
@@ -100,106 +103,122 @@
 
     pid_t ret;
     int status;
 
     auto start = std::chrono::system_clock::now();
     auto time_out = start + rel_time;
-
-    bool time_out_occured = false;
+    bool timed_out;
+
     do
     {
-        ret = ::waitpid(p.pid, &status, WUNTRACED | WNOHANG);
-        if (std::chrono::system_clock::now() >= time_out)
+        ret = ::waitpid(p.pid, &status, WNOHANG);
+        if (ret == 0)
         {
-            time_out_occured = true;
-            break;
+            timed_out = std::chrono::system_clock::now() >= time_out;    
+            if (timed_out)
+                return false;
         }
     } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    while ((ret == 0) ||
+          (((ret == -1) && errno == EINTR) ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status))));
 
 
+    if (timed_out && (ret == -1))
+    	return false;
+
     if (ret == -1)
         ec = boost::process::detail::get_last_error();
     else
     {
         ec.clear();
         exit_code = status;
     }
 
-    return !time_out_occured;
+    return true;
 }
 
 
 
-template< class Rep, class Period >
+template< class Clock, class Duration >
 inline bool wait_until(
         const child_handle &p,
         int & exit_code,
-        const std::chrono::duration<Rep, Period>& time_out)
+        const std::chrono::time_point<Clock, Duration>& time_out)
 {
 
     pid_t ret;
     int status;
 
-    bool time_out_occured = false;
+    bool timed_out;
     do
     {
-        ret = ::waitpid(p.pid, &status, WUNTRACED | WNOHANG);
-        if (std::chrono::system_clock::now() >= time_out)
+        ret = ::waitpid(p.pid, &status, WNOHANG);
+        if (ret == 0)
         {
-            time_out_occured = true;
-            break;
+            timed_out = std::chrono::system_clock::now() >= time_out;    
+            if (timed_out)
+                return false;
         }
-    } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    }
+    while ((ret == 0) ||
+          (((ret == -1) && errno == EINTR) ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status))));
 
 
+    if (timed_out && !WIFEXITED(status))
+    	return false;
+
     if (ret == -1)
         boost::process::detail::throw_last_error("waitpid(2) failed");
-
     exit_code = status;
 
-    return !time_out_occured;
+    return true;
 }
 
 
-template< class Rep, class Period >
+template< class Clock, class Duration >
 inline bool wait_until(
         const child_handle &p,
         int & exit_code,
-        const std::chrono::duration<Rep, Period>& time_out,
+        const std::chrono::time_point<Clock, Duration>& time_out,
         std::error_code & ec) noexcept
 {
 
     pid_t ret;
     int status;
 
-    bool time_out_occured = false;
+    bool timed_out;
+
     do
     {
-        ret = ::waitpid(p.pid, &status, WUNTRACED | WNOHANG);
-        if (std::chrono::system_clock::now() >= time_out)
+        ret = ::waitpid(p.pid, &status, WNOHANG);
+        if (ret == 0)
         {
-            time_out_occured = true;
-            break;
+            timed_out = std::chrono::system_clock::now() >= time_out;    
+            if (timed_out)
+                return false;
         }
     } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    while ((ret == 0) ||
+          (((ret == -1) && errno == EINTR) ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status))));
 
 
+
+    if (timed_out && !WIFEXITED(status))
+    	return false;
+
     if (ret == -1)
         ec = boost::process::detail::get_last_error();
     else
     {
         ec.clear();
         exit_code = status;
     }
 
-    return !time_out_occured;
+    return true;
 }
 
 }}}}
 
 #endif
--- boost\process\detail\posix\wait_group.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\posix\wait_group.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -22,30 +22,34 @@
 {
     pid_t ret;
     int status;
     do
     {
         ret = ::waitpid(-p.grp, &status, 0);
-    } while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status)));
+    } while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status) && !WIFSIGNALED(status)));
     if (ret == -1)
         boost::process::detail::throw_last_error("waitpid(2) failed");
+    if (WIFSIGNALED(status))
+        throw process_error(std::error_code(), "process group terminated due to receipt of a signal");
 }
 
 inline void wait(const group_handle &p, std::error_code &ec) noexcept
 {
     pid_t ret;
     int status;
 
     do
     {
         ret = ::waitpid(-p.grp, &status, 0);
     } 
-    while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status)));
+    while (((ret == -1) && (errno == EINTR)) || (ret != -1 && !WIFEXITED(status) && !WIFSIGNALED(status)));
     
     if (ret == -1)
         ec = boost::process::detail::get_last_error();
+    else if (WIFSIGNALED(status))
+        ec = std::make_error_code(std::errc::no_such_process);
     else
         ec.clear();
 
 }
 
 template< class Rep, class Period >
@@ -67,19 +71,20 @@
         if (std::chrono::system_clock::now() >= time_out)
         {
             time_out_occured = true;
             break;
         }
     } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    while (((ret == -1) && errno == EINTR)                               ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status)));
 
 
     if (ret == -1)
         boost::process::detail::throw_last_error("waitpid(2) failed");
-     
+    if (WIFSIGNALED(status))
+        throw process_error(std::error_code(), "process group terminated due to receipt of a signal");
 
     return !time_out_occured;
 }
 
 
 template< class Rep, class Period >
@@ -102,18 +107,20 @@
         if (std::chrono::system_clock::now() >= time_out)
         {
             time_out_occured = true;
             break;
         }
     } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    while (((ret == -1) && errno == EINTR)                       ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status)));
 
 
     if (ret == -1)
         ec = boost::process::detail::get_last_error();
+    else if (WIFSIGNALED(status))
+        ec = std::make_error_code(std::errc::no_such_process);
     else
         ec.clear();
 
     return !time_out_occured;
 }
 
@@ -125,30 +132,30 @@
         const std::chrono::duration<Rep, Period>& time_out)
 {
 
     pid_t ret;
     int status;
 
-    auto start = std::chrono::system_clock::now();
-
     bool time_out_occured = false;
     do
     {
         ret = ::waitpid(-p.grp, &status, WUNTRACED | WNOHANG);
         if (std::chrono::system_clock::now() >= time_out)
         {
             time_out_occured = true;
             break;
         }
     } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    while (((ret == -1) && errno == EINTR)                               ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status)));
 
 
     if (ret == -1)
         boost::process::detail::throw_last_error("waitpid(2) failed");
+    if (WIFSIGNALED(status))
+        throw process_error(std::error_code(), "process group terminated due to receipt of a signal");
 
 
     return !time_out_occured;
 }
 
 
@@ -171,21 +178,23 @@
         if (std::chrono::system_clock::now() >= time_out)
         {
             time_out_occured = true;
             break;
         }
     } 
-    while (((ret == -1) && errno == EINTR)       || 
-           ((ret != -1) && !WIFEXITED(status)));
+    while (((ret == -1) && errno == EINTR)                               ||
+           ((ret != -1) && !WIFEXITED(status) && !WIFSIGNALED(status)));
 
 
     if (ret == -1)
         ec = boost::process::detail::get_last_error();
+    else if (WIFSIGNALED(status))
+        ec = std::make_error_code(std::errc::no_such_process);
     else
         ec.clear();
 
     return !time_out_occured;
 }
 
 }}}}
 
 #endif
--- boost\process\detail\windows\async_out.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\windows\async_out.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -135,14 +135,17 @@
                         promise->set_exception(std::make_exception_ptr(process_error(e)));
                     }
                     else
                     {
                         std::istream is (buffer.get());
                         Type arg;
-                        arg.resize(buffer->size());
-                        is.read(&*arg.begin(), buffer->size());
+                        if (buffer->size() > 0)
+                        {
+                        	arg.resize(buffer->size());
+                        	is.read(&*arg.begin(), buffer->size());
+                        }
 
                         promise->set_value(std::move(arg));
 
 
                     }
                 });
--- boost\process\detail\windows\async_pipe.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\windows\async_pipe.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -75,16 +75,14 @@
     inline async_pipe& operator=(const async_pipe& rhs);
 
     inline async_pipe& operator=(async_pipe&& rhs);
 
     ~async_pipe()
     {
-        if (_sink .native()  != ::boost::detail::winapi::INVALID_HANDLE_VALUE_)
-            ::boost::detail::winapi::CloseHandle(_sink.native());
-        if (_source.native() != ::boost::detail::winapi::INVALID_HANDLE_VALUE_)
-            ::boost::detail::winapi::CloseHandle(_source.native());
+        boost::system::error_code ec;
+        close(ec);
     }
 
     template<class CharT, class Traits = std::char_traits<CharT>>
     inline explicit operator basic_pipe<CharT, Traits>() const;
 
     void cancel()
--- boost\process\detail\windows\basic_cmd.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\windows\basic_cmd.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -64,17 +64,31 @@
     return st;
 }
 
 inline std::wstring build_args(const std::wstring & exe, std::vector<std::wstring> && data)
 {
     std::wstring st = exe;
+
+    //put in quotes if it has spaces
+    {
+        boost::replace_all(st, L"\"", L"\\\"");
+
+        auto it = std::find(st.begin(), st.end(), L' ');
+
+        if (it != st.end())//contains spaces.
+        {
+            st.insert(st.begin(), L'"');
+            st += L'"';
+        }
+    }
+
     for (auto & arg : data)
     {
         boost::replace_all(arg, L"\"", L"\\\"");
 
-        auto it = std::find(arg.begin(), arg.end(), ' ');//contains space?
+        auto it = std::find(arg.begin(), arg.end(), L' ');//contains space?
         if (it != arg.end())//ok, contains spaces.
         {
             //the first one is put directly onto the output,
             //because then I don't have to copy the whole string
             arg.insert(arg.begin(), L'"');
             arg += L'"'; //thats the post one.
--- boost\process\detail\windows\environment.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\windows\environment.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -297,16 +297,14 @@
 
     if (itr == _data.end())
         return;//nothing to return if it's empty anyway...
 
     auto end = itr;
 
-    while (*end != '\0')
-        end++;
+    while (*++end != '\0');
 
-    end ++; //to point behind the last null-char
 
     _data.erase(itr, end);//and remove it
     reload();
 
 
 }
--- boost\process\detail\windows\search_path.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\windows\search_path.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -17,38 +17,63 @@
 #include <string>
 #include <stdexcept>
 #include <array>
 #include <atomic>
 #include <cstdlib>
 #include <boost/detail/winapi/shell.hpp>
-
+#include <boost/process/environment.hpp>
 
-
 namespace boost { namespace process { namespace detail { namespace windows {
 
 inline boost::filesystem::path search_path(
         const boost::filesystem::path &filename,
         const std::vector<boost::filesystem::path> &path)
 {
+    const ::boost::process::wnative_environment ne{};
+    typedef typename ::boost::process::wnative_environment::const_entry_type value_type;
+    const auto id = L"PATHEXT";
+
+    auto itr = std::find_if(ne.cbegin(), ne.cend(),
+            [&](const value_type & e)
+             {return id == ::boost::to_upper_copy(e.get_name(), ::boost::process::detail::process_locale());});
+
+    auto extensions_in = itr->to_vector();
+
+    std::vector<std::wstring> extensions((extensions_in.size() * 2) + 1);
+
+    auto it_ex = extensions.begin();
+    it_ex++;
+    it_ex = std::transform(extensions_in.begin(), extensions_in.end(), it_ex,
+                [](const std::wstring & ws){return boost::to_lower_copy(ws, ::boost::process::detail::process_locale());});
+
+    std::transform(extensions_in.begin(), extensions_in.end(), it_ex,
+                [](const std::wstring & ws){return boost::to_upper_copy(ws, ::boost::process::detail::process_locale());});
+
+
+    std::copy(std::make_move_iterator(extensions_in.begin()), std::make_move_iterator(extensions_in.end()), extensions.begin() + 1);
+
+
+    for (auto & ext : extensions)
+        boost::to_lower(ext);
+
     for (const boost::filesystem::path & pp : path)
     {
-        auto full = pp / filename;
-        std::array<std::string, 4> extensions {{ "", ".exe", ".com", ".bat" }};
+        auto p = pp / filename;
         for (boost::filesystem::path ext : extensions)
         {
-            auto p = full;
-            p += ext;
+            boost::filesystem::path pp = p;
+            pp += ext;
             boost::system::error_code ec;
-            bool file = boost::filesystem::is_regular_file(p, ec);
+            bool file = boost::filesystem::is_regular_file(pp, ec);
             if (!ec && file &&
-                ::boost::detail::winapi::sh_get_file_info(p.string().c_str(), 0, 0, 0, ::boost::detail::winapi::SHGFI_EXETYPE_))
+                ::boost::detail::winapi::sh_get_file_info(pp.native().c_str(), 0, 0, 0, ::boost::detail::winapi::SHGFI_EXETYPE_))
             {
-                return p;
+                return pp;
             }
         }
     }
     return "";
 }
 
 }}}}
 
 #endif
--- boost\process\detail\windows\wait_for_exit.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\windows\wait_for_exit.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -162,32 +162,36 @@
         std::error_code &ec) noexcept
 {
     std::chrono::milliseconds ms =
             std::chrono::duration_cast<std::chrono::milliseconds>(
                     timeout_time - std::chrono::system_clock::now());
 
-    ::boost::detail::winapi::DWORD_ _exit_code = 1;
-
-    if (::boost::detail::winapi::WaitForSingleObject(p.process_handle(),
-            static_cast<::boost::detail::winapi::DWORD_>(ms.count()))
-                == ::boost::detail::winapi::wait_failed)
+    ::boost::detail::winapi::DWORD_ wait_code;
+    wait_code = ::boost::detail::winapi::WaitForSingleObject(p.process_handle(),
+                    static_cast<::boost::detail::winapi::DWORD_>(ms.count()));
+
+    if (wait_code == ::boost::detail::winapi::wait_failed)
         ec = std::error_code(
             ::boost::detail::winapi::GetLastError(),
             std::system_category());
-    else if (!::boost::detail::winapi::GetExitCodeProcess(p.process_handle(), &_exit_code))
+    else if (wait_code == ::boost::detail::winapi::wait_timeout)
+    	return false;
+
+    ::boost::detail::winapi::DWORD_ _exit_code;
+    if (!::boost::detail::winapi::GetExitCodeProcess(p.process_handle(), &_exit_code))
         ec = std::error_code(
             ::boost::detail::winapi::GetLastError(),
             std::system_category());
     else
         ec.clear();
 
-    exit_code = static_cast<int>(exit_code);
+    exit_code = static_cast<int>(_exit_code);
     ::boost::detail::winapi::CloseHandle(p.proc_info.hProcess);
     p.proc_info.hProcess = ::boost::detail::winapi::INVALID_HANDLE_VALUE_;
     return true;
 ;
 }
 
 
 }}}}
 
 #endif
--- boost\process\detail\config.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\detail\config.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -69,12 +69,17 @@
 
 inline void throw_last_error(const std::string & msg)
 {
     throw process_error(get_last_error(), msg);
 }
 
+inline void throw_last_error(const char * msg)
+{
+    throw process_error(get_last_error(), msg);
+}
+
 inline void throw_last_error()
 {
     throw process_error(get_last_error());
 }
 
 
--- boost\process\async.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\async.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -114,17 +114,17 @@
 std::future<int> exit_code;
 chlid c2("ls", on_exit=exit_code);
 
 \endcode
 
 \note The handler is not invoked when the launch fails.
-\warning When used \ref ignore_error it might gte invoked on error.
-
+\warning When used \ref ignore_error it might get invoked on error.
+\warning All `on_exit` use one signal(SIGCHLD) on posix, which is only guaranteed to work when all use the same `io_service`.
  */
 constexpr static ::boost::process::detail::on_exit_ on_exit{};
 #endif
 
 }}
 
 
 
 #endif /* INCLUDE_BOOST_PROCESS_DETAIL_ASYNC_HPP_ */
--- boost\process\child.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\child.hpp	2017-08-26 23:03:08.000000000 -0700
@@ -32,12 +32,15 @@
 
 template<typename ...Args>
 child::child(Args&&...args)
     : child(::boost::process::detail::execute_impl(std::forward<Args>(args)...)) {}
 
 
+///Typedef for the type of an pid_t
+typedef ::boost::process::detail::api::pid_t pid_t;
+
 #if defined(BOOST_PROCESS_DOXYGEN)
 /** The main class to hold a child process. It is simliar to [std::thread](http://en.cppreference.com/w/cpp/thread/thread),
  * in that it has a join and detach function.
  *
  * @attention The destructor will call terminate on the process if not joined or detached without any warning.
  *
--- boost\process\io.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\process\io.hpp	2017-08-26 23:03:09.000000000 -0700
@@ -95,13 +95,13 @@
 std::future<std::string> output;
 system("ls", std_out > output, ios);
 
 auto res = fut.get();
 \endcode
 
-\note `boost/process/asnyc.hpp` must also be included for this to work.
+\note `boost/process/async.hpp` must also be included for this to work.
 
 \par Closing
 
 Stream can be closed, so nothing can be read or written.
 
 \code{.cpp}
--- boost\proto\detail\decltype.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\proto\detail\decltype.hpp	2017-08-21 15:45:35.000000000 -0700
@@ -40,13 +40,13 @@
 # pragma warning(push)
 # pragma warning(disable : 4714) // function 'xxx' marked as __forceinline not inlined
 #endif
 
 // We're STILL using Boost.Typeof on MSVC even for msvc-11.0 because of this bug:
 // https://connect.microsoft.com/VisualStudio/feedback/details/765392/decltype-of-a-pointer-to-member-operator-gets-ref-qualification-wrong
-#if !defined(BOOST_NO_CXX11_DECLTYPE) && !BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1700))
+#if !defined(BOOST_NO_CXX11_DECLTYPE) && !BOOST_WORKAROUND(BOOST_MSVC, < 1900 )
 # define BOOST_PROTO_DECLTYPE_(EXPR, TYPE) typedef decltype((EXPR)) TYPE;
 #else
 # define BOOST_PROTO_DECLTYPE_NESTED_TYPEDEF_TPL_(NESTED, EXPR)                                     \
     BOOST_TYPEOF_NESTED_TYPEDEF_TPL(BOOST_PP_CAT(nested_and_hidden_, NESTED), EXPR)                 \
     static int const BOOST_PP_CAT(sz, NESTED) = sizeof(boost::proto::detail::check_reference(EXPR));\
     struct NESTED                                                                                   \
--- boost\proto\expr.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\proto\expr.hpp	2017-08-21 15:46:02.000000000 -0700
@@ -89,13 +89,13 @@
             }
             return that;
         }
 
         // Work-around for:
         // https://connect.microsoft.com/VisualStudio/feedback/details/765449/codegen-stack-corruption-using-runtime-checks-when-aggregate-initializing-struct
-    #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1700))
+    #if BOOST_WORKAROUND(BOOST_MSVC, < 1800 )
         template<typename T, typename Expr, typename C, typename U>
         BOOST_FORCEINLINE
         Expr make_terminal(T &t, Expr *, proto::term<U C::*> *)
         {
             Expr that;
             that.child0 = t;
--- boost\proto\generate.hpp	2017-08-19 09:49:45.000000000 -0700
+++ boost\proto\generate.hpp	2017-08-21 15:46:20.000000000 -0700
@@ -227,13 +227,13 @@
             Extends<Expr> that = {e};
             return that;
         }
 
         // Work-around for:
         // https://connect.microsoft.com/VisualStudio/feedback/details/765449/codegen-stack-corruption-using-runtime-checks-when-aggregate-initializing-struct
-    #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1700))
+    #if BOOST_WORKAROUND(BOOST_MSVC, < 1800 )
         template<typename Class, typename Member>
         BOOST_FORCEINLINE
         Extends<expr<tag::terminal, proto::term<Member Class::*> > > operator ()(expr<tag::terminal, proto::term<Member Class::*> > const &e) const
         {
             Extends<expr<tag::terminal, proto::term<Member Class::*> > > that;
             proto::value(that.proto_expr_) = proto::value(e);
--- boost\range\algorithm_ext\insert.hpp	2017-08-19 09:49:48.000000000 -0700
+++ boost\range\algorithm_ext\insert.hpp	2017-08-21 15:47:30.000000000 -0700
@@ -36,13 +36,14 @@
 template< class Container, class Range >
 inline Container& insert( Container& on, const Range& from )
 {
     BOOST_RANGE_CONCEPT_ASSERT(( ForwardRangeConcept<Container> ));
     BOOST_RANGE_CONCEPT_ASSERT(( SinglePassRangeConcept<Range> ));
     on.insert(boost::begin(from), boost::end(from));
+    return on;
 }
 
     } // namespace range
     using range::insert;
 } // namespace boost
 
 #endif // include guard
--- boost\range\adaptors.hpp	2017-08-19 09:49:48.000000000 -0700
+++ boost\range\adaptors.hpp	2017-08-21 15:47:48.000000000 -0700
@@ -23,9 +23,10 @@
 #include <boost/range/adaptor/replaced_if.hpp>
 #include <boost/range/adaptor/reversed.hpp>
 #include <boost/range/adaptor/sliced.hpp>
 #include <boost/range/adaptor/strided.hpp>
 #include <boost/range/adaptor/tokenized.hpp>
 #include <boost/range/adaptor/transformed.hpp>
+#include <boost/range/adaptor/type_erased.hpp>
 #include <boost/range/adaptor/uniqued.hpp>
 
 #endif
--- boost\range\algorithm.hpp	2017-08-19 09:49:48.000000000 -0700
+++ boost\range\algorithm.hpp	2017-08-21 15:48:01.000000000 -0700
@@ -74,12 +74,13 @@
 #include <boost/range/algorithm/reverse_copy.hpp>
 #include <boost/range/algorithm/rotate.hpp>
 #include <boost/range/algorithm/rotate_copy.hpp>
 #include <boost/range/algorithm/sort.hpp>
 #include <boost/range/algorithm/stable_partition.hpp>
 #include <boost/range/algorithm/stable_sort.hpp>
+#include <boost/range/algorithm/swap_ranges.hpp>
 #include <boost/range/algorithm/transform.hpp>
 #include <boost/range/algorithm/unique.hpp>
 #include <boost/range/algorithm/unique_copy.hpp>
 
 // Binary search
 #include <boost/range/algorithm/binary_search.hpp>
--- boost\smart_ptr\detail\local_counted_base.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\smart_ptr\detail\local_counted_base.hpp	2017-08-28 18:55:50.000000000 -0700
@@ -57,18 +57,20 @@
     virtual void local_cb_destroy() BOOST_SP_NOEXCEPT = 0;
 
     virtual boost::detail::shared_count local_cb_get_shared_count() const BOOST_SP_NOEXCEPT = 0;
 
     void add_ref() BOOST_SP_NOEXCEPT
     {
+#if !defined(__NVCC__)
 #if defined( __has_builtin )
 # if __has_builtin( __builtin_assume )
 
         __builtin_assume( local_use_count_ >= 1 );
 
-# endif
+# endif
+#endif
 #endif
 
         local_use_count_ = static_cast<count_type>( local_use_count_ + 1 );
     }
 
     void release() BOOST_SP_NOEXCEPT
--- boost\spirit\home\x3\binary\binary.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\spirit\home\x3\binary\binary.hpp	2017-08-24 15:07:24.000000000 -0700
@@ -34,13 +34,13 @@
 
         binary_lit_parser(V n_)
           : n(n_) {}
 
         template <typename Iterator, typename Context, typename Attribute>
         bool parse(Iterator& first, Iterator const& last
-          , Context& context, unused_type, Attribute& attr_param) const
+          , Context const& context, unused_type, Attribute& attr_param) const
         {
             x3::skip_over(first, last, context);
 
             auto bytes = reinterpret_cast<const unsigned char*>(&n);
 
             Iterator it = first;
@@ -66,13 +66,13 @@
         typedef T attribute_type;
         static bool const has_attribute =
             !is_same<unused_type, attribute_type>::value;
 
         template <typename Iterator, typename Context, typename Attribute>
         bool parse(Iterator& first, Iterator const& last
-          , Context& context, unused_type, Attribute& attr_param) const
+          , Context const& context, unused_type, Attribute& attr_param) const
         {
             x3::skip_over(first, last, context);
 
             attribute_type attr_;
             auto bytes = reinterpret_cast<unsigned char*>(&attr_);
 
--- boost\spirit\home\x3\char\char_set.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\spirit\home\x3\char\char_set.hpp	2017-08-24 15:07:47.000000000 -0700
@@ -34,13 +34,13 @@
 
 
         char_range(char_type from_, char_type to_)
           : from(from_), to(to_) {}
 
         template <typename Char, typename Context>
-        bool test(Char ch_, Context& context) const
+        bool test(Char ch_, Context const& context) const
         {
 
             char_type ch = char_type(ch_);  // optimize for token based parsing
             return ((sizeof(Char) <= sizeof(char_type)) || encoding::ischar(ch_))
                         && (get_case_compare<encoding>(context)(ch, from) >= 0 )
                         && (get_case_compare<encoding>(context)(ch , to) <= 0 );
--- boost\spirit\home\x3\directive\confix.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\spirit\home\x3\directive\confix.hpp	2017-08-24 15:08:10.000000000 -0700
@@ -32,13 +32,13 @@
         }
 
         template<typename Iterator, typename Context
                  , typename RContext, typename Attribute>
         bool parse(
             Iterator& first, Iterator const& last
-            , Context& context, RContext& rcontext, Attribute& attr) const
+            , Context const& context, RContext& rcontext, Attribute& attr) const
         {
             Iterator save = first;
 
             if (!(prefix.parse(first, last, context, rcontext, unused) &&
                   this->subject.parse(first, last, context, rcontext, attr) &&
                   postfix.parse(first, last, context, rcontext, unused)))
--- boost\spirit\home\x3\directive\with.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\spirit\home\x3\directive\with.hpp	2017-08-24 15:08:50.000000000 -0700
@@ -18,24 +18,24 @@
     template <typename Subject, typename Derived, typename T>
     struct with_value_holder
       : unary_parser<Subject, Derived>
     {
         typedef unary_parser<Subject, Derived> base_type;
         mutable T val;
-        with_value_holder(Subject const& subject, T const& val)
+        with_value_holder(Subject const& subject, T&& val)
           : base_type(subject)
-          , val(val) {}
+          , val(std::forward<T>(val)) {}
     };
     
     template <typename Subject, typename Derived, typename T>
-    struct with_value_holder<Subject, Derived, T const>
+    struct with_value_holder<Subject, Derived, T&>
       : unary_parser<Subject, Derived>
     {
         typedef unary_parser<Subject, Derived> base_type;
-        T val;
-        with_value_holder(Subject const& subject, T const& val)
+        T& val;
+        with_value_holder(Subject const& subject, T& val)
           : base_type(subject)
           , val(val) {}
     };
 
     template <typename Subject, typename ID, typename T>
     struct with_directive
@@ -44,14 +44,14 @@
         typedef with_value_holder<Subject, with_directive<Subject, ID, T>, T> base_type;
         static bool const is_pass_through_unary = true;
         static bool const handles_container = Subject::handles_container;
 
         typedef Subject subject_type;
 
-        with_directive(Subject const& subject, T const& val)
-          : base_type(subject, val) {}
+        with_directive(Subject const& subject, T&& val)
+          : base_type(subject, std::forward<T>(val)) {}
 
         template <typename Iterator, typename Context
           , typename RContext, typename Attribute>
         bool parse(Iterator& first, Iterator const& last
           , Context const& context, RContext& rcontext, Attribute& attr) const
         {
@@ -60,48 +60,27 @@
               , make_context<ID>(this->val, context)
               , rcontext
               , attr);
         }
     };
    
-    template <typename ID, typename T, typename NextContext = unused_type>
-    struct with_context
-    {
-        typedef context<ID, T, NextContext> type;
-    };
-    
     template <typename ID, typename T>
-    struct with_context<ID, T, unused_type>
-    {
-        typedef context<ID, T> type;
-    };
-
-    template <typename ID, typename T>
     struct with_gen
     {
-        T& val;
+        T&& val;
 
-        with_gen(T& val)
-          : val(val) {}
-
         template <typename Subject>
         with_directive<typename extension::as_parser<Subject>::value_type, ID, T>
         operator[](Subject const& subject) const
         {
-            return { as_parser(subject), val };
+            return { as_parser(subject), std::forward<T>(val) };
         }
     };
 
     template <typename ID, typename T>
-    inline with_gen<ID, T> with(T& val)
+    inline with_gen<ID, T> with(T&& val)
     {
-        return { val };
+        return { std::forward<T>(val) };
     }
-    
-    template <typename ID, typename T>
-    inline with_gen<ID, T const> with(T const& val)
-    {
-        return { val };
-    }
 }}}
 
 #endif
--- boost\spirit\home\x3\numeric\bool.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\spirit\home\x3\numeric\bool.hpp	2017-08-24 15:09:19.000000000 -0700
@@ -67,22 +67,22 @@
         template <typename Value>
         literal_bool_parser(Value const& n, BoolPolicies const& policies)
         	: policies(policies), n_(n) {}
 
         template <typename Iterator, typename Context>
         bool parse_main(Iterator& first, Iterator const& last
-          , Context& context, T& attr) const
+          , Context const& context, T& attr) const
         {
             x3::skip_over(first, last, context);
             return (n_ && policies.parse_true(first, last, attr, get_case_compare<encoding>(context)))
                 || (!n_ && policies.parse_false(first, last, attr, get_case_compare<encoding>(context)));
         }
 
         template <typename Iterator, typename Context>
         bool parse(Iterator& first, Iterator const& last
-          , Context& context, unused_type, T& attr) const
+          , Context const& context, unused_type, T& attr) const
         {
             return parse_main(first, last, context, attr);
         }
 
         template <typename Iterator, typename Context, typename Attribute>
         bool parse(Iterator& first, Iterator const& last
--- boost\spirit\home\x3\numeric\real.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\spirit\home\x3\numeric\real.hpp	2017-08-24 15:09:42.000000000 -0700
@@ -25,21 +25,21 @@
 
         real_parser(RealPolicies const& policies)
         	: policies(policies) {}
 
         template <typename Iterator, typename Context>
         bool parse(Iterator& first, Iterator const& last
-          , Context& context, unused_type, T& attr_) const
+          , Context const& context, unused_type, T& attr_) const
         {
             x3::skip_over(first, last, context);
             return extract_real<T, RealPolicies>::parse(first, last, attr_, policies);
         }
 
         template <typename Iterator, typename Context, typename Attribute>
         bool parse(Iterator& first, Iterator const& last
-          , Context& context, unused_type, Attribute& attr_param) const
+          , Context const& context, unused_type, Attribute& attr_param) const
         {
             // this case is called when Attribute is not T
             T attr_;
             if (parse(first, last, context, unused, attr_))
             {
                 traits::move_to(attr_, attr_param);
--- boost\spirit\home\x3\support\ast\variant.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\spirit\home\x3\support\ast\variant.hpp	2017-08-24 18:03:24.000000000 -0700
@@ -4,15 +4,16 @@
     Distributed under the Boost Software License, Version 1.0. (See accompanying
     file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 ==============================================================================*/
 #if !defined(BOOST_SPIRIT_X3_VARIANT_AUGUST_6_2011_0859AM)
 #define BOOST_SPIRIT_X3_VARIANT_AUGUST_6_2011_0859AM
 
+#include <boost/config.hpp>
 #include <boost/variant.hpp>
 #include <boost/mpl/list.hpp>
-#include <boost/type_traits/is_base_of.hpp>
+#include <utility>
 #include <type_traits>
 
 ///////////////////////////////////////////////////////////////////////////////
 namespace boost { namespace spirit { namespace x3
 {
     template <typename T>
@@ -26,13 +27,13 @@
 
         forward_ast() : p_(new T) {}
 
         forward_ast(forward_ast const& operand)
             : p_(new T(operand.get())) {}
 
-        forward_ast(forward_ast&& operand)
+        forward_ast(forward_ast&& operand) BOOST_NOEXCEPT
             : p_(operand.p_)
         {
             operand.p_ = 0;
         }
 
         forward_ast(T const& operand)
@@ -43,55 +44,55 @@
 
         ~forward_ast()
         {
             boost::checked_delete(p_);
         }
 
-        forward_ast& operator=(forward_ast const& rhs)
+        forward_ast& operator=(forward_ast const& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_copy_assignable<T>{})
         {
             assign(rhs.get());
             return *this;
         }
 
         void swap(forward_ast& operand) BOOST_NOEXCEPT
         {
             T* temp = operand.p_;
             operand.p_ = p_;
             p_ = temp;
         }
 
-        forward_ast& operator=(T const& rhs)
+        forward_ast& operator=(T const& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_copy_assignable<T>{})
         {
             assign(rhs);
             return *this;
         }
 
         forward_ast& operator=(forward_ast&& rhs) BOOST_NOEXCEPT
         {
             swap(rhs);
             return *this;
         }
 
-        forward_ast& operator=(T&& rhs)
+        forward_ast& operator=(T&& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_move_assignable<T>{})
         {
             get() = std::move(rhs);
             return *this;
         }
 
-        T& get() { return *get_pointer(); }
-        const T& get() const { return *get_pointer(); }
+        T& get() BOOST_NOEXCEPT { return *get_pointer(); }
+        const T& get() const BOOST_NOEXCEPT { return *get_pointer(); }
 
-        T* get_pointer() { return p_; }
-        const T* get_pointer() const { return p_; }
+        T* get_pointer() BOOST_NOEXCEPT { return p_; }
+        const T* get_pointer() const BOOST_NOEXCEPT { return p_; }
 
-        operator T const&() const { return this->get(); }
-        operator T&() { return this->get(); }
+        operator T const&() const BOOST_NOEXCEPT { return this->get(); }
+        operator T&() BOOST_NOEXCEPT { return this->get(); }
 
     private:
 
-        void assign(const T& rhs)
+        void assign(const T& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_copy_assignable<T>{})
         {
             this->get() = rhs;
         }
 
         T* p_;
     };
@@ -132,52 +133,52 @@
             = std::enable_if_t<!(std::is_base_of<base_type
                                                 ,std::remove_reference_t<T>
                                                 >
                                                 ::value)
                               >;
 
-        variant() : var() {}
+        variant() BOOST_NOEXCEPT_IF(std::is_nothrow_default_constructible<variant_type>{}) : var() {}
 
         template <typename T, class = non_self_t<T>>
-        explicit variant(T const& rhs)
+        explicit variant(T const& rhs) BOOST_NOEXCEPT_IF((std::is_nothrow_constructible<variant_type, T const&>{}))
             : var(rhs) {}
 
         template <typename T, class = non_self_t<T>>
-        explicit variant(T&& rhs)
+        explicit variant(T&& rhs) BOOST_NOEXCEPT_IF((std::is_nothrow_constructible<variant_type, T&&>{}))
             : var(std::forward<T>(rhs)) {}
 
-        variant(variant const& rhs)
+        variant(variant const& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_copy_constructible<variant_type>{})
             : var(rhs.var) {}
 
-        variant(variant& rhs)
+        variant(variant& rhs) BOOST_NOEXCEPT_IF((std::is_nothrow_constructible<variant_type, variant_type&>{}))
             : var(rhs.var) {}
 
-        variant(variant&& rhs)
-            : var(std::forward<variant_type>(rhs.var)) {}
+        variant(variant&& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_move_constructible<variant_type>{})
+            : var(std::move(rhs.var)) {}
 
-        variant& operator=(variant const& rhs)
+        variant& operator=(variant const& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_copy_assignable<variant_type>{})
         {
             var = rhs.get();
             return *this;
         }
 
-        variant& operator=(variant&& rhs)
+        variant& operator=(variant&& rhs) BOOST_NOEXCEPT_IF(std::is_nothrow_move_assignable<variant_type>{})
         {
-            var = std::forward<variant_type>(rhs.get());
+            var = std::move(rhs.get());
             return *this;
         }
 
         template <typename T, class = non_self_t<T>>
-        variant& operator=(T const& rhs)
+        variant& operator=(T const& rhs) BOOST_NOEXCEPT_IF((std::is_nothrow_assignable<variant_type, T const&>{}))
         {
             var = rhs;
             return *this;
         }
 
         template <typename T, class = non_self_t<T>>
-        variant& operator=(T&& rhs)
+        variant& operator=(T&& rhs) BOOST_NOEXCEPT_IF((std::is_nothrow_assignable<variant_type, T&&>{}))
         {
             var = std::forward<T>(rhs);
             return *this;
         }
 
         template <typename F>
@@ -201,18 +202,18 @@
         template <typename F>
         typename F::result_type apply_visitor(F& v) const
         {
             return var.apply_visitor(v);
         }
 
-        variant_type const& get() const
+        variant_type const& get() const BOOST_NOEXCEPT
         {
             return var;
         }
 
-        variant_type& get()
+        variant_type& get() BOOST_NOEXCEPT
         {
             return var;
         }
 
         void swap(variant& rhs) BOOST_NOEXCEPT
         {
@@ -224,34 +225,34 @@
 }}}
 
 namespace boost
 {
     template <typename T, typename ...Types>
     inline T const&
-    get(boost::spirit::x3::variant<Types...> const& x)
+    get(boost::spirit::x3::variant<Types...> const& x) BOOST_NOEXCEPT
     {
         return boost::get<T>(x.get());
     }
 
     template <typename T, typename ...Types>
     inline T&
-    get(boost::spirit::x3::variant<Types...>& x)
+    get(boost::spirit::x3::variant<Types...>& x) BOOST_NOEXCEPT
     {
         return boost::get<T>(x.get());
     }
 
     template <typename T, typename ...Types>
     inline T const*
-    get(boost::spirit::x3::variant<Types...> const* x)
+    get(boost::spirit::x3::variant<Types...> const* x) BOOST_NOEXCEPT
     {
         return boost::get<T>(&x->get());
     }
 
     template <typename T, typename ...Types>
     inline T*
-    get(boost::spirit::x3::variant<Types...>* x)
+    get(boost::spirit::x3::variant<Types...>* x) BOOST_NOEXCEPT
     {
         return boost::get<T>(&x->get());
     }
 }
 
 #endif
--- boost\system\detail\error_code.ipp	2017-08-19 09:49:49.000000000 -0700
+++ boost\system\detail\error_code.ipp	2017-08-21 15:49:09.000000000 -0700
@@ -29,12 +29,18 @@
 #   endif
 #   ifndef ERROR_INCORRECT_SIZE
 #     define ERROR_INCORRECT_SIZE ERROR_BAD_ARGUMENTS
 #   endif
 # endif
 
+# ifdef BOOST_ERROR_CODE_HEADER_ONLY
+#   define BOOST_ERROR_CODE_HEADER_ONLY_INLINE inline
+# else
+#   define BOOST_ERROR_CODE_HEADER_ONLY_INLINE
+# endif
+
 //--------------------------------------------------------------------------------------//
 namespace boost
 {
     namespace system
     {
 
@@ -59,18 +65,18 @@
     std::string         message( int ev ) const;
     error_condition     default_error_condition( int ev ) const BOOST_SYSTEM_NOEXCEPT;
   };
 
   //  generic_error_category implementation  ---------------------------------//
 
-  const char * generic_error_category::name() const BOOST_SYSTEM_NOEXCEPT
+  BOOST_ERROR_CODE_HEADER_ONLY_INLINE const char * generic_error_category::name() const BOOST_SYSTEM_NOEXCEPT
   {
     return "generic";
   }
 
-  std::string generic_error_category::message( int ev ) const
+  BOOST_ERROR_CODE_HEADER_ONLY_INLINE std::string generic_error_category::message( int ev ) const
   {
     using namespace boost::system::errc;
 #if defined(__PGI)
       using boost::system::errc::invalid_argument;
 #endif
 
@@ -158,18 +164,18 @@
       return msg;
   #  endif   // else POSIX version of strerror_r
   # endif  // else use strerror_r
   }
   //  system_error_category implementation  --------------------------------------------//
 
-  const char * system_error_category::name() const BOOST_SYSTEM_NOEXCEPT
+  BOOST_ERROR_CODE_HEADER_ONLY_INLINE const char * system_error_category::name() const BOOST_SYSTEM_NOEXCEPT
   {
     return "system";
   }
 
-  error_condition system_error_category::default_error_condition( int ev ) const
+  BOOST_ERROR_CODE_HEADER_ONLY_INLINE error_condition system_error_category::default_error_condition( int ev ) const
     BOOST_SYSTEM_NOEXCEPT
   {
     using namespace boost::system::errc;
 #if defined(__PGI)
       using boost::system::errc::invalid_argument;
 #endif
@@ -368,19 +374,19 @@
     default: return error_condition( ev, system_category() );
     }
   }
 
 # if !defined( BOOST_WINDOWS_API )
 
-  std::string system_error_category::message( int ev ) const
+  BOOST_ERROR_CODE_HEADER_ONLY_INLINE std::string system_error_category::message( int ev ) const
   {
     return generic_category().message( ev );
   }
 # else
 
-  std::string system_error_category::message( int ev ) const
+  BOOST_ERROR_CODE_HEADER_ONLY_INLINE std::string system_error_category::message( int ev ) const
   {
 #if defined(UNDER_CE) || BOOST_PLAT_WINDOWS_RUNTIME || defined(BOOST_NO_ANSI_APIS)
     std::wstring buf(128, wchar_t());
     for (;;)
     {
         boost::detail::winapi::DWORD_ retval = boost::detail::winapi::FormatMessageW(
@@ -478,6 +484,8 @@
       static const generic_error_category generic_category_const;
       return generic_category_const;
     }
 
   } // namespace system
 } // namespace boost
+
+# undef BOOST_ERROR_CODE_HEADER_ONLY_INLINE
--- boost\system\error_code.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\system\error_code.hpp	2017-08-21 15:49:24.000000000 -0700
@@ -615,25 +615,25 @@
       inline error_condition make_error_condition( errc_t e ) BOOST_SYSTEM_NOEXCEPT
         { return error_condition( e, generic_category() ); }
     }
 
     //  error_category default implementation  -----------------------------------------//
 
-    error_condition error_category::default_error_condition( int ev ) const
+    inline error_condition error_category::default_error_condition( int ev ) const
       BOOST_SYSTEM_NOEXCEPT
     {
       return error_condition( ev, *this );
     }
 
-    bool error_category::equivalent( int code,
+    inline bool error_category::equivalent( int code,
       const error_condition & condition ) const BOOST_SYSTEM_NOEXCEPT
     {
       return default_error_condition( code ) == condition;
     }
 
-    bool error_category::equivalent( const error_code & code,
+    inline bool error_category::equivalent( const error_code & code,
       int condition ) const BOOST_SYSTEM_NOEXCEPT
     {
       return *this == code.category() && code.value() == condition;
     }
 
 #ifndef BOOST_NO_CXX11_HDR_SYSTEM_ERROR
--- boost\thread\detail\config.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\detail\config.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -9,27 +9,25 @@
 #define BOOST_THREAD_CONFIG_WEK01032003_HPP
 
 #include <boost/config.hpp>
 #include <boost/detail/workaround.hpp>
 #include <boost/thread/detail/platform.hpp>
 
-#define BOOST_THREAD_USEFIXES_TIMESPEC
 //#define BOOST_THREAD_HAS_CONDATTR_SET_CLOCK_MONOTONIC
 //#define BOOST_THREAD_DONT_PROVIDE_INTERRUPTIONS
 // ATTRIBUTE_MAY_ALIAS
 
-#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
+//#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
+#if !defined(BOOST_NO_MAY_ALIAS)
 
-  // GCC since 3.3 has may_alias attribute that helps to alleviate optimizer issues with
-  // regard to violation of the strict aliasing rules.
+  // GCC since 3.3 and some other compilers have may_alias attribute that helps
+  // to alleviate optimizer issues with regard to violation of the strict aliasing rules.
 
   #define BOOST_THREAD_DETAIL_USE_ATTRIBUTE_MAY_ALIAS
-  #define BOOST_THREAD_ATTRIBUTE_MAY_ALIAS __attribute__((__may_alias__))
-#else
-  #define BOOST_THREAD_ATTRIBUTE_MAY_ALIAS
 #endif
+#define BOOST_THREAD_ATTRIBUTE_MAY_ALIAS BOOST_MAY_ALIAS
 
 
 #if defined BOOST_THREAD_THROW_IF_PRECONDITION_NOT_SATISFIED
 #define BOOST_THREAD_ASSERT_PRECONDITION(EXPR, EX) \
         if (EXPR) {} else boost::throw_exception(EX)
 #define BOOST_THREAD_VERIFY_PRECONDITION(EXPR, EX) \
--- boost\thread\detail\thread.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\detail\thread.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -154,13 +154,13 @@
             }
         };
 #endif
     }
 namespace thread_detail {
 #ifdef BOOST_THREAD_USES_CHRONO
-#if defined(BOOST_THREAD_HAS_CONDATTR_SET_CLOCK_MONOTONIC) && defined(BOOST_THREAD_USEFIXES_TIMESPEC)
+#if defined(BOOST_THREAD_HAS_CONDATTR_SET_CLOCK_MONOTONIC)
         typedef chrono::steady_clock internal_clock_t;
 #else
         typedef chrono::system_clock internal_clock_t;
 #endif
 #endif
 }
@@ -296,13 +296,13 @@
             start_thread(attrs);
         }
 #else
         template <class F>
         explicit thread(F f
         , typename disable_if_c<
-        boost::thread_detail::is_rv<F>::value // todo ass a thread_detail::is_rv
+        boost::thread_detail::is_rv<F>::value // todo as a thread_detail::is_rv
         //boost::thread_detail::is_convertible<F&,BOOST_THREAD_RV_REF(F)>::value
             //|| is_same<typename decay<F>::type, thread>::value
            , dummy* >::type=0
         ):
             thread_info(make_thread_info(f))
         {
--- boost\thread\executors\detail\priority_executor_base.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\executors\detail\priority_executor_base.hpp	2017-08-28 20:49:56.000000000 -0700
@@ -54,16 +54,22 @@
     void loop()
     {
       try
       {
         for(;;)
         {
-          work task;
-          queue_op_status st = _workq.wait_pull(task);
-          if (st == queue_op_status::closed) return;
-          task();
+          try {
+            work task;
+            queue_op_status st = _workq.wait_pull(task);
+            if (st == queue_op_status::closed) return;
+            task();
+          }
+          catch (boost::thread_interrupted&)
+          {
+            return;
+          }
         }
       }
       catch (...)
       {
         std::terminate();
         return;
--- boost\thread\executors\basic_thread_pool.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\executors\basic_thread_pool.hpp	2017-08-28 20:49:56.000000000 -0700
@@ -83,17 +83,24 @@
     {
       try
       {
         for(;;)
         {
           work task;
-          queue_op_status st = work_queue.wait_pull(task);
-          if (st == queue_op_status::closed) {
-            return;
-          }
-          task();
+          try
+          {
+            queue_op_status st = work_queue.wait_pull(task);
+            if (st == queue_op_status::closed) {
+              return;
+            }
+            task();
+          }
+          catch (boost::thread_interrupted&)
+          {
+            return;
+          }
         }
       }
       catch (...)
       {
         std::terminate();
         return;
@@ -231,12 +238,13 @@
      * \b Effects: join all the threads.
      */
     void join()
     {
       for (unsigned i = 0; i < threads.size(); ++i)
       {
+        threads[i].interrupt();
         threads[i].join();
       }
     }
 
     /**
      * \b Effects: close the \c basic_thread_pool for submissions.
--- boost\thread\executors\scheduled_thread_pool.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\executors\scheduled_thread_pool.hpp	2017-08-28 20:49:56.000000000 -0700
@@ -29,12 +29,13 @@
       }
     }
 
     ~scheduled_thread_pool()
     {
       this->close();
+      _workers.interrupt_all();
       _workers.join_all();
     }
 
   private:
     typedef detail::scheduled_executor_base<> super;
   }; //end class
--- boost\thread\executors\scheduler.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\executors\scheduler.hpp	2017-08-28 20:49:56.000000000 -0700
@@ -228,12 +228,13 @@
         : super(),
           thr(&super::loop, this) {}
 
       ~scheduler()
       {
         this->close();
+        thr.interrupt();
         thr.join();
       }
       template <class Ex>
       scheduler_executor_wrapper<scheduler, Ex> on(Ex& ex)
       {
         return scheduler_executor_wrapper<scheduler, Ex>(*this, ex);
--- boost\thread\executors\scheduling_adaptor.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\executors\scheduling_adaptor.hpp	2017-08-28 20:49:56.000000000 -0700
@@ -28,12 +28,13 @@
         _exec(ex),
         _scheduler(&super::loop, this) {}
 
     ~scheduling_adpator()
     {
       this->close();
+      _scheduler.interrupt();
       _scheduler.join();
     }
 
     Executor& underlying_executor()
     {
         return _exec;
--- boost\thread\pthread\condition_variable_fwd.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\pthread\condition_variable_fwd.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -50,15 +50,15 @@
     }
   }
 
     class condition_variable
     {
     private:
-#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
+//#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
         pthread_mutex_t internal_mutex;
-#endif
+//#endif
         pthread_cond_t cond;
 
     public:
     //private: // used by boost::thread::try_join_until
 
         inline bool do_wait_until(
@@ -66,58 +66,56 @@
             struct timespec const &timeout);
 
         bool do_wait_for(
             unique_lock<mutex>& lock,
             struct timespec const &timeout)
         {
-#if ! defined BOOST_THREAD_USEFIXES_TIMESPEC
-            return do_wait_until(lock, boost::detail::timespec_plus(timeout, boost::detail::timespec_now()));
-#elif ! defined BOOST_THREAD_HAS_CONDATTR_SET_CLOCK_MONOTONIC
-            //using namespace chrono;
-            //nanoseconds ns = chrono::system_clock::now().time_since_epoch();
-
-            struct timespec ts = boost::detail::timespec_now_realtime();
-            //ts.tv_sec = static_cast<long>(chrono::duration_cast<chrono::seconds>(ns).count());
-            //ts.tv_nsec = static_cast<long>((ns - chrono::duration_cast<chrono::seconds>(ns)).count());
-            return do_wait_until(lock, boost::detail::timespec_plus(timeout, ts));
+#if defined BOOST_THREAD_HAS_CONDATTR_SET_CLOCK_MONOTONIC
+            return do_wait_until(lock, boost::detail::timespec_plus(timeout, boost::detail::timespec_now_monotonic()));
 #else
             // old behavior was fine for monotonic
             return do_wait_until(lock, boost::detail::timespec_plus(timeout, boost::detail::timespec_now_realtime()));
 #endif
         }
 
     public:
       BOOST_THREAD_NO_COPYABLE(condition_variable)
         condition_variable()
         {
             int res;
-#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
+//#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
+            // Even if it is not used, the internal_mutex exists (see
+            // above) and must be initialized (etc) in case some
+            // compilation units provide interruptions and others
+            // don't.
             res=pthread_mutex_init(&internal_mutex,NULL);
             if(res)
             {
                 boost::throw_exception(thread_resource_error(res, "boost::condition_variable::condition_variable() constructor failed in pthread_mutex_init"));
             }
-#endif
+//#endif
             res = detail::monotonic_pthread_cond_init(cond);
             if (res)
             {
-#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
+//#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
+                // ditto
                 BOOST_VERIFY(!pthread_mutex_destroy(&internal_mutex));
-#endif
+//#endif
                 boost::throw_exception(thread_resource_error(res, "boost::condition_variable::condition_variable() constructor failed in detail::monotonic_pthread_cond_init"));
             }
         }
         ~condition_variable()
         {
             int ret;
-#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
+//#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
+            // ditto
             do {
               ret = pthread_mutex_destroy(&internal_mutex);
             } while (ret == EINTR);
             BOOST_ASSERT(!ret);
-#endif
+//#endif
             do {
               ret = pthread_cond_destroy(&cond);
             } while (ret == EINTR);
             BOOST_ASSERT(!ret);
         }
 
--- boost\thread\pthread\shared_mutex.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\pthread\shared_mutex.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -17,13 +17,12 @@
 #endif
 #ifdef BOOST_THREAD_USES_CHRONO
 #include <boost/chrono/system_clocks.hpp>
 #include <boost/chrono/ceil.hpp>
 #endif
 #include <boost/thread/detail/delete.hpp>
-#include <boost/assert.hpp>
 
 #include <boost/config/abi_prefix.hpp>
 
 namespace boost
 {
     class shared_mutex
--- boost\thread\pthread\thread_data.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\pthread\thread_data.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -47,13 +47,17 @@
           int res = pthread_attr_destroy(&val_);
           BOOST_VERIFY(!res && "pthread_attr_destroy failed");
         }
         // stack
         void set_stack_size(std::size_t size) BOOST_NOEXCEPT {
           if (size==0) return;
+#ifdef BOOST_THREAD_USES_GETPAGESIZE
           std::size_t page_size = getpagesize();
+#else
+          std::size_t page_size = ::sysconf( _SC_PAGESIZE);
+#endif
 #ifdef PTHREAD_STACK_MIN
           if (size<PTHREAD_STACK_MIN) size=PTHREAD_STACK_MIN;
 #endif
           size = ((size+page_size-1)/page_size)*page_size;
           int res = pthread_attr_setstacksize(&val_, size);
           BOOST_VERIFY(!res && "pthread_attr_setstacksize failed");
@@ -237,16 +241,18 @@
 
     namespace this_thread
     {
         namespace hidden
         {
           void BOOST_THREAD_DECL sleep_for(const timespec& ts);
-          void BOOST_THREAD_DECL sleep_until(const timespec& ts);
+          void BOOST_THREAD_DECL sleep_until_realtime(const timespec& ts);
         }
 
 #ifdef BOOST_THREAD_USES_CHRONO
+        template <class Rep, class Period>
+        void sleep_for(const chrono::duration<Rep, Period>& d);
 #ifdef BOOST_THREAD_SLEEP_FOR_IS_STEADY
 
         inline
         void BOOST_SYMBOL_VISIBLE sleep_for(const chrono::nanoseconds& ns)
         {
             return boost::this_thread::hidden::sleep_for(boost::detail::to_timespec(ns));
@@ -256,16 +262,18 @@
 
         namespace no_interruption_point
         {
           namespace hidden
           {
             void BOOST_THREAD_DECL sleep_for(const timespec& ts);
-            void BOOST_THREAD_DECL sleep_until(const timespec& ts);
+            void BOOST_THREAD_DECL sleep_until_realtime(const timespec& ts);
           }
 
     #ifdef BOOST_THREAD_USES_CHRONO
+          template <class Rep, class Period>
+          void sleep_for(const chrono::duration<Rep, Period>& d);
     #ifdef BOOST_THREAD_SLEEP_FOR_IS_STEADY
 
           inline
           void BOOST_SYMBOL_VISIBLE sleep_for(const chrono::nanoseconds& ns)
           {
               return boost::this_thread::no_interruption_point::hidden::sleep_for(boost::detail::to_timespec(ns));
@@ -281,13 +289,13 @@
 #ifdef __DECXXX
         /// Workaround of DECCXX issue of incorrect template substitution
         template<>
 #endif
         inline void sleep(system_time const& abs_time)
         {
-          return boost::this_thread::hidden::sleep_until(boost::detail::to_timespec(abs_time));
+          return boost::this_thread::hidden::sleep_until_realtime(boost::detail::to_timespec(abs_time));
         }
 
         template<typename TimeDuration>
         inline BOOST_SYMBOL_VISIBLE void sleep(TimeDuration const& rel_time)
         {
             this_thread::sleep(get_system_time()+rel_time);
--- boost\thread\pthread\thread_heap_alloc.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\pthread\thread_heap_alloc.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -13,14 +13,19 @@
     {
         template<typename T>
         inline T* heap_new()
         {
             return new T();
         }
-
-#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES
+#if defined(BOOST_THREAD_PROVIDES_VARIADIC_THREAD) && ! defined (BOOST_NO_CXX11_RVALUE_REFERENCES)
+        template<typename T,typename... Args>
+        inline T* heap_new(Args&&... args)
+        {
+            return new T(static_cast<Args&&>(args)...);
+        }
+#elif ! defined BOOST_NO_CXX11_RVALUE_REFERENCES
         template<typename T,typename A1>
         inline T* heap_new(A1&& a1)
         {
             return new T(static_cast<A1&&>(a1));
         }
         template<typename T,typename A1,typename A2>
@@ -57,12 +62,37 @@
             return new T(a1,a2,a3);
         }
         template<typename T,typename A1,typename A2,typename A3,typename A4>
         inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4)
         {
             return new T(a1,a2,a3,a4);
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5)
+        {
+            return new T(a1,a2,a3,a4,a5);
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6)
+        {
+            return new T(a1,a2,a3,a4,a5,a6);
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7)
+        {
+            return new T(a1,a2,a3,a4,a5,a6,a7);
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8)
+        {
+            return new T(a1,a2,a3,a4,a5,a6,a7,a8);
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8,typename A9>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8,A9 a9)
+        {
+            return new T(a1,a2,a3,a4,a5,a6,a7,a8,a9);
         }
 
         template<typename T,typename A1>
         inline T* heap_new(A1 const& a1)
         {
             return heap_new_impl<T,A1 const&>(a1);
--- boost\thread\pthread\timespec.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\pthread\timespec.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -68,38 +68,27 @@
       return static_cast<boost::intmax_t>(ts.tv_sec) * 1000000000l + ts.tv_nsec;
     }
     inline bool timespec_ge_zero(timespec const& ts)
     {
       return (ts.tv_sec >= 0) || (ts.tv_nsec >= 0);
     }
-    inline timespec timespec_now()
+#if defined BOOST_THREAD_HAS_CONDATTR_SET_CLOCK_MONOTONIC
+
+    inline timespec timespec_now_monotonic()
     {
       timespec ts;
 
-#if defined CLOCK_MONOTONIC && defined BOOST_THREAD_USEFIXES_TIMESPEC
       if ( ::clock_gettime( CLOCK_MONOTONIC, &ts ) )
       {
         ts.tv_sec = 0;
         ts.tv_nsec = 0;
         BOOST_ASSERT(0 && "Boost::Thread - Internal Error");
       }
-#elif defined(BOOST_THREAD_TIMESPEC_MAC_API)
-      timeval tv;
-      ::gettimeofday(&tv, 0);
-      ts.tv_sec = tv.tv_sec;
-      ts.tv_nsec = tv.tv_usec * 1000;
-#else
-      if ( ::clock_gettime( CLOCK_REALTIME, &ts ) )
-      {
-        ts.tv_sec = 0;
-        ts.tv_nsec = 0;
-        BOOST_ASSERT(0 && "Boost::Thread - Internal Error");
-      }
+      return ts;
+    }
 #endif
-      return ts;
-    }
 
     inline timespec timespec_now_realtime()
     {
       timespec ts;
 
 #if defined(BOOST_THREAD_TIMESPEC_MAC_API)
--- boost\thread\win32\condition_variable.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\win32\condition_variable.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -208,23 +208,23 @@
 #else
                 entry_manager(entry_ptr const& entry_, boost::mutex& mutex_):
                     entry(entry_), internal_mutex(mutex_)
                 {}
 #endif
 
-                void remove_waiter()
+                void remove_waiter_and_reset()
                 {
                   if (entry) {
                     boost::lock_guard<boost::mutex> internal_lock(internal_mutex);
                     entry->remove_waiter();
                     entry.reset();
                   }
                 }
                 ~entry_manager() BOOST_NOEXCEPT_IF(false)
                 {
-                    remove_waiter();
+                  remove_waiter_and_reset();
                 }
 
                 list_entry* operator->()
                 {
                     return entry.get();
                 }
@@ -247,13 +247,13 @@
                       return false;
                   }
 
                   woken=entry->woken();
               }
               // do it here to avoid throwing on the destructor
-              entry->remove_waiter();
+              entry.remove_waiter_and_reset();
               locker.lock();
               return woken;
             }
 
             template<typename lock_type,typename predicate_type>
             bool do_wait(lock_type& m,timeout const& abs_time,predicate_type pred)
--- boost\thread\win32\thread_heap_alloc.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\win32\thread_heap_alloc.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -69,13 +69,30 @@
         }
 
         inline void free_raw_heap_memory(void* heap_memory)
         {
             BOOST_VERIFY(detail::win32::HeapFree(detail::win32::GetProcessHeap(),0,heap_memory)!=0);
         }
-
+#if defined(BOOST_THREAD_PROVIDES_VARIADIC_THREAD) && ! defined (BOOST_NO_CXX11_RVALUE_REFERENCES)
+        template<typename T,typename... Args>
+        inline T* heap_new(Args&&... args)
+        {
+          void* const heap_memory=allocate_raw_heap_memory(sizeof(T));
+          BOOST_TRY
+          {
+              T* const data=new (heap_memory) T(static_cast<Args&&>(args)...);
+              return data;
+          }
+          BOOST_CATCH(...)
+          {
+              free_raw_heap_memory(heap_memory);
+              BOOST_RETHROW
+          }
+          BOOST_CATCH_END
+        }
+#else
         template<typename T>
         inline T* heap_new()
         {
             void* const heap_memory=allocate_raw_heap_memory(sizeof(T));
             BOOST_TRY
             {
@@ -222,12 +239,92 @@
             {
                 free_raw_heap_memory(heap_memory);
                 BOOST_RETHROW
             }
             BOOST_CATCH_END
         }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5)
+        {
+            void* const heap_memory=allocate_raw_heap_memory(sizeof(T));
+            BOOST_TRY
+            {
+                T* const data=new (heap_memory) T(a1,a2,a3,a4,a5);
+                return data;
+            }
+            BOOST_CATCH(...)
+            {
+                free_raw_heap_memory(heap_memory);
+                BOOST_RETHROW
+            }
+            BOOST_CATCH_END
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6)
+        {
+            void* const heap_memory=allocate_raw_heap_memory(sizeof(T));
+            BOOST_TRY
+            {
+                T* const data=new (heap_memory) T(a1,a2,a3,a4,a5,a6);
+                return data;
+            }
+            BOOST_CATCH(...)
+            {
+                free_raw_heap_memory(heap_memory);
+                BOOST_RETHROW
+            }
+            BOOST_CATCH_END
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7)
+        {
+            void* const heap_memory=allocate_raw_heap_memory(sizeof(T));
+            BOOST_TRY
+            {
+                T* const data=new (heap_memory) T(a1,a2,a3,a4,a5,a6,a7);
+                return data;
+            }
+            BOOST_CATCH(...)
+            {
+                free_raw_heap_memory(heap_memory);
+                BOOST_RETHROW
+            }
+            BOOST_CATCH_END
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8)
+        {
+            void* const heap_memory=allocate_raw_heap_memory(sizeof(T));
+            BOOST_TRY
+            {
+                T* const data=new (heap_memory) T(a1,a2,a3,a4,a5,a6,a7,a8);
+                return data;
+            }
+            BOOST_CATCH(...)
+            {
+                free_raw_heap_memory(heap_memory);
+                BOOST_RETHROW
+            }
+            BOOST_CATCH_END
+        }
+        template<typename T,typename A1,typename A2,typename A3,typename A4,typename A5,typename A6,typename A7,typename A8,typename A9>
+        inline T* heap_new_impl(A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8,A9 a9)
+        {
+            void* const heap_memory=allocate_raw_heap_memory(sizeof(T));
+            BOOST_TRY
+            {
+                T* const data=new (heap_memory) T(a1,a2,a3,a4,a5,a6,a7,a8,a9);
+                return data;
+            }
+            BOOST_CATCH(...)
+            {
+                free_raw_heap_memory(heap_memory);
+                BOOST_RETHROW
+            }
+            BOOST_CATCH_END
+        }
 
 
         template<typename T,typename A1>
         inline T* heap_new(A1 const& a1)
         {
             return heap_new_impl<T,A1 const&>(a1);
@@ -382,12 +479,13 @@
         inline T* heap_new(A1& a1,A2& a2,A3& a3,A4& a4)
         {
             return heap_new_impl<T,A1&,A2&,A3&,A4&>(a1,a2,a3,a4);
         }
 
 #endif
+#endif
         template<typename T>
         inline void heap_delete(T* data)
         {
             data->~T();
             free_raw_heap_memory(data);
         }
--- boost\thread\future.hpp	2017-08-19 09:49:49.000000000 -0700
+++ boost\thread\future.hpp	2017-08-26 22:32:24.000000000 -0700
@@ -296,13 +296,13 @@
                         end=external_waiters.end();it!=end;++it)
                 {
                     (*it)->notify_all();
                 }
                 do_continuation(lock);
             }
-            void make_ready()
+            void notify_deferred()
             {
               boost::unique_lock<boost::mutex> lock(this->mutex);
               mark_finished_internal(lock);
             }
 
             void do_callback(boost::unique_lock<boost::mutex>& lock)
--- boost\type_erasure\detail\vtable.hpp	2017-08-19 09:49:50.000000000 -0700
+++ boost\type_erasure\detail\vtable.hpp	2017-08-21 15:49:42.000000000 -0700
@@ -27,13 +27,13 @@
 #include <boost/type_erasure/config.hpp>
 
 namespace boost {
 namespace type_erasure {
 namespace detail {
 
-#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_CXX11_CONSTEXPR) && !defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS)
+#if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && !defined(BOOST_NO_CXX11_CONSTEXPR) && !defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS) && (!defined(BOOST_MSVC) || BOOST_MSVC_FULL_VER > 190023026)
 
 template<class... T>
 struct stored_arg_pack;
 
 template<class It, class End, class... T>
 struct make_arg_pack_impl
--- boost\uuid\random_generator.hpp	2017-08-19 09:49:50.000000000 -0700
+++ boost\uuid\random_generator.hpp	2017-08-21 15:50:03.000000000 -0700
@@ -7,13 +7,13 @@
 
 #ifndef BOOST_UUID_RANDOM_GENERATOR_HPP
 #define BOOST_UUID_RANDOM_GENERATOR_HPP
 
 #include <boost/uuid/uuid.hpp>
 #include <boost/uuid/seed_rng.hpp>
-#include <boost/random/uniform_int.hpp>
+#include <boost/random/uniform_int_distribution.hpp>
 #include <boost/random/variate_generator.hpp>
 #include <boost/random/mersenne_twister.hpp>
 #include <boost/core/null_deleter.hpp>
 #include <boost/assert.hpp>
 #include <boost/shared_ptr.hpp>
 #include <limits>
@@ -22,56 +22,47 @@
 namespace uuids {
 
 // generate a random-based uuid
 template <typename UniformRandomNumberGenerator>
 class basic_random_generator {
 private:
-    typedef uniform_int<unsigned long> distribution_type;
+    typedef random::uniform_int_distribution<unsigned long> distribution_type;
     typedef variate_generator<UniformRandomNumberGenerator*, distribution_type> generator_type;
 
 public:
     typedef uuid result_type;
 
     // default constructor creates the random number generator
     basic_random_generator()
         : pURNG(new UniformRandomNumberGenerator)
         , generator
           ( pURNG.get()
-          , distribution_type
-            ( (std::numeric_limits<unsigned long>::min)()
-            , (std::numeric_limits<unsigned long>::max)()
-            )
+          , distribution_type()
           )
     {
         // seed the random number generator
         detail::seed(*pURNG);
     }
 
     // keep a reference to a random number generator
     // don't seed a given random number generator
     explicit basic_random_generator(UniformRandomNumberGenerator& gen)
         : pURNG(&gen, boost::null_deleter())
         , generator
           ( pURNG.get()
-          , distribution_type
-            ( (std::numeric_limits<unsigned long>::min)()
-            , (std::numeric_limits<unsigned long>::max)()
-            )
+          , distribution_type()
           )
     {}
 
     // keep a pointer to a random number generator
     // don't seed a given random number generator
     explicit basic_random_generator(UniformRandomNumberGenerator* pGen)
         : pURNG(pGen, boost::null_deleter())
         , generator
           ( pURNG.get()
-          , distribution_type
-            ( (std::numeric_limits<unsigned long>::min)()
-            , (std::numeric_limits<unsigned long>::max)()
-            )
+          , distribution_type()
           )
     {
         BOOST_ASSERT(pURNG);
     }
 
     uuid operator()()
--- boost\cstdint.hpp	2017-08-19 09:49:40.000000000 -0700
+++ boost\cstdint.hpp	2017-08-28 19:23:30.000000000 -0700
@@ -364,18 +364,15 @@
 // intptr_t/uintptr_t are defined separately because they are optional and not universally available
 #if defined(BOOST_WINDOWS) && !defined(_WIN32_WCE) && !defined(BOOST_HAS_STDINT_H)
 // Older MSVC don't have stdint.h and have intptr_t/uintptr_t defined in stddef.h
 #include <stddef.h>
 #endif
 
-// PGI seems to not support intptr_t/uintptr_t properly. BOOST_HAS_STDINT_H is not defined for this compiler by Boost.Config.
-#if !defined(__PGIC__)
-
 #if (defined(BOOST_WINDOWS) && !defined(_WIN32_WCE)) \
     || (defined(_XOPEN_UNIX) && (_XOPEN_UNIX+0 > 0) && !defined(__UCLIBC__)) \
-    || defined(__CYGWIN__) \
+    || defined(__CYGWIN__) || defined(__VXWORKS__) \
     || defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__) \
     || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || (defined(sun) && !defined(BOOST_HAS_STDINT_H)) || defined(INTPTR_MAX)
 
 namespace boost {
     using ::intptr_t;
     using ::uintptr_t;
@@ -387,16 +384,14 @@
 
 namespace boost {
     typedef __INTPTR_TYPE__ intptr_t;
     typedef __UINTPTR_TYPE__ uintptr_t;
 }
 #define BOOST_HAS_INTPTR_T
-
-#endif
 
-#endif // !defined(__PGIC__)
+#endif
 
 #endif // BOOST_CSTDINT_HPP
 
 
 /****************************************************
 
--- boost\hana.hpp	2017-08-19 09:49:42.000000000 -0700
+++ boost\hana.hpp	2017-08-21 18:32:53.000000000 -0700
@@ -111,12 +111,13 @@
 #include <boost/hana/front.hpp>
 #include <boost/hana/functional.hpp>
 #include <boost/hana/fuse.hpp>
 #include <boost/hana/greater.hpp>
 #include <boost/hana/greater_equal.hpp>
 #include <boost/hana/group.hpp>
+#include <boost/hana/hash.hpp>
 #include <boost/hana/index_if.hpp>
 #include <boost/hana/if.hpp>
 #include <boost/hana/insert.hpp>
 #include <boost/hana/insert_range.hpp>
 #include <boost/hana/integral_constant.hpp>
 #include <boost/hana/intersection.hpp>
--- boost\scope_exit.hpp	2017-08-19 09:49:48.000000000 -0700
+++ boost\scope_exit.hpp	2017-08-21 15:50:46.000000000 -0700
@@ -58,13 +58,13 @@
 #if BOOST_WORKAROUND(BOOST_SCOPE_EXIT_AUX_GCC, BOOST_TESTED_AT(413))
 #   define BOOST_SCOPE_EXIT_AUX_TPL_GCC_WORKAROUND_01 1
 #else
 #   define BOOST_SCOPE_EXIT_AUX_TPL_GCC_WORKAROUND_01 0
 #endif
 
-#if BOOST_MSVC
+#if BOOST_WORKAROUND(BOOST_MSVC, < 1800 )
 #   define BOOST_SCOPE_EXIT_AUX_TYPEOF_THIS_MSVC_WORKAROUND_01 1
 #else
 #   define BOOST_SCOPE_EXIT_AUX_TYPEOF_THIS_MSVC_WORKAROUND_01 0
 #endif
 
 // MSVC has problems expanding __LINE__ so use (the non standard) __COUNTER__.
--- boost\type_index.hpp	2017-08-19 09:49:50.000000000 -0700
+++ boost\type_index.hpp	2017-08-21 15:51:09.000000000 -0700
@@ -22,13 +22,13 @@
 
 #if defined(BOOST_TYPE_INDEX_USER_TYPEINDEX)
 #   include BOOST_TYPE_INDEX_USER_TYPEINDEX
 #   ifdef BOOST_HAS_PRAGMA_DETECT_MISMATCH
 #       pragma detect_mismatch( "boost__type_index__abi", "user defined type_index class is used: " BOOST_STRINGIZE(BOOST_TYPE_INDEX_USER_TYPEINDEX))
 #   endif
-#elif (!defined(BOOST_NO_RTTI) && !defined(BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY)) || defined(BOOST_MSVC)
+#elif (!defined(BOOST_NO_RTTI) && !defined(BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY)) || (defined(BOOST_MSVC) && BOOST_MSVC < 1910)
 #   include <boost/type_index/stl_type_index.hpp>
 #   if defined(BOOST_NO_RTTI) || defined(BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY)
 #       include <boost/type_index/detail/stl_register_class.hpp>
 #       ifdef BOOST_HAS_PRAGMA_DETECT_MISMATCH
 #           pragma detect_mismatch( "boost__type_index__abi", "RTTI is off - typeid() is used only for templates")
 #       endif
@@ -125,13 +125,13 @@
     /// user defined type_index class.
     ///
     /// \b See boost::typeindex::type_index_facade for a full description of type_index functions.
     typedef platform_specific type_index;
 #elif defined(BOOST_TYPE_INDEX_USER_TYPEINDEX)
     // Nothing to do
-#elif (!defined(BOOST_NO_RTTI) && !defined(BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY)) || defined(BOOST_MSVC)
+#elif (!defined(BOOST_NO_RTTI) && !defined(BOOST_TYPE_INDEX_FORCE_NO_RTTI_COMPATIBILITY)) || (defined(BOOST_MSVC) && BOOST_MSVC < 1910)
     typedef boost::typeindex::stl_type_index type_index;
 #else 
     typedef boost::typeindex::ctti_type_index type_index;
 #endif
 
 /// Depending on a compiler flags, optimal implementation of type_info will be used 
--- libs\config\checks\Jamfile.v2	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\checks\Jamfile.v2	2017-08-28 19:23:29.000000000 -0700
@@ -1,9 +1,9 @@
 #
 # *** DO NOT EDIT THIS FILE BY HAND ***
-# This file was automatically generated on Mon May 29 10:27:35 2017
+# This file was automatically generated on Sun Jul  9 16:30:35 2017
 #  by libs/config/tools/generate.cpp
 # Copyright John Maddock.
 # Use, modification and distribution are subject to the 
 # Boost Software License, Version 1.0. (See accompanying file 
 # LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
@@ -108,12 +108,13 @@
 obj cxx14_aggregate_nsdmi : test_case.cpp : <define>TEST_BOOST_NO_CXX14_AGGREGATE_NSDMI ;
 obj cxx14_return_type_deduction : test_case.cpp : <define>TEST_BOOST_NO_CXX14_RETURN_TYPE_DEDUCTION ;
 obj cxx14_std_exchange : test_case.cpp : <define>TEST_BOOST_NO_CXX14_STD_EXCHANGE ;
 obj cxx14_variable_templates : test_case.cpp : <define>TEST_BOOST_NO_CXX14_VARIABLE_TEMPLATES ;
 obj cxx17_fold_expressions : test_case.cpp : <define>TEST_BOOST_NO_CXX17_FOLD_EXPRESSIONS ;
 obj cxx17_inline_variables : test_case.cpp : <define>TEST_BOOST_NO_CXX17_INLINE_VARIABLES ;
+obj cxx17_iterator_traits : test_case.cpp : <define>TEST_BOOST_NO_CXX17_ITERATOR_TRAITS ;
 obj cxx17_std_apply : test_case.cpp : <define>TEST_BOOST_NO_CXX17_STD_APPLY ;
 obj cxx17_std_invoke : test_case.cpp : <define>TEST_BOOST_NO_CXX17_STD_INVOKE ;
 obj cxx17_structured_bindings : test_case.cpp : <define>TEST_BOOST_NO_CXX17_STRUCTURED_BINDINGS ;
 obj cxx98_binders : test_case.cpp : <define>TEST_BOOST_NO_CXX98_BINDERS ;
 obj cxx98_function_base : test_case.cpp : <define>TEST_BOOST_NO_CXX98_FUNCTION_BASE ;
 obj cxx98_random_shuffle : test_case.cpp : <define>TEST_BOOST_NO_CXX98_RANDOM_SHUFFLE ;
--- libs\config\checks\test_case.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\checks\test_case.cpp	2017-08-28 19:23:29.000000000 -0700
@@ -1,7 +1,7 @@
-//  This file was automatically generated on Mon May 29 10:27:35 2017
+//  This file was automatically generated on Sun Jul  9 16:30:35 2017
 //  by libs/config/tools/generate.cpp
 //  Copyright John Maddock 2002-4.
 //  Use, modification and distribution are subject to the 
 //  Boost Software License, Version 1.0. (See accompanying file 
 //  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
@@ -508,12 +508,17 @@
 #endif
 #ifdef TEST_BOOST_NO_CXX17_INLINE_VARIABLES
 #  ifdef BOOST_NO_CXX17_INLINE_VARIABLES
 #     error "Defect macro BOOST_NO_CXX17_INLINE_VARIABLES is defined."
 #  endif
 #endif
+#ifdef TEST_BOOST_NO_CXX17_ITERATOR_TRAITS
+#  ifdef BOOST_NO_CXX17_ITERATOR_TRAITS
+#     error "Defect macro BOOST_NO_CXX17_ITERATOR_TRAITS is defined."
+#  endif
+#endif
 #ifdef TEST_BOOST_NO_CXX17_STD_APPLY
 #  ifdef BOOST_NO_CXX17_STD_APPLY
 #     error "Defect macro BOOST_NO_CXX17_STD_APPLY is defined."
 #  endif
 #endif
 #ifdef TEST_BOOST_NO_CXX17_STD_INVOKE
--- libs\config\doc\config.qbk	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\doc\config.qbk	2017-08-28 19:23:29.000000000 -0700
@@ -19,13 +19,13 @@
 
 [/ Cited Boost resources ]
 
 [def __BOOST_REGRESSION_TEST_DRIVER__ [@../../../../tools/regression/doc/index.html boost regression test driver]]
 [def __BOOST_CONFIG_HEADER__ [@../../../../boost/config.hpp <boost/config.hpp>]]
 [def __BOOST_CONFIG_USER_HEADER__ [@../../../../boost/config/user.hpp <boost/config/user.hpp>]]
-[def __BOOST_CONFIG_SUFFIX_HEADER__ [@../../../../boost/config/user.hpp <boost/config/suffix.hpp>]]
+[def __BOOST_CONFIG_SUFFIX_HEADER__ [@../../../../boost/config/detail/suffix.hpp <boost/config/detail/suffix.hpp>]]
 [def __BOOST_CONFIG_DIR__ ['<boost-root>]`/boost/config/`]
 
 
 [/ Other web resources ]
 
 [def __STL_PORT__ [@http://stlport.sourceforge.net STLport]]
--- libs\config\doc\guidelines.qbk	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\doc\guidelines.qbk	2017-08-28 19:23:29.000000000 -0700
@@ -188,15 +188,15 @@
 
 __BOOST_CONFIG_SUFFIX_HEADER__ is always included so be careful about
 modifying this file as it breaks dependencies for everyone. This file should
 include only "boilerplate" configuration code, and generally should change
 only when new macros are added.
 
-[@../../../../boost/config/select_compiler_config.hpp <boost/config/select_compiler_config.hpp>],
-[@../../../../boost/config/select_platform_config.hpp <boost/config/select_platform_config.hpp>] and
-[@../../../../boost/config/select_stdlib_config.hpp <boost/config/select_stdlib_config.hpp>]
+[@../../../../boost/config/detail/select_compiler_config.hpp <boost/config/detail/select_compiler_config.hpp>],
+[@../../../../boost/config/detail/select_platform_config.hpp <boost/config/detail/select_platform_config.hpp>] and
+[@../../../../boost/config/detail/select_stdlib_config.hpp <boost/config/detail/select_stdlib_config.hpp>]
 are included by default and should change only if support for a new
 compiler/standard library/platform is added.
 
 The compiler/platform/standard library selection code is set up so that unknown
 platforms are ignored and assumed to be fully standards compliant - this gives
 unknown platforms a "sporting chance" of working "as is" even without running
--- libs\config\doc\macro_reference.qbk	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\doc\macro_reference.qbk	2017-08-28 19:23:29.000000000 -0700
@@ -942,12 +942,13 @@
 that are not yet supported by a particular compiler or library.
 
 [table
 [[Macro ][Description ]]
 [[`BOOST_NO_CXX17_STD_APPLY`][The compiler does not support `std::apply()`.]]
 [[`BOOST_NO_CXX17_STD_INVOKE`][The compiler does not support `std::invoke()`.]]
+[[`BOOST_NO_CXX17_ITERATOR_TRAITS`][The compiler does not support SFINAE-friendly `std::iterator_traits`.]]
 ]
 
 [endsect]
 
 [section Macros that describe features that have been removed from the standard.]
 
@@ -1259,12 +1260,24 @@
   if (BOOST_UNLIKELY(ptr == NULL))
     handle_error("ptr is NULL");
 ``
 ]]
 [[`BOOST_ATTRIBUTE_UNUSED`][Expands to `__attribute__((unused))` when this is available - 
 can be used to disable compiler warnings relating to unused types or variables.]]
+[[`BOOST_MAY_ALIAS`, `BOOST_NO_MAY_ALIAS`][
+`BOOST_MAY_ALIAS` expands to a type attribute that can be used to mark types that may
+alias other types. Pointers or references to such marked types can be used to access objects
+of other types. If the compiler supports this feature `BOOST_NO_MAY_ALIAS` is not defined.
+Otherwise `BOOST_MAY_ALIAS` expands to nothing and `BOOST_NO_MAY_ALIAS` is defined.
+
+Usage example:
+``
+  struct BOOST_MAY_ALIAS aliasing_struct;
+  typedef unsigned int BOOST_MAY_ALIAS aliasing_uint;
+``
+]]
 ]
 
 [endsect]
 
 [#config_info_macros]
 
--- libs\config\test\all\Jamfile.v2	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\test\all\Jamfile.v2	2017-08-28 19:23:30.000000000 -0700
@@ -1,10 +1,10 @@
 #
 # Regression test Jamfile for boost configuration setup.
 # *** DO NOT EDIT THIS FILE BY HAND ***
-# This file was automatically generated on Mon May 29 10:27:35 2017
+# This file was automatically generated on Sun Jul  9 16:30:35 2017
 #  by libs/config/tools/generate.cpp
 # Copyright John Maddock.
 # Use, modification and distribution are subject to the 
 # Boost Software License, Version 1.0. (See accompanying file 
 # LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 #
@@ -319,12 +319,15 @@
 test-suite "BOOST_NO_CXX17_FOLD_EXPRESSIONS" : 
 [ run ../no_cxx17_fold_expressions_pass.cpp ]
 [ compile-fail ../no_cxx17_fold_expressions_fail.cpp ] ;
 test-suite "BOOST_NO_CXX17_INLINE_VARIABLES" : 
 [ run ../no_cxx17_inline_variables_pass.cpp ]
 [ compile-fail ../no_cxx17_inline_variables_fail.cpp ] ;
+test-suite "BOOST_NO_CXX17_ITERATOR_TRAITS" : 
+[ run ../no_cxx17_iterator_traits_pass.cpp ]
+[ compile-fail ../no_cxx17_iterator_traits_fail.cpp ] ;
 test-suite "BOOST_NO_CXX17_STD_APPLY" : 
 [ run ../no_cxx17_std_apply_pass.cpp ]
 [ compile-fail ../no_cxx17_std_apply_fail.cpp ] ;
 test-suite "BOOST_NO_CXX17_STD_INVOKE" : 
 [ run ../no_cxx17_std_invoke_pass.cpp ]
 [ compile-fail ../no_cxx17_std_invoke_fail.cpp ] ;
--- libs\config\test\link\bc_gen.sh	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\test\link\bc_gen.sh	2017-08-28 19:23:32.000000000 -0700
@@ -1,7 +1,7 @@
-#! /bin/bash
+#! /usr/bin/env bash
 
 # copyright John Maddock 2005
 # Use, modification and distribution are subject to the 
 # Boost Software License, Version 1.0. (See accompanying file 
 # LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
--- libs\config\test\link\vc_gen.sh	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\test\link\vc_gen.sh	2017-08-28 19:23:32.000000000 -0700
@@ -1,7 +1,7 @@
-#! /bin/bash
+#! /usr/bin/env bash
 # copyright John Maddock 2005
 # Use, modification and distribution are subject to the 
 # Boost Software License, Version 1.0. (See accompanying file 
 # LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
 libname=""
--- 
+++ libs\config\test\boost_no_cxx17_iterator_traits.ipp	2017-08-28 19:23:31.000000000 -0700
@@ -0,0 +1,49 @@
+//  Copyright (c) Andrey Semashev 2017.
+//  Use, modification and distribution are subject to the
+//  Boost Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/config for most recent version.
+
+//  MACRO:         BOOST_NO_CXX17_ITERATOR_TRAITS
+//  TITLE:         C++17 std::iterator_traits
+//  DESCRIPTION:   The compiler does not support SFINAE-friendly std::iterator_traits defined in C++17.
+
+#include <iterator>
+
+namespace boost_no_cxx17_iterator_traits {
+
+struct iterator :
+    public std::iterator< std::random_access_iterator_tag, char >
+{
+};
+
+struct non_iterator {};
+
+template< typename T >
+struct void_type { typedef void type; };
+
+template< typename Traits, typename Void = void >
+struct has_iterator_category
+{
+    enum { value = false };
+};
+
+template< typename Traits >
+struct has_iterator_category< Traits, typename void_type< typename Traits::iterator_category >::type >
+{
+    enum { value = true };
+};
+
+int test()
+{
+    if (!has_iterator_category< std::iterator_traits< boost_no_cxx17_iterator_traits::iterator > >::value)
+        return 1;
+
+    if (has_iterator_category< std::iterator_traits< boost_no_cxx17_iterator_traits::non_iterator > >::value)
+        return 2;
+
+    return 0;
+}
+
+}
--- libs\config\test\config_info.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\test\config_info.cpp	2017-08-28 19:23:31.000000000 -0700
@@ -150,12 +150,13 @@
   PRINT_MACRO(_M_MRX000);
   PRINT_MACRO(_M_PPC);
   PRINT_MACRO(_MFC_VER);
   PRINT_MACRO(_MSC_EXTENSIONS);
   PRINT_MACRO(_MSC_VER);
   PRINT_MACRO(_MSC_FULL_VER);
+  PRINT_MACRO(_MSVC_LANG);
   PRINT_MACRO(_MT);
   PRINT_MACRO(_NATIVE_WCHAR_T_DEFINED);
   // GNUC options:
   PRINT_MACRO(__GNUC__);
   PRINT_MACRO(__GNUC_MINOR__);
   PRINT_MACRO(__GNUC_PATCHLEVEL__);
@@ -1070,12 +1071,13 @@
    PRINT_MACRO(BOOST_NO_CXX14_INITIALIZED_LAMBDA_CAPTURES);
    PRINT_MACRO(BOOST_NO_CXX14_RETURN_TYPE_DEDUCTION);
    PRINT_MACRO(BOOST_NO_CXX14_STD_EXCHANGE);
    PRINT_MACRO(BOOST_NO_CXX14_VARIABLE_TEMPLATES);
    PRINT_MACRO(BOOST_NO_CXX17_FOLD_EXPRESSIONS);
    PRINT_MACRO(BOOST_NO_CXX17_INLINE_VARIABLES);
+   PRINT_MACRO(BOOST_NO_CXX17_ITERATOR_TRAITS);
    PRINT_MACRO(BOOST_NO_CXX17_STD_APPLY);
    PRINT_MACRO(BOOST_NO_CXX17_STD_INVOKE);
    PRINT_MACRO(BOOST_NO_CXX17_STRUCTURED_BINDINGS);
    PRINT_MACRO(BOOST_NO_CXX98_BINDERS);
    PRINT_MACRO(BOOST_NO_CXX98_FUNCTION_BASE);
    PRINT_MACRO(BOOST_NO_CXX98_RANDOM_SHUFFLE);
@@ -1136,12 +1138,13 @@
    PRINT_MACRO(BOOST_NO_TYPENAME_WITH_CTOR);
    PRINT_MACRO(BOOST_NO_UNREACHABLE_RETURN_DETECTION);
    PRINT_MACRO(BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE);
    PRINT_MACRO(BOOST_NO_USING_TEMPLATE);
    PRINT_MACRO(BOOST_NO_VOID_RETURNS);
 
+
    // END GENERATED BLOCK
 
    PRINT_MACRO(BOOST_INTEL);
    PRINT_MACRO(BOOST_MSVC);
    PRINT_MACRO(BOOST_STD_EXTENSION_NAMESPACE);
    PRINT_MACRO(BOOST_UNREACHABLE_RETURN(0));
@@ -1149,12 +1152,14 @@
    PRINT_MACRO(BOOST_CONSTEXPR_OR_CONST);
    PRINT_MACRO(BOOST_STATIC_CONSTEXPR);
    PRINT_MACRO(BOOST_NOEXCEPT);
    PRINT_MACRO(BOOST_FORCEINLINE);
    PRINT_MACRO(BOOST_NOINLINE);
    PRINT_MACRO(BOOST_FALLTHROUGH);
+   PRINT_MACRO(BOOST_MAY_ALIAS);
+   PRINT_MACRO(BOOST_NO_MAY_ALIAS);
 }
 
 void print_separator()
 {
    std::cout <<
 "\n\n*********************************************************************\n\n";
--- libs\config\test\config_test.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\test\config_test.cpp	2017-08-28 19:23:31.000000000 -0700
@@ -1,7 +1,7 @@
-//  This file was automatically generated on Mon May 29 10:27:35 2017
+//  This file was automatically generated on Sun Jul  9 16:30:35 2017
 //  by libs/config/tools/generate.cpp
 //  Copyright John Maddock 2002-4.
 //  Use, modification and distribution are subject to the 
 //  Boost Software License, Version 1.0. (See accompanying file 
 //  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
@@ -339,12 +339,17 @@
 #endif
 #ifndef BOOST_NO_CXX17_INLINE_VARIABLES
 #include "boost_no_cxx17_inline_variables.ipp"
 #else
 namespace boost_no_cxx17_inline_variables = empty_boost;
 #endif
+#ifndef BOOST_NO_CXX17_ITERATOR_TRAITS
+#include "boost_no_cxx17_iterator_traits.ipp"
+#else
+namespace boost_no_cxx17_iterator_traits = empty_boost;
+#endif
 #ifndef BOOST_NO_CXX17_STD_APPLY
 #include "boost_no_cxx17_std_apply.ipp"
 #else
 namespace boost_no_cxx17_std_apply = empty_boost;
 #endif
 #ifndef BOOST_NO_CXX17_STD_INVOKE
@@ -1473,12 +1478,17 @@
    }
    if(0 != boost_no_cxx17_inline_variables::test())
    {
       std::cerr << "Failed test for BOOST_NO_CXX17_INLINE_VARIABLES at: " << __FILE__ << ":" << __LINE__ << std::endl;
       ++error_count;
    }
+   if(0 != boost_no_cxx17_iterator_traits::test())
+   {
+      std::cerr << "Failed test for BOOST_NO_CXX17_ITERATOR_TRAITS at: " << __FILE__ << ":" << __LINE__ << std::endl;
+      ++error_count;
+   }
    if(0 != boost_no_cxx17_std_apply::test())
    {
       std::cerr << "Failed test for BOOST_NO_CXX17_STD_APPLY at: " << __FILE__ << ":" << __LINE__ << std::endl;
       ++error_count;
    }
    if(0 != boost_no_cxx17_std_invoke::test())
--- libs\config\test\helper_macro_test.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\config\test\helper_macro_test.cpp	2017-08-28 19:23:32.000000000 -0700
@@ -31,12 +31,15 @@
 
 BOOST_NORETURN void always_throw()
 {
    throw 0;
 }
 
+struct BOOST_MAY_ALIAS aliasing_struct {};
+typedef unsigned int BOOST_MAY_ALIAS aliasing_uint;
+
 
 #define test_fallthrough(x) foobar(x)
 
 
 int main()
 {
--- 
+++ libs\config\test\no_cxx17_iterator_traits_fail.cpp	2017-08-28 19:23:33.000000000 -0700
@@ -0,0 +1,37 @@
+//  This file was automatically generated on Sun Jul  9 15:26:23 2017
+//  by libs/config/tools/generate.cpp
+//  Copyright John Maddock 2002-4.
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/config for the most recent version.//
+//  Revision $Id$
+//
+
+
+// Test file for macro BOOST_NO_CXX17_ITERATOR_TRAITS
+// This file should not compile, if it does then
+// BOOST_NO_CXX17_ITERATOR_TRAITS should not be defined.
+// See file boost_no_cxx17_iterator_traits.ipp for details
+
+// Must not have BOOST_ASSERT_CONFIG set; it defeats
+// the objective of this file:
+#ifdef BOOST_ASSERT_CONFIG
+#  undef BOOST_ASSERT_CONFIG
+#endif
+
+#include <boost/config.hpp>
+#include "test.hpp"
+
+#ifdef BOOST_NO_CXX17_ITERATOR_TRAITS
+#include "boost_no_cxx17_iterator_traits.ipp"
+#else
+#error "this file should not compile"
+#endif
+
+int main( int, char *[] )
+{
+   return boost_no_cxx17_iterator_traits::test();
+}
+
--- 
+++ libs\config\test\no_cxx17_iterator_traits_pass.cpp	2017-08-28 19:23:33.000000000 -0700
@@ -0,0 +1,37 @@
+//  This file was automatically generated on Sun Jul  9 15:26:23 2017
+//  by libs/config/tools/generate.cpp
+//  Copyright John Maddock 2002-4.
+//  Use, modification and distribution are subject to the 
+//  Boost Software License, Version 1.0. (See accompanying file 
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+//  See http://www.boost.org/libs/config for the most recent version.//
+//  Revision $Id$
+//
+
+
+// Test file for macro BOOST_NO_CXX17_ITERATOR_TRAITS
+// This file should compile, if it does not then
+// BOOST_NO_CXX17_ITERATOR_TRAITS should be defined.
+// See file boost_no_cxx17_iterator_traits.ipp for details
+
+// Must not have BOOST_ASSERT_CONFIG set; it defeats
+// the objective of this file:
+#ifdef BOOST_ASSERT_CONFIG
+#  undef BOOST_ASSERT_CONFIG
+#endif
+
+#include <boost/config.hpp>
+#include "test.hpp"
+
+#ifndef BOOST_NO_CXX17_ITERATOR_TRAITS
+#include "boost_no_cxx17_iterator_traits.ipp"
+#else
+namespace boost_no_cxx17_iterator_traits = empty_boost;
+#endif
+
+int main( int, char *[] )
+{
+   return boost_no_cxx17_iterator_traits::test();
+}
+
--- libs\context\doc\callcc.qbk	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\doc\callcc.qbk	2017-08-25 01:17:43.000000000 -0700
@@ -173,12 +173,13 @@
     c=c.resume();
     std::cout << "f1: returned second time: " << data << std::endl;
     data+=1;
     c=c.resume_with([&data](ctx::continuation && c){
                         std::cout << "f2: entered: " << data << std::endl;
                         data=-1;
+                        return std::move( c);
                     });
     std::cout << "f1: returned third time" << std::endl;
 
     output:
         f1: entered first time: 0
         f1: returned first time: 1
@@ -218,12 +219,13 @@
         }
         return std::move(c);
     });
     c = c.resume_with(
            [](ctx::continuation && c){
                throw my_exception(std::move(c),"abc");
+               return std::move( c);
            });
 
     output:
         entered
         my_exception: abc
 
@@ -524,17 +526,17 @@
 
         template<typename Fn>
         continuation resume_with(Fn && fn);
 
 [variablelist
 [[Effects:] [Captures current continuation and resumes `*this`.
-The function `resume_with`, is used to execute function `fn` in continuation
+The function `resume_with`, is used to execute function `fn` in the execution context of
 `*this` (e.g. the stack frame of `fn` is allocated on stack of `*this`).]]
 [[Returns:] [The continuation representing the continuation that has been
 suspended.]]
-[[Note:] [Function `fn` needs to return void.]]
+[[Note:] [Function `fn` needs to return `continuation`.]]
 [[Note:] [The returned continuation indicates if the suspended continuation has
 terminated (return from context-function) via `bool operator()`.]]
 ]
 
 [operator_heading cc..operator_bool..operator bool]
 
--- libs\context\example\ontop.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\example\ontop.cpp	2017-08-25 01:18:30.000000000 -0700
@@ -29,11 +29,12 @@
     c = c.resume();
     std::cout << "f1: returned second time: " << data << std::endl;
     data += 1;
     c = c.resume_with( [&data](ctx::continuation && c){
                             std::cout << "f2: entered: " << data << std::endl;
                             data = -1;
+                            return std::move( c);
                         });
     std::cout << "f1: returned third time" << std::endl;
     std::cout << "main: done" << std::endl;
     return EXIT_SUCCESS;
 }
--- libs\context\example\ontop_void.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\example\ontop_void.cpp	2017-08-25 01:19:16.000000000 -0700
@@ -18,14 +18,15 @@
     std::cout << "f1: entered second time" << std::endl;
     c = c.resume();
     std::cout << "f1: entered third time" << std::endl;
     return std::move( c);
 }
 
-void f2( ctx::continuation && c) {
+ctx::continuation f2( ctx::continuation && c) {
     std::cout << "f2: entered" << std::endl;
+    return std::move( c);
 }
 
 int main() {
     ctx::continuation c = ctx::callcc( f1);
     std::cout << "f1: returned first time" << std::endl;
     c = c.resume();
--- libs\context\example\throw.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\example\throw.cpp	2017-08-25 01:19:36.000000000 -0700
@@ -35,12 +35,13 @@
         }
         return std::move( c);
     });
     c = c.resume_with(
            [](ctx::continuation && c){
                throw my_exception(std::move( c), "abc");
+               return std::move( c);
            });
 
     std::cout << "main: done" << std::endl;
 
     return EXIT_SUCCESS;
 }
--- libs\context\src\asm\jump_i386_sysv_macho_gas.S	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\src\asm\jump_i386_sysv_macho_gas.S	2017-08-28 20:16:31.000000000 -0700
@@ -9,20 +9,20 @@
  *                                                                                      *
  *  ----------------------------------------------------------------------------------  *
  *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
  *  ----------------------------------------------------------------------------------  *
  *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
  *  ----------------------------------------------------------------------------------  *
- *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |  hidden |  *
+ *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |    to   |  *
  *  ----------------------------------------------------------------------------------  *
  *  ----------------------------------------------------------------------------------  *
  *  |    8    |    9    |    10   |    11   |    12    |    13   |    14   |    15   |  *
  *  ----------------------------------------------------------------------------------  *
- *  |   0x20  |   0x24  |                                                            |  *
+ *  |   0x20  |                                                                      |  *
  *  ----------------------------------------------------------------------------------  *
- *  |    to   |   data  |                                                            |  *
+ *  |   data  |                                                                      |  *
  *  ----------------------------------------------------------------------------------  *
  *                                                                                      *
  ****************************************************************************************/
 
 .text
 .globl _jump_fcontext
@@ -41,25 +41,23 @@
     movl  %ebp, 0x14(%esp)  /* save EBP */
 
     /* store ESP (pointing to context-data) in ECX */
     movl  %esp, %ecx
 
     /* first arg of jump_fcontext() == fcontext to jump to */
-    movl  0x20(%esp), %eax
+    movl  0x1c(%esp), %eax
 
     /* second arg of jump_fcontext() == data to be transferred */
-    movl  0x24(%esp), %edx
+    movl  0x20(%esp), %edx
 
     /* restore ESP (pointing to context-data) from EAX */
     movl  %eax, %esp
 
-    /* address of returned transport_t */
-    movl 0x1c(%esp), %eax
     /* return parent fcontext_t */
-    movl  %ecx, (%eax)
-    /* return data */
+    movl  %ecx, %eax
+    /* returned data is stored in EDX */
     movl %edx, 0x4(%eax)
 
     movl  0x18(%esp), %ecx  /* restore EIP */
 
 #if !defined(BOOST_USE_TSX)
     ldmxcsr  (%esp)     /* restore MMX control- and status-word */
@@ -68,10 +66,10 @@
 
     movl  0x8(%esp), %edi  /* restore EDI */
     movl  0xc(%esp), %esi  /* restore ESI */
     movl  0x10(%esp), %ebx  /* restore EBX */
     movl  0x14(%esp), %ebp  /* restore EBP */
 
-    leal  0x20(%esp), %esp  /* prepare stack */
+    leal  0x1c(%esp), %esp  /* prepare stack */
 
     /* jump to context */
     jmp *%ecx
--- libs\context\src\asm\make_i386_sysv_macho_gas.S	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\src\asm\make_i386_sysv_macho_gas.S	2017-08-25 01:11:28.000000000 -0700
@@ -9,20 +9,20 @@
  *                                                                                      *
  *  ----------------------------------------------------------------------------------  *
  *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
  *  ----------------------------------------------------------------------------------  *
  *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
  *  ----------------------------------------------------------------------------------  *
- *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |  hidden |  *
+ *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |    to   |  *
  *  ----------------------------------------------------------------------------------  *
  *  ----------------------------------------------------------------------------------  *
  *  |    8    |    9    |    10   |    11   |    12    |    13   |    14   |    15   |  *
  *  ----------------------------------------------------------------------------------  *
- *  |   0x20  |   0x24  |                                                            |  *
+ *  |   0x20  |                                                                      |  *
  *  ----------------------------------------------------------------------------------  *
- *  |    to   |   data  |                                                            |  *
+ *  |   data  |                                                                      |  *
  *  ----------------------------------------------------------------------------------  *
  *                                                                                      *
  ****************************************************************************************/
 
 .text
 .globl _make_fcontext
@@ -36,28 +36,23 @@
     leal  -0x8(%eax), %eax
 
     /* shift address in EAX to lower 16 byte boundary */
     andl  $-16, %eax
 
     /* reserve space for context-data on context-stack */
-    leal  -0x28(%eax), %eax
+    leal  -0x2c(%eax), %eax
 
     /* third arg of make_fcontext() == address of context-function */
     /* stored in EBX */
     movl  0xc(%esp), %ecx
     movl  %ecx, 0x10(%eax)
 
     /* save MMX control- and status-word */
     stmxcsr (%eax)
     /* save x87 control-word */
     fnstcw  0x4(%eax)
-
-    /* return transport_t */
-    /* FCTX == EDI, DATA == ESI */
-    leal  0x8(%eax), %ecx
-    movl  %ecx, 0x1c(%eax)
 
     /* compute abs address of label trampoline */
     call  1f
     /* address of trampoline 1 */
 1:  popl  %ecx
     /* compute abs address of label trampoline */
@@ -77,19 +72,19 @@
     movl  %ecx, 0x14(%eax) 
 
     ret /* return pointer to context-data */
 
 trampoline:
     /* move transport_t for entering context-function */
-    movl  %edi, (%esp)
-    movl  %esi, 0x4(%esp)
+    movl  %eax, (%esp)
+    movl  %edx, 0x4(%esp)
     pushl %ebp
     /* jump to context-function */
     jmp *%ebx
 
 finish:
     /* exit code is zero */
     xorl  %eax, %eax
     movl  %eax, (%esp)
     /* exit application */
     call  __exit
     hlt
--- libs\context\src\asm\ontop_i386_sysv_macho_gas.S	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\src\asm\ontop_i386_sysv_macho_gas.S	2017-08-25 01:12:18.000000000 -0700
@@ -9,20 +9,20 @@
  *                                                                                      *
  *  ----------------------------------------------------------------------------------  *
  *  |    0    |    1    |    2    |    3    |    4     |    5    |    6    |    7    |  *
  *  ----------------------------------------------------------------------------------  *
  *  |   0x0   |   0x4   |   0x8   |   0xc   |   0x10   |   0x14  |   0x18  |   0x1c  |  *
  *  ----------------------------------------------------------------------------------  *
- *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |  hidden |  *
+ *  | fc_mxcsr|fc_x87_cw|   EDI   |   ESI   |   EBX    |   EBP   |   EIP   |    to   |  *
  *  ----------------------------------------------------------------------------------  *
  *  ----------------------------------------------------------------------------------  *
  *  |    8    |    9    |    10   |    11   |    12    |    13   |    14   |    15   |  *
  *  ----------------------------------------------------------------------------------  *
- *  |   0x20  |   0x24  |                                                            |  *
+ *  |   0x20  |                                                                      |  *
  *  ----------------------------------------------------------------------------------  *
- *  |    to   |   data  |                                                            |  *
+ *  |   data  |                                                                      |  *
  *  ----------------------------------------------------------------------------------  *
  *                                                                                      *
  ****************************************************************************************/
 
 .text
 .globl _ontop_fcontext
@@ -41,35 +41,32 @@
     movl  %ebp, 0x14(%esp)  /* save EBP */
 
     /* store ESP (pointing to context-data) in ECX */
     movl  %esp, %ecx
 
     /* first arg of ontop_fcontext() == fcontext to jump to */
-    movl  0x20(%esp), %eax
+    movl  0x1c(%esp), %eax
 
     /* pass parent fcontext_t */
-    movl  %ecx, 0x20(%eax)
+    movl  %ecx, 0x1c(%eax)
 
     /* second arg of ontop_fcontext() == data to be transferred */
-    movl  0x24(%esp), %ecx
+    movl  0x20(%esp), %ecx
 
     /* pass data */
-    movl %ecx, 0x24(%eax)
+    movl %ecx, 0x20(%eax)
 
     /* third arg of ontop_fcontext() == ontop-function */
-    movl  0x28(%esp), %ecx
+    movl  0x24(%esp), %ecx
 
     /* restore ESP (pointing to context-data) from EAX */
     movl  %eax, %esp
 
-    /* address of returned transport_t */
-    movl 0x1c(%esp), %eax
     /* return parent fcontext_t */
-    movl  %ecx, (%eax)
-    /* return data */
-    movl %edx, 0x4(%eax)
+    movl  %ecx, %eax
+    /* returned data is stored in EDX */
 
 #if !defined(BOOST_USE_TSX)
     ldmxcsr  (%esp)     /* restore MMX control- and status-word */
     fldcw    0x4(%esp)  /* restore x87 control-word */
 #endif
 
--- libs\context\test\test_callcc.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\context\test\test_callcc.cpp	2017-08-28 20:16:32.000000000 -0700
@@ -249,12 +249,13 @@
                     }
                     return std::move( c);
                 });
         c = c.resume_with(
                [&i](ctx::continuation && c){
                    i -= 10;
+                   return std::move( c);
                });
         BOOST_CHECK( c);
         BOOST_CHECK_EQUAL( i, 200);
     }
     {
         ctx::continuation c1;
@@ -263,12 +264,13 @@
                     BOOST_CHECK( ! c);
                     return std::move( c1);
                 });
         c = c.resume_with(
                [&c1](ctx::continuation && c){
                    c1 = std::move( c);
+                   return std::move( c);
                });
     }
 }
 
 void test_ontop_exception() {
     value1 = 0;
@@ -287,13 +289,14 @@
     });
     c = c.resume();
     BOOST_CHECK_EQUAL( 3, value1);
     const char * what = "hello world";
     c.resume_with(
        [what](ctx::continuation && c){
-           throw my_exception( std::move( c), what);
+            throw my_exception( std::move( c), what);
+            return std::move( c);
        });
     BOOST_CHECK_EQUAL( 3, value1);
     BOOST_CHECK_EQUAL( std::string( what), value2);
 }
 
 void test_termination() {
--- libs\date_time\test\gregorian\testdate.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\gregorian\testdate.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -283,16 +283,16 @@
 
   try{
     date d(neg_infin);
     tm d_tm = to_tm(d);
     check("Exception not thrown (special_value to_tm)", false);
     std::cout << d_tm.tm_sec << std::endl; //does nothing useful but stops compiler from complaining about unused d_tm
-  }catch(std::out_of_range& e){
+  }catch(std::out_of_range&){
     check("Caught expected exception (special_value to_tm)", true);
   }catch(...){
     check("Caught un-expected exception (special_value to_tm)", false);
   }
 
   return printTestStats();
 
 }
 
--- libs\date_time\test\gregorian\testdate_input_facet.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\gregorian\testdate_input_facet.cpp	2017-08-28 19:11:27.000000000 -0700
@@ -477,13 +477,13 @@
 
     // create a period_parser
     period_parser p_parser; // default will do
     // create date_generator_parser
     typedef boost::date_time::date_generator_parser<date,char> date_gen_parser;
     date_gen_parser dg_parser("Zuerst","Zweitens","Dritt","Viert",
-                              "Fünft","Letzt","Vor","Nach","Von");
+                              "F\xC3\xBCnft","Letzt","Vor","Nach","Von");
 
     // create the date_input_facet
     date_input_facet* de_facet =
       new date_input_facet("%B %d %Y",
                            d_parser,
                            sv_parser,
--- libs\date_time\test\gregorian\testgreg_durations.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\gregorian\testgreg_durations.cpp	2017-08-28 19:11:27.000000000 -0700
@@ -153,12 +153,30 @@
       date d(2000, Feb, 29);
       check("date - years", date(1994, Feb, 28) == d - years(6));
       d -= years(6);
       check("date -= years", date(1994, Feb, 28) == d);
     }
 
+    try {
+      date d1(1400, 6, 1);
+      const date d2 = d1 + years(8600);
+      check("date + many years != overflow", d2 == date(10000, 6, 1));
+    }
+    catch (...) {
+      check("date + many years != overflow", false);
+    }
+
+    try {
+      date d1(10000, 6, 1);
+      const date d2 = d1 - years(8600);
+      check("date - many years != overflow", d2 == date(1400, 6, 1));
+    }
+    catch (...) {
+      check("date - many years != overflow", false);
+    }
+
   }
   
   /*** weeks ***/
   // shouldn't need many tests, it is nothing more than a date_duration
   // so all date_duration tests should prove this class
   {
--- libs\date_time\test\gregorian\testparse_date.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\gregorian\testparse_date.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -86,13 +86,13 @@
       date d(not_a_date_time);
       try {
         d = date_from_iso_string(s);
         check("Expected exception not thrown: from ISO string (bad_day_of_month)", false);
         std::cout << date_from_iso_string(s) << std::endl;
       }
-      catch(bad_day_of_month& e) {
+      catch(bad_day_of_month&) {
         check("Caught expected exception: bad_day_of_month ", true);
       }
       catch(...) {
         check("Caught unexpected exception", false);
       }
 /* not currently passing due to a bug in boost::offset_separator (reported 2005-Aug-02)
@@ -342,12 +342,13 @@
 
   try {
     using namespace boost::gregorian;
     std::string ud(""); //empty string error sf bug# 1155556
     date d1(from_simple_string(ud));
     check("empty string",  false); //should never reach this piont
+    (void)d1;
   }
   catch(std::exception& e) {
     check(std::string("empty string parse (exception expected): ") + e.what(),  true);
   }
   
 
--- libs\date_time\test\local_time\testlocal_time.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\local_time\testlocal_time.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -287,13 +287,13 @@
       try{
         local_date_time ldt(not_a_date_time);
         tm ldt_tm = to_tm(ldt);
         check("Exception not thrown (special_value to_tm)", false);
 	//does nothing useful but stops compiler from complaining about unused ldt_tm
 	std::cout << ldt_tm.tm_sec << std::endl; 
-      }catch(std::out_of_range& e){
+      }catch(std::out_of_range&){
         check("Caught expected exception (special_value to_tm)", true);
       }catch(...){
         check("Caught un-expected exception (special_value to_tm)", false);
       }
       // check that all are equal to sv_pt
       check("local == utc", az_lt == utc_lt); 
--- libs\date_time\test\local_time\testlocal_time_facet.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\local_time\testlocal_time_facet.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -46,13 +46,13 @@
   tz_database time_zones;
 
   try {
     // first try to find the data file from the test dir
     time_zones.load_from_file("../data/date_time_zonespec.csv");
   }
-  catch(const data_not_accessible& e) {
+  catch(const data_not_accessible&) {
     // couldn't find the data file so assume we are being run from 
     // boost_root/status and try again
     try {
       time_zones.load_from_file("../libs/date_time/data/date_time_zonespec.csv");
     }
     catch(const data_not_accessible&) {
--- libs\date_time\test\local_time\testposix_time_zone.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\local_time\testposix_time_zone.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -197,13 +197,13 @@
     // Mar-01 & Oct-31 Non-leap year, count begins at 0
     spec = "FST+3FDT,59,304"; // "304" is not a mistake here, see posix_time_zone docs
     posix_time_zone fl_2(spec);
     try{
       check("Non-Julian First/last of month", fl_2.dst_local_start_time(2003) ==
           ptime(date(2003,Mar,1),hours(2)));
-    }catch(std::exception& e){
+    }catch(std::exception&){
       check("Expected exception caught for Non-Julian day of 59, in non-leap year (Feb-29)", true);
     }
     check("Non-Julian First/last of month", fl_2.dst_local_end_time(2003) == 
         ptime(date(2003,Oct,31),hours(2)));
     
     // Mar-01 & Oct-31 leap year, count begins at 0
--- libs\date_time\test\local_time\testtz_database.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\local_time\testtz_database.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -29,13 +29,13 @@
    * have all had full names added */
  
   // run the exception tests first
   try{
     tz_database tz_db;
     tz_db.load_from_file("missing_file.csv"); // file does not exist
-  }catch(data_not_accessible& e){
+  }catch(data_not_accessible&){
     check("Caught Missing data file exception", true);
   }catch(...){
     check("Caught first unexpected exception", false);
   }
   check("Caught Bad field count exception", run_bad_field_count_test());
 
@@ -49,13 +49,13 @@
    * attempting to open it again but from a different location. If that 
    * also fails, we abort the test. */
   tz_database tz_db;
   try {
     // first try to find the data file from the test dir
     tz_db.load_from_file("../data/date_time_zonespec.csv");
-  }catch(data_not_accessible& e) {
+  }catch(data_not_accessible&) {
     // couldn't find the data file so assume we are being run from 
     // boost_root/status and try again
     tz_db.load_from_file("../libs/date_time/data/date_time_zonespec.csv");
   }catch(...) {
     check("Cannot locate data file - aborting.", false);
     return printTestStats();
@@ -118,21 +118,21 @@
 {
   using namespace boost::local_time;
   bool caught_bfc = false;
   tz_database other_db;
   try{
     other_db.load_from_file("local_time/poorly_formed_zonespec.csv");
-  }catch(bad_field_count& be){
+  }catch(bad_field_count&){
     caught_bfc = true;
   }catch(...) {
     // do nothing (file not found)
   }
   try{
     other_db.load_from_file("../libs/date_time/test/local_time/poorly_formed_zonespec.csv");
-  }catch(bad_field_count& be){
+  }catch(bad_field_count&){
     caught_bfc = true;
   }catch(...) {
     // do nothing (file not found)
   }
   return caught_bfc;
 }
 
--- libs\date_time\test\local_time\testwposix_time_zone.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\local_time\testwposix_time_zone.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -200,13 +200,13 @@
     // Mar-01 & Oct-31 Non-leap year, count begins at 0
     spec = L"FST+3FDT,59,304"; // "304" is not a mistake here, see posix_time_zone docs
     w_posix_time_zone fl_2(spec);
     try{
       check("Non-Julian First/last of month", fl_2.dst_local_start_time(2003) ==
           ptime(date(2003,Mar,1),hours(2)));
-    }catch(std::exception& e){
+    }catch(std::exception&){
       check("Expected exception caught for Non-Julian day of 59, in non-leap year (Feb-29)", true);
     }
     check("Non-Julian First/last of month", fl_2.dst_local_end_time(2003) == 
         ptime(date(2003,Oct,31),hours(2)));
     
     // Mar-01 & Oct-31 leap year, count begins at 0
--- libs\date_time\test\posix_time\testfiletime_functions.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\posix_time\testfiletime_functions.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -19,13 +19,13 @@
 #if defined(BOOST_HAS_FTIME) // skip tests if no FILETIME
 
   using namespace boost::posix_time;
 
   // adjustor is used to truncate ptime's fractional seconds for 
   // comparison with SYSTEMTIME's milliseconds
-  const int adjustor = time_duration::ticks_per_second() / 1000;
+  const time_duration::tick_type adjustor = time_duration::ticks_per_second() / 1000;
   
   for(int i = 0; i < 5; ++i){
 
     FILETIME ft;
     SYSTEMTIME st;
     GetSystemTime(&st);
--- libs\date_time\test\posix_time\testtime.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\posix_time\testtime.cpp	2017-08-28 19:15:39.000000000 -0700
@@ -306,13 +306,13 @@
   try{
     ptime pt(pos_infin);
     tm pt_tm = to_tm(pt);
     check("Exception not thrown (special_value to_tm)", false);
     //following code does nothing useful but stops compiler from complaining about unused pt_tm
     std::cout << pt_tm.tm_sec << std::endl;
-  }catch(std::out_of_range& e){
+  }catch(std::out_of_range&){
     check("Caught expected exception (special_value to_tm)", true);
   }catch(...){
     check("Caught un-expected exception (special_value to_tm)", false);
   }
   try{
     // exception is only thrown from gregorian::to_tm. Needed to
@@ -320,17 +320,17 @@
     ptime pt(date(2002,Oct,31), hours(1));
     pt += time_duration(pos_infin);
     tm pt_tm = to_tm(pt);
     check("Exception not thrown (special_value to_tm)", false);
     //following code does nothing useful but stops compiler from complaining about unused pt_tm
     std::cout << pt_tm.tm_sec << std::endl;
-  }catch(std::out_of_range& e){
+  }catch(std::out_of_range&){
     check("Caught expected exception (special_value to_tm)", true);
   }catch(...){
     check("Caught un-expected exception (special_value to_tm)", false);
   }
 
   
   return printTestStats();
   
 }
 
--- libs\date_time\test\testfrmwk.hpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\date_time\test\testfrmwk.hpp	2017-08-28 19:11:28.000000000 -0700
@@ -53,22 +53,46 @@
     stat.addFailingTest();
     std::cout << "FAIL :: " << testname << " " <<  std::endl;
     return false;
   }
 }
 
+// In the comparisons below, it is possible that T and U are signed and unsigned integer types, which generates warnings in some compilers.
+#if defined(BOOST_MSVC)
+# pragma warning(push)
+# pragma warning(disable: 4389)
+#elif defined(BOOST_CLANG) && defined(__has_warning)
+# if __has_warning("-Wsign-compare")
+#  pragma clang diagnostic push
+#  pragma clang diagnostic ignored "-Wsign-compare"
+# endif
+#elif defined(BOOST_GCC) && (BOOST_GCC+0) >= 40600
+# pragma GCC diagnostic push
+# pragma GCC diagnostic ignored "-Wsign-compare"
+#endif
+
 template< typename T, typename U >
 inline bool check_equal(const std::string& testname, T const& left, U const& right)
 {
   bool res = check(testname, left == right);
   if (!res)
   {
     std::cout << "        left = " << left << ", right = " << right << std::endl;
   }
   return res;
 }
+
+#if defined(BOOST_MSVC)
+# pragma warning(pop)
+#elif defined(BOOST_CLANG) && defined(__has_warning)
+# if __has_warning("-Wsign-compare")
+#  pragma clang diagnostic pop
+# endif
+#elif defined(BOOST_GCC) && (BOOST_GCC+0) >= 40600
+# pragma GCC diagnostic pop
+#endif
 
 #ifndef BOOST_NO_STD_WSTRING
 inline bool check_equal(const std::string& testname, std::wstring const& left, std::wstring const& right)
 {
   bool res = check(testname, left == right);
   if (!res)
--- libs\fiber\src\context.cpp	2017-08-19 09:49:40.000000000 -0700
+++ libs\fiber\src\context.cpp	2017-08-25 00:59:05.000000000 -0700
@@ -142,12 +142,13 @@
     // context_initializer::active_ will point to `this`
     // prev will point to previous active context
     std::swap( context_initializer::active_, prev);
     // pass pointer to the context that resumes `this`
     c_.resume_with([prev](boost::context::continuation && c){
                 prev->c_ = std::move( c);
+                return boost::context::continuation{};
             });
 }
 
 void
 context::resume( detail::spinlock_lock & lk) noexcept {
     context * prev = this;
@@ -155,12 +156,13 @@
     // prev will point to previous active context
     std::swap( context_initializer::active_, prev);
     // pass pointer to the context that resumes `this`
     c_.resume_with([prev,&lk](boost::context::continuation && c){
                 prev->c_ = std::move( c);
                 lk.unlock();
+                return boost::context::continuation{};
             });
 }
 
 void
 context::resume( context * ready_ctx) noexcept {
     context * prev = this;
@@ -168,12 +170,13 @@
     // prev will point to previous active context
     std::swap( context_initializer::active_, prev);
     // pass pointer to the context that resumes `this`
     c_.resume_with([prev,ready_ctx](boost::context::continuation && c){
                 prev->c_ = std::move( c);
                 context::active()->schedule( ready_ctx);
+                return boost::context::continuation{};
             });
 }
 
 void
 context::suspend() noexcept {
     get_scheduler()->suspend();
@@ -215,12 +218,13 @@
     // context_initializer::active_ will point to `this`
     // prev will point to previous active context
     std::swap( context_initializer::active_, prev);
     // pass pointer to the context that resumes `this`
     return c_.resume_with([prev](boost::context::continuation && c){
                 prev->c_ = std::move( c);
+                return boost::context::continuation{};
             });
 }
 
 boost::context::continuation
 context::terminate() noexcept {
     // protect for concurrent access
--- libs\log\build\Jamfile.v2	2017-08-19 09:49:43.000000000 -0700
+++ libs\log\build\Jamfile.v2	2017-08-21 15:19:35.000000000 -0700
@@ -392,13 +392,13 @@
                 {
                     result = <cxxflags>"-xCORE-AVX2 -fabi-version=0" ;
                 }
             }
             else if <toolset>msvc in $(properties)
             {
-                result = <cxxflags>"/arch:AVX" ;
+                result = <cxxflags>"/arch:AVX2" ;
             }
         }
     }
 
 #    if ! <build>no in $(result)
 #    {
--- libs\log\config\x86-ext\Jamfile.jam	2017-08-19 09:49:43.000000000 -0700
+++ libs\log\config\x86-ext\Jamfile.jam	2017-08-21 15:20:28.000000000 -0700
@@ -17,18 +17,19 @@
     :
         <toolset>gcc:<cxxflags>"-msse -msse2 -msse3 -mssse3"
         <toolset>clang:<cxxflags>"-msse -msse2 -msse3 -mssse3"
         <toolset>intel-linux:<cxxflags>"-xSSSE3"
         <toolset>intel-darwin:<cxxflags>"-xSSSE3"
         <toolset>intel-win:<cxxflags>"/QxSSSE3"
+        <toolset>msvc,<address-model>32:<cxxflags>"/arch:SSE2"
     ;
 
 obj avx2 : avx2.cpp
     :
         <toolset>gcc:<cxxflags>"-mavx -mavx2 -fabi-version=0"
         <toolset>clang:<cxxflags>"-mavx -mavx2"
         <toolset>intel-linux:<cxxflags>"-xCORE-AVX2 -fabi-version=0"
         <toolset>intel-darwin:<cxxflags>"-xCORE-AVX2 -fabi-version=0"
         <toolset>intel-win:<cxxflags>"/arch:CORE-AVX2"
-        <toolset>msvc:<cxxflags>"/arch:AVX"
+        <toolset>msvc:<cxxflags>"/arch:AVX2"
     ;
 
--- libs\math\build\Jamfile.v2	2017-08-19 09:49:43.000000000 -0700
+++ libs\math\build\Jamfile.v2	2017-08-21 15:20:55.000000000 -0700
@@ -9,13 +9,13 @@
 project  
     : requirements 
       <toolset>intel-win:<cxxflags>-nologo 
       <toolset>intel-win:<linkflags>-nologo 
       #<toolset>intel-linux:<pch>off
       <toolset>intel-darwin:<pch>off
-      <toolset>msvc-7.1:<pch>off
+      <toolset>msvc:<pch>off
       <toolset>gcc,<target-os>windows:<pch>off
       #<toolset>gcc:<cxxflags>-fvisibility=hidden
       <toolset>intel-linux:<cxxflags>-fvisibility=hidden
       #<toolset>sun:<cxxflags>-xldscope=hidden
       [ check-target-builds ../config//has_gcc_visibility "gcc visibility" : <toolset>gcc:<cxxflags>-fvisibility=hidden : ]
     ;
--- libs\process\doc\concepts.qbk	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\doc\concepts.qbk	2017-08-26 23:03:08.000000000 -0700
@@ -47,13 +47,13 @@
 
 [endsect]
 
 
 [section:process Processes]
 
-A process is an independently executable entity, which is different from a thread, in that it has it's own resources. 
+A process is an independently executable entity, which is different from a thread, in that it has its own resources. 
 Those include memory and hardware resources.
 
 Every process is identified by a unique number[footnote it is unique as long as the process is active], called the process identification digit, `pid`. 
 
 [section:exit_code Exit code]
 A process will return an integer value indicating whether it was successful. On posix
--- libs\process\doc\extend.qbk	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\doc\extend.qbk	2017-08-26 23:03:08.000000000 -0700
@@ -100,17 +100,18 @@
 ```
 struct async_foo : __handler__, __require_io_service__ 
 {
     tempalte<typename Executor>
     void on_setup(Executor & exec)
     {
-        __io_service__ & ios = __get_io_service__(exec.seq); //gives us a reference and a compiler error if not present.
+        io_service & ios = __get_io_service__(exec.seq); //gives us a reference and a compiler error if not present.
         //do something with ios
     }
 };
 ```
+[caution All async_handlers use one signal(SIGCHLD) on posix, which is only guaranteed to work when all use the same `io_service`]
 
 [note Inheriting [globalref boost::process::extend::require_io_service require_io_service] is necessary, so [funcref boost::process::system system] provides one.]
 
 Additionally the handler can provide a function that is invoked when the child process exits. This is done through __async_handler__.
 
 [note [globalref boost::process::extend::async_handler async_handler] implies [globalref boost::process::extend::require_io_service require_io_service] .]
--- libs\process\doc\faq.qbk	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\doc\faq.qbk	2017-08-26 23:03:08.000000000 -0700
@@ -21,14 +21,14 @@
         os << elem;
     }
 }
  
 ```
 We switched the read and write operation up, so that's causing a dead-lock.
-This locks immediately. This is because `c++filt` expects input, before 
-outputting any data. The launching process on the other hand wait's for it's output.
+This locks immediately. This is because `c++filt` expects input, before
+outputting any data. The launching process on the other hand waits for its output.
 
 [endsect]
 
 [section:closep Why does the pipe not close?]
 
 Now for another example, which might look correct, let's consider you want
--- libs\process\doc\tutorial.qbk	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\doc\tutorial.qbk	2017-08-26 23:03:08.000000000 -0700
@@ -78,13 +78,13 @@
 So as a first step, we'll use the `exe-args` style.
 
 ```
 int result = bp::system("/usr/bin/g++", "main.cpp");
 ```
 
-With that sytax we still have "g++" hard-coded, so let's assume we get the string
+With that syntax we still have "g++" hard-coded, so let's assume we get the string
 from an external source as `boost::filesystem::path`, we can do this too.
 
 ```
 boost::filesystem::path p = "/usr/bin/g++"; //or get it from somewhere else.
 int result = bp::system(p, "main.cpp");
 ```
@@ -106,14 +106,14 @@
 
 Given that in our example used the [funcref boost::process::system system] function, 
 our program will wait until the child process is completed. This maybe unwanted, 
 especially since compiling can take a while. 
 
 In order to avoid that, boost.process provides several ways to launch a process.
-Besides the already mentioned [funcref boost::process::system system] function and it's 
-asynchronous version [funcref boost::process::async_system async_system], 
+Besides the already mentioned [funcref boost::process::system system] function and its
+asynchronous version [funcref boost::process::async_system async_system],
 we can also use the [funcref boost::process::spawn spawn] function or the
 [classref boost::process::child child] class.
 
 The [funcref boost::process::spawn spawn] function launches a process and 
 immediately detaches it, so no handle will be returned and the process will be ignored.
 This is not what we need for compiling, but maybe we want to entertain the user,
@@ -197,13 +197,13 @@
 [@http://en.cppreference.com/w/cpp/io/basic_iostream std::iostream] interface.
 
 ```
 std::vector<std::string> read_outline(std::string & file)
 {
     bp::ipstream is; //reading pipe-stream
-    bp::child c(bp::search_patk("nm"), file, bp::std_out > is);
+    bp::child c(bp::search_path("nm"), file, bp::std_out > is);
     
     std::vector<std::string> data;
     std::string line;
     
     while (c.child_running() && std::getline(is, line) && !line.empty())
         data.push_back(line);    
@@ -275,13 +275,13 @@
 but the compiler output will just be put into one large buffer.
 
 With [@http://www.boost.org/doc/libs/release/libs/asio/ boost.asio] this is what it looks like.
 
 ```
 io_service ios;
-std::vector<char> buf;
+std::vector<char> buf(4096);
 
 bp::async_pipe ap(ios);
 
 bp::child c(bp::search_path("g++"), "main.cpp", bp::std_out > ap);
 
 asio_async_read(ap, asio_buffer(buf), 
@@ -339,16 +339,16 @@
 if they do not modify the group membership. E.g. if you call `make` which 
 launches other processes and call terminate on it, 
 it will not terminate all the child processes of the child unless you use a group.
 
 The two main reasons to use groups are:
 
-# Being able two terminate child processes of the child process
+# Being able to terminate child processes of the child process
 # Grouping several processes into one, just so they can be terminated at once
 
-If we have program like `make`, which does launch it's own child processes, 
+If we have program like `make`, which does launch its own child processes, 
 a call of child_terminate might not suffice. I.e. if we have a makefile launching `gcc` 
 and use the following code, the `gcc` process will still run afterwards:
 
 ```
 bp::child c("make");
 if (!c.child_wait_for(std::chrono::seconds(10)) //give it 10 seconds
@@ -385,13 +385,13 @@
     
     g.group_wait();
 };
 ```
 
 In the example, it will wait for both processes at the end of the function unless 
-an exception occures. I.e. if an exception is thrown, the group will be terminated.
+an exception occurs. I.e. if an exception is thrown, the group will be terminated.
 
 
 Please see the [headerref boost/process/group.hpp reference] for more information.
 
 [endsect]
 [section:env Environment]
@@ -402,13 +402,13 @@
 ```
 //get a handle to the current environment
 auto env = boost::this_process::environment();
 //add a variable to the current environment
 env["VALUE_1"] = "foo";
 
-//copy it into a environment seperate to the one of this process
+//copy it into a environment separate to the one of this process
 bp::environment env_ = env;  
 //append two values to a variable in the new env
 env_["VALUE_2"] += {"bar1", "bar2"};
 
 //launch a process with `env_`
 bp::system("stuff", env_); 
--- libs\process\test\async_fut.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\async_fut.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -72,6 +72,32 @@
     BOOST_REQUIRE_GE(line.size(), val.size());
     if (line >= val)
         BOOST_CHECK(boost::algorithm::starts_with(line, val));
 }
 
 
+BOOST_AUTO_TEST_CASE(emtpy_out, *boost::unit_test::timeout(2))
+{
+    using boost::unit_test::framework::master_test_suite;
+
+    boost::asio::io_service io_service;
+
+
+    std::error_code ec;
+    std::future<std::string> fut;
+
+    bp::spawn(
+        master_test_suite().argv[1],
+        "test", "--exit-code", "0",
+        bp::std_out > fut,
+        io_service,
+        ec
+    );
+    BOOST_REQUIRE(!ec);
+
+
+    io_service.run();
+
+    BOOST_REQUIRE(fut.valid());
+    BOOST_CHECK_EQUAL(fut.get(), "");
+}
+
--- libs\process\test\bind_stderr.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\bind_stderr.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -26,13 +26,13 @@
 
 #include <string>
 #include <istream>
 #include <iostream>
 #include <cstdlib>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <unistd.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\bind_stdin.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\bind_stdin.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -28,13 +28,13 @@
 #include <thread>
 
 #include <boost/config.hpp>
 
 
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <unistd.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\bind_stdout.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\bind_stdout.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -26,13 +26,13 @@
 #include <boost/filesystem.hpp>
 
 #include <string>
 #include <istream>
 #include <cstdlib>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <unistd.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\bind_stdout_stderr.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\bind_stdout_stderr.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -24,13 +24,13 @@
 
 #include <boost/asio.hpp>
 #include <boost/algorithm/string/predicate.hpp>
 #include <string>
 #include <istream>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
 
 namespace bp = boost::process;
--- libs\process\test\environment.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\environment.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -214,32 +214,32 @@
     BOOST_CHECK_EQUAL(env.at("b").to_string(), "2");
     BOOST_CHECK_EQUAL(env.at("c").to_string(), "3");
     BOOST_CHECK_EQUAL(env.size(), 3u);
     BOOST_CHECK_EQUAL(std::distance(env.begin(), env.end()), 3u);
     BOOST_CHECK_EQUAL(std::distance(env.cbegin(), env.cend()), 3u);
 
-    env.erase("a");
+    env.erase("c");
     BOOST_CHECK_EQUAL(env.size(), 2u);
-    BOOST_CHECK_EQUAL(env.count("a"), 0u);
+    BOOST_CHECK_EQUAL(env.at("a").to_string(), "1");
     BOOST_CHECK_EQUAL(env.at("b").to_string(), "2");
-    BOOST_CHECK_EQUAL(env.at("c").to_string(), "3");
+    BOOST_CHECK_EQUAL(env.count("c"), 0u);
 
     BOOST_CHECK_EQUAL(std::distance(env.begin(), env.end()), 2u);
     BOOST_CHECK_EQUAL(std::distance(env.cbegin(), env.cend()), 2u);
 
     env.erase("b");
     BOOST_CHECK_EQUAL(env.size(), 1u);
-    BOOST_CHECK_EQUAL(env.count("a"), 0u);
+    BOOST_CHECK_EQUAL(env.at("a").to_string(), "1");
     BOOST_CHECK_EQUAL(env.count("b"), 0u);
-    BOOST_CHECK_EQUAL(env.at("c").to_string(), "3");
+    BOOST_CHECK_EQUAL(env.count("c"), 0u);
 
     BOOST_CHECK_EQUAL(std::distance(env.begin(), env.end()), 1u);
     BOOST_CHECK_EQUAL(std::distance(env.cbegin(), env.cend()), 1u);
 
     env.clear();
     BOOST_CHECK(env.empty());
     BOOST_CHECK_EQUAL(env.size(), 0u);
 
     BOOST_CHECK_EQUAL(std::distance(env.begin(), env.end()), 0u);
     BOOST_CHECK_EQUAL(std::distance(env.cbegin(), env.cend()), 0u);
 
 }
--- libs\process\test\exit_code.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\exit_code.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -15,13 +15,13 @@
 #include <boost/process/async.hpp>
 #include <boost/process/child.hpp>
 
 #include <boost/system/error_code.hpp>
 #include <boost/asio.hpp>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <signal.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\group.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\group.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -26,13 +26,13 @@
 #include <string>
 #include <thread>
 #include <istream>
 #include <iostream>
 #include <cstdlib>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <unistd.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\Jamfile.jam	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\Jamfile.jam	2017-08-26 23:03:09.000000000 -0700
@@ -50,13 +50,13 @@
 test-suite bare :
     [ run environment.cpp system filesystem  ]
     [ run async_pipe.cpp system filesystem ]
     [ run pipe.cpp        system filesystem  ]
     ;
 
-test-suite execution :
+test-suite with-valgrind :
     [ run async.cpp       system thread filesystem            : : sparring_partner ]
     [ run async_fut.cpp   system thread filesystem            : : sparring_partner ]
     [ run args_cmd.cpp    system filesystem                   : : sparring_partner ]
     [ run wargs_cmd.cpp    system filesystem                  : : sparring_partner ]
     [ run bind_stderr.cpp     filesystem                      : : sparring_partner ]
     [ run bind_stdin.cpp     system filesystem                : : sparring_partner ]
@@ -75,25 +75,29 @@
     [ run group.cpp     system thread filesystem              : : sub_launch       ]
     [ run run_exe.cpp filesystem                              : : sparring_partner ]
     [ run run_exe_path.cpp filesystem                         : : sparring_partner ]
     [ run search_path.cpp filesystem system                   : : : <target-os>windows:<source>shell32 ]
     [ run shell.cpp filesystem system                         : : sparring_partner ]
     [ run shell_path.cpp  filesystem system                   ]
-    [ run async_system.cpp filesystem system coroutine        : : sparring_partner : <link>static ]
     [ run system_test1.cpp filesystem system                  : : sparring_partner ]
     [ run system_test2.cpp filesystem system                  : : sparring_partner ]
     [ run spawn.cpp filesystem system                         : : sparring_partner ]
     [ run start_dir.cpp   filesystem system                   : : sparring_partner ]
     [ run terminate.cpp system filesystem                     : : sparring_partner ]
     [ run throw_on_error.cpp system filesystem                : : sparring_partner ]
     [ run wait.cpp system filesystem                          : : sparring_partner ]
+    [ run wait_for.cpp system filesystem                      : : sparring_partner ]
+    [ run on_exit.cpp  system filesystem                      : : sparring_partner ]
+    [ run on_exit2.cpp system filesystem                      : : sparring_partner ]
+    [ run on_exit3.cpp system filesystem                      : : sparring_partner ]
     [ compile-fail spawn_fail.cpp        ]
     [ compile-fail async_system_fail.cpp ]
     [ run posix_specific.cpp     system filesystem            : : sparring_partner : <build>no <target-os>linux:<build>yes   ]
     [ run windows_specific.cpp filesystem system              : : sparring_partner : <build>no <target-os>windows:<build>yes   ]
    : <dependency>bare ;
 
-run vfork.cpp     system filesystem                     : : sparring_partner : <build>no <target-os>linux:<build>yes ;
-explicit vfork ;
-
-   
-   
+test-suite without-valgrind :
+    [ run async_system.cpp filesystem system coroutine        : : sparring_partner : <link>static ]
+    [ run vfork.cpp     system filesystem                     : : sparring_partner : <build>no <target-os>linux:<build>yes ]
+    ;
+
+
--- 
+++ libs\process\test\on_exit.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -0,0 +1,52 @@
+// Copyright (c) 2006, 2007 Julio M. Merino Vidal
+// Copyright (c) 2008 Ilya Sokolov, Boris Schaeling
+// Copyright (c) 2009 Boris Schaeling
+// Copyright (c) 2010 Felipe Tanus, Boris Schaeling
+// Copyright (c) 2011, 2012 Jeff Flinn, Boris Schaeling
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#define BOOST_TEST_MAIN
+#define BOOST_TEST_IGNORE_SIGCHLD
+#include <boost/test/included/unit_test.hpp>
+#include <boost/process.hpp>
+#include <boost/asio.hpp>
+#include <chrono>
+#include <thread>
+
+BOOST_AUTO_TEST_CASE(single_ios, *boost::unit_test::timeout(6))
+{
+    using boost::unit_test::framework::master_test_suite;
+
+    if (master_test_suite().argc > 2 && strcmp(master_test_suite().argv[1], "sleep") == 0)
+    {
+        auto s = atoi(master_test_suite().argv[2]);
+        std::this_thread::sleep_for(std::chrono::seconds(s));
+        return;
+    }
+
+    namespace bp = boost::process;
+    boost::asio::io_service ios;
+    std::chrono::steady_clock::time_point p1, p2;
+
+    // launch a child that will sleep for 2s
+    auto c1 = bp::child(master_test_suite().argv[0], "sleep", "2", ios,
+        bp::on_exit([&p1](int, const std::error_code&)
+    { p1 = std::chrono::steady_clock::now(); }));
+
+    // wait a bit, make sure the child launch for my test
+    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+
+    // launch a child that will sleep for 4s
+    auto c2 = bp::child(master_test_suite().argv[0], "sleep", "4", ios,
+        bp::on_exit([&p2](int, const std::error_code&)
+    { p2 = std::chrono::steady_clock::now(); }));
+
+    // wait for the notifications
+    while (!ios.stopped())
+        ios.run_one();
+
+    BOOST_REQUIRE((p2 - p1) > std::chrono::seconds(1));
+}
+
--- 
+++ libs\process\test\on_exit2.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -0,0 +1,50 @@
+// Copyright (c) 2006, 2007 Julio M. Merino Vidal
+// Copyright (c) 2008 Ilya Sokolov, Boris Schaeling
+// Copyright (c) 2009 Boris Schaeling
+// Copyright (c) 2010 Felipe Tanus, Boris Schaeling
+// Copyright (c) 2011, 2012 Jeff Flinn, Boris Schaeling
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#define BOOST_TEST_MAIN
+#define BOOST_TEST_IGNORE_SIGCHLD
+#include <boost/test/included/unit_test.hpp>
+#include <boost/process.hpp>
+#include <boost/asio.hpp>
+#include <chrono>
+#include <thread>
+
+BOOST_AUTO_TEST_CASE(double_ios, *boost::unit_test::timeout(6))
+{
+    using boost::unit_test::framework::master_test_suite;
+
+    if (master_test_suite().argc > 2 && strcmp(master_test_suite().argv[1], "sleep") == 0)
+    {
+        auto s = atoi(master_test_suite().argv[2]);
+        std::this_thread::sleep_for(std::chrono::seconds(s));
+        return;
+    }
+
+    namespace bp = boost::process;
+    boost::asio::io_service ios;
+    std::chrono::steady_clock::time_point p1, p2;
+
+    // launch a child that will sleep for 2s
+    auto c1 = bp::child(master_test_suite().argv[0], "sleep", "2", ios,
+        bp::on_exit([&p1](int, const std::error_code&)
+    { p1 = std::chrono::steady_clock::now(); }));
+
+    // wait a bit, make sure the child launch for my test
+    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+
+    // launch a child that will sleep for 4s
+    auto c2 = bp::child(master_test_suite().argv[0], "sleep", "4", ios,
+        bp::on_exit([&p2](int, const std::error_code&)
+    { p2 = std::chrono::steady_clock::now(); }));
+
+
+    ios.run();
+    BOOST_REQUIRE((p2 - p1) > std::chrono::seconds(1));
+}
+
--- 
+++ libs\process\test\on_exit3.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -0,0 +1,51 @@
+// Copyright (c) 2006, 2007 Julio M. Merino Vidal
+// Copyright (c) 2008 Ilya Sokolov, Boris Schaeling
+// Copyright (c) 2009 Boris Schaeling
+// Copyright (c) 2010 Felipe Tanus, Boris Schaeling
+// Copyright (c) 2011, 2012 Jeff Flinn, Boris Schaeling
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#define BOOST_TEST_MAIN
+#define BOOST_TEST_IGNORE_SIGCHLD
+#include <boost/test/included/unit_test.hpp>
+#include <boost/process.hpp>
+#include <boost/asio.hpp>
+#include <chrono>
+#include <thread>
+
+BOOST_AUTO_TEST_CASE(double_ios_threaded, *boost::unit_test::timeout(6))
+{
+    using boost::unit_test::framework::master_test_suite;
+
+    if (master_test_suite().argc > 2 && strcmp(master_test_suite().argv[1], "sleep") == 0)
+    {
+        auto s = atoi(master_test_suite().argv[2]);
+        std::this_thread::sleep_for(std::chrono::seconds(s));
+        return;
+    }
+
+    namespace bp = boost::process;
+    boost::asio::io_service ios;
+    std::chrono::steady_clock::time_point p1, p2;
+
+    // launch a child that will sleep for 2s
+    auto c1 = bp::child(master_test_suite().argv[0], "sleep", "2", ios,
+        bp::on_exit([&p1](int, const std::error_code&)
+    { p1 = std::chrono::steady_clock::now(); }));
+
+    // wait a bit, make sure the child launch for my test
+    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+
+    // launch a child that will sleep for 4s
+    auto c2 = bp::child(master_test_suite().argv[0], "sleep", "4", ios,
+        bp::on_exit([&p2](int, const std::error_code&)
+    { p2 = std::chrono::steady_clock::now(); }));
+
+    // wait for the notifications
+    std::thread ([&ios] { ios.run(); }).join();
+
+    BOOST_REQUIRE((p2 - p1) > std::chrono::seconds(1));
+}
+
--- libs\process\test\sparring_partner.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\sparring_partner.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -25,13 +25,13 @@
 #if defined(BOOST_POSIX_API)
 #   include <boost/lexical_cast.hpp>
 #   include <boost/iostreams/device/file_descriptor.hpp>
 #   include <boost/iostreams/stream.hpp>
 #   include <unistd.h>
 #elif defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 #endif
 
 
 using namespace boost::program_options;
 
 int main(int argc, char *argv[])
--- libs\process\test\spawn.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\spawn.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -27,13 +27,13 @@
 #include <boost/filesystem.hpp>
 
 #include <string>
 #include <istream>
 #include <cstdlib>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <unistd.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\spawn_fail.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\spawn_fail.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -23,13 +23,13 @@
 #include <boost/filesystem.hpp>
 
 #include <string>
 #include <istream>
 #include <cstdlib>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <unistd.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\system_test1.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\system_test1.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -32,13 +32,13 @@
 
 #include <string>
 #include <chrono>
 #include <istream>
 #include <cstdlib>
 #if defined(BOOST_WINDOWS_API)
-#   include <Windows.h>
+#   include <windows.h>
 typedef boost::asio::windows::stream_handle pipe_end;
 #elif defined(BOOST_POSIX_API)
 #   include <sys/wait.h>
 #   include <unistd.h>
 typedef boost::asio::posix::stream_descriptor pipe_end;
 #endif
--- libs\process\test\wait.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\wait.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -61,35 +61,6 @@
     BOOST_REQUIRE(!ec);
 
     io_service.run();
     BOOST_CHECK(called);
 
 }
-
-BOOST_AUTO_TEST_CASE(double_wait, *boost::unit_test::timeout(5))
-{
-    using boost::unit_test::framework::master_test_suite;
-    using namespace boost::asio;
-
-    boost::asio::io_service io_service;
-
-    std::error_code ec;
-    std::atomic<bool> called{false};
-
-    bp::child c(
-        master_test_suite().argv[1],
-        bp::args+={"test", "--wait", "1"},
-        ec,
-        io_service,
-        bp::on_exit([&](int, const std::error_code&){called.store(true);})
-
-    );
-    BOOST_REQUIRE(!ec);
-
-    std::thread th([&]{io_service.run();});
-
-    c.wait();
-
-    th.join();
-    BOOST_CHECK(called.load());
-
-}
--- 
+++ libs\process\test\wait_for.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -0,0 +1,104 @@
+// Copyright (c) 2006, 2007 Julio M. Merino Vidal
+// Copyright (c) 2008 Ilya Sokolov, Boris Schaeling
+// Copyright (c) 2009 Boris Schaeling
+// Copyright (c) 2010 Felipe Tanus, Boris Schaeling
+// Copyright (c) 2011, 2012 Jeff Flinn, Boris Schaeling
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+
+#define BOOST_TEST_MAIN
+#define BOOST_TEST_IGNORE_SIGCHLD
+#include <boost/test/included/unit_test.hpp>
+#include <boost/process/error.hpp>
+#include <boost/process/child.hpp>
+#include <boost/process/args.hpp>
+#include <thread>
+#include <atomic>
+#include <system_error>
+#include <boost/asio.hpp>
+#if defined(BOOST_POSIX_API)
+#   include <signal.h>
+#endif
+
+namespace bp = boost::process;
+
+BOOST_AUTO_TEST_CASE(wait_for)
+{
+    using boost::unit_test::framework::master_test_suite;
+
+    std::error_code ec;
+    bp::child c(
+        master_test_suite().argv[1],
+        bp::args+={"test", "--wait", "1"},
+        ec
+    );
+    BOOST_REQUIRE(!ec);
+
+    BOOST_CHECK(!c.wait_for(std::chrono::milliseconds(200)));
+    BOOST_CHECK( c.wait_for(std::chrono::milliseconds(1000)));
+}
+
+BOOST_AUTO_TEST_CASE(wait_for_ec)
+{
+    using boost::unit_test::framework::master_test_suite;
+
+    std::error_code ec;
+    bp::child c(
+        master_test_suite().argv[1],
+        bp::args+={"test", "--wait", "1"},
+        ec
+    );
+    BOOST_REQUIRE(!ec);
+
+    BOOST_CHECK(!c.wait_for(std::chrono::milliseconds(400),ec));
+    BOOST_CHECK( c.wait_for(std::chrono::milliseconds(1000),ec));
+
+    BOOST_CHECK_MESSAGE(!ec, ec.message());
+}
+
+
+BOOST_AUTO_TEST_CASE(wait_until)
+{
+    using boost::unit_test::framework::master_test_suite;
+    std::error_code ec;
+
+    bp::child c(
+        master_test_suite().argv[1],
+        bp::args+={"test", "--wait", "1"},
+        ec
+    );
+    BOOST_REQUIRE(!ec);
+
+    auto now = std::chrono::system_clock::now();
+
+    auto t1 = now + std::chrono::milliseconds(400);
+    auto t2 = now + std::chrono::milliseconds(1200);
+
+    BOOST_CHECK(!c.wait_until(t1));
+    BOOST_CHECK( c.wait_until(t2));
+
+}
+
+BOOST_AUTO_TEST_CASE(wait_until_ec)
+{
+    using boost::unit_test::framework::master_test_suite;
+    std::error_code ec;
+
+    bp::child c(
+        master_test_suite().argv[1],
+        bp::args+={"test", "--wait", "1"},
+        ec
+    );
+    BOOST_REQUIRE(!ec);
+
+    auto now = std::chrono::system_clock::now();
+
+    auto t1 = now + std::chrono::milliseconds(400);
+    auto t2 = now + std::chrono::milliseconds(1200);
+
+    BOOST_CHECK(!c.wait_until(t1, ec));
+    BOOST_CHECK( c.wait_until(t2, ec));
+
+    BOOST_CHECK_MESSAGE(!ec, ec.message());
+}
--- libs\process\test\wargs_cmd.cpp	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\test\wargs_cmd.cpp	2017-08-26 23:03:09.000000000 -0700
@@ -37,13 +37,12 @@
         bp::std_out>is,
         ec
     );
     if (ec)
         std::cout << "EC: " << ec.message() << std::endl;
     BOOST_REQUIRE(!ec);
-    return ;
 
     std::string s;
 
     std::getline(is, s);
     s.resize(4);
     BOOST_CHECK_EQUAL(s, "test");
@@ -84,13 +83,13 @@
 
     bp::child c(cmd,
         bp::std_out>is,
         ec
     );
     BOOST_REQUIRE(!ec);
-    return ;
+
     std::string s;
 
     std::getline(is, s);
     s.resize(4);
     BOOST_CHECK_EQUAL(s, "test");
 
--- libs\process\README.md	2017-08-19 09:49:45.000000000 -0700
+++ libs\process\README.md	2017-08-26 23:03:08.000000000 -0700
@@ -1,16 +1,16 @@
-#[Boost Process (Boost.Process)](https://github.com/klemens-morgenstern/boost-process)
+# [Boost Process (Boost.Process)](https://github.com/klemens-morgenstern/boost-process)
 
-Boost.process is not yet part of the [Boost C++ Libraries](http://github.com/boostorg), but will probably be released in boost 1.64. It is a library for comfortable management of processes.
+Boost.process is a library for comfortable management of processes, released with boost 1.64.0.
 
 ### Test results
 
 Branches        | Build         | Tests coverage | 
 ----------------|-------------- | -------------- |
 Develop:        | [![Build Status](https://travis-ci.org/klemens-morgenstern/boost-process.svg?branch=develop)](https://travis-ci.org/klemens-morgenstern/boost-process)  [![Build status](https://ci.appveyor.com/api/projects/status/peup7e6m0e1bb5ba?svg=true)](https://ci.appveyor.com/project/klemens-morgenstern/boost-process) | [![Coverage Status](https://coveralls.io/repos/github/klemens-morgenstern/boost-process/badge.svg?branch=develop)](https://coveralls.io/github/klemens-morgenstern/boost-process?branch=develop) |
-Master:         | [![Build Status](https://travis-ci.org/klemens-morgenstern/boost-process.svg?branch=master)] (https://travis-ci.org/klemens-morgenstern/boost-process) [![Build status](https://ci.appveyor.com/api/projects/status/peup7e6m0e1bb5ba/branch/master?svg=true)](https://ci.appveyor.com/project/klemens-morgenstern/boost-process/branch/master) | [![Coverage Status](https://coveralls.io/repos/github/klemens-morgenstern/boost-process/badge.svg?branch=master)](https://coveralls.io/github/klemens-morgenstern/boost-process?branch=master)   |
+Master:         | [![Build Status](https://travis-ci.org/klemens-morgenstern/boost-process.svg?branch=master)](https://travis-ci.org/klemens-morgenstern/boost-process) [![Build status](https://ci.appveyor.com/api/projects/status/peup7e6m0e1bb5ba/branch/master?svg=true)](https://ci.appveyor.com/project/klemens-morgenstern/boost-process/branch/master) | [![Coverage Status](https://coveralls.io/repos/github/klemens-morgenstern/boost-process/badge.svg?branch=master)](https://coveralls.io/github/klemens-morgenstern/boost-process?branch=master)   |
 
 [Open Issues](https://github.com/klemens-morgenstern/boost-process/issues)
 
 [Latest developer documentation](http://klemens-morgenstern.github.io/process/)
 
 ### About
@@ -18,7 +18,7 @@
 
 ### License
 Distributed under the [Boost Software License, Version 1.0](http://www.boost.org/LICENSE_1_0.txt).
 
 ### Dependency
 
-This library requires boost 1.63. Since this is not released yet you can clone the winapi module from [here](https://github.com/boostorg/winapi) to get it to work on windows.
+This library requires boost 1.64 with which it is released.
--- libs\smart_ptr\test\atomic_sp_constexpr_test.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\smart_ptr\test\atomic_sp_constexpr_test.cpp	2017-08-28 18:55:51.000000000 -0700
@@ -14,13 +14,13 @@
 #define HAVE_CONSTEXPR_INIT
 
 #if defined( BOOST_NO_CXX11_CONSTEXPR )
 # undef HAVE_CONSTEXPR_INIT
 #endif
 
-#if BOOST_WORKAROUND( BOOST_MSVC, <= 1910 )
+#if BOOST_WORKAROUND( BOOST_MSVC, < 1920 )
 # undef HAVE_CONSTEXPR_INIT
 #endif
 
 #if defined(__clang__) && defined( BOOST_NO_CXX14_CONSTEXPR )
 # undef HAVE_CONSTEXPR_INIT
 #endif
--- libs\smart_ptr\test\sp_constexpr_test.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\smart_ptr\test\sp_constexpr_test.cpp	2017-08-28 18:55:52.000000000 -0700
@@ -14,13 +14,13 @@
 #define HAVE_CONSTEXPR_INIT
 
 #if defined( BOOST_NO_CXX11_CONSTEXPR )
 # undef HAVE_CONSTEXPR_INIT
 #endif
 
-#if BOOST_WORKAROUND( BOOST_MSVC, <= 1910 )
+#if BOOST_WORKAROUND( BOOST_MSVC, < 1920 )
 # undef HAVE_CONSTEXPR_INIT
 #endif
 
 #if defined(__clang__) && defined( BOOST_NO_CXX14_CONSTEXPR )
 # undef HAVE_CONSTEXPR_INIT
 #endif
--- libs\smart_ptr\test\sp_constexpr_test2.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\smart_ptr\test\sp_constexpr_test2.cpp	2017-08-28 18:55:52.000000000 -0700
@@ -14,13 +14,13 @@
 #define HAVE_CONSTEXPR_INIT
 
 #if defined( BOOST_NO_CXX11_CONSTEXPR )
 # undef HAVE_CONSTEXPR_INIT
 #endif
 
-#if BOOST_WORKAROUND( BOOST_MSVC, <= 1910 )
+#if BOOST_WORKAROUND( BOOST_MSVC, < 1920 )
 # undef HAVE_CONSTEXPR_INIT
 #endif
 
 #if defined(__clang__) && defined( BOOST_NO_CXX14_CONSTEXPR )
 # undef HAVE_CONSTEXPR_INIT
 #endif
--- libs\spirit\test\x3\with.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\spirit\test\x3\with.cpp	2017-08-24 15:10:21.000000000 -0700
@@ -53,8 +53,62 @@
 
         BOOST_TEST(test("(123,456)", start));
         BOOST_TEST(!test("(abc,def)", start));
         BOOST_TEST(val == 2);
     }
 
+    { // injecting non-const lvalue into the context
+        int val = 0;
+        auto const r  = int_[([](auto& ctx){
+            x3::get<my_tag>(ctx) += x3::_attr(ctx);
+        })];
+        BOOST_TEST(test("123,456", with<my_tag>(val)[r % ',']));
+        BOOST_TEST(579 == val);
+    }
+
+    { // injecting rvalue into the context
+        auto const r1 = int_[([](auto& ctx){
+            x3::get<my_tag>(ctx) += x3::_attr(ctx);
+        })];
+        auto const r2 = rule<struct my_rvalue_rule_class, int>() =
+            x3::lit('(') >> (r1 % ',') >> x3::lit(')')[([](auto& ctx){
+                x3::_val(ctx) = x3::get<my_tag>(ctx);
+            })];
+        int attr = 0;
+        BOOST_TEST(test_attr("(1,2,3)", with<my_tag>(100)[r2], attr));
+        BOOST_TEST(106 == attr);
+    }
+
+    { // injecting const/non-const lvalue and rvalue into the context
+        struct functor {
+            int operator()(int& val) {
+                return val * 10; // non-const ref returns 10 * injected val
+            }
+            int operator()(int const& val) {
+                return val; // const ref returns injected val
+            }
+        };
+
+        auto f = [](auto& ctx){
+            x3::_val(ctx) = x3::_attr(ctx) + functor()(x3::get<my_tag>(ctx));
+        };
+        auto const r = rule<struct my_rule_class2, int>() = int_[f];
+
+        int attr = 0;
+        int const cval = 10;
+        BOOST_TEST(test_attr("5", with<my_tag>(cval)[r], attr));
+        BOOST_TEST(15 == attr); // x3::get returns const ref to cval
+
+        attr = 0;
+        int val = 10;
+        BOOST_TEST(test_attr("5", with<my_tag>(val)[r], attr));
+        BOOST_TEST(105 == attr); // x3::get returns ref to val
+
+        attr = 0;
+
+        BOOST_TEST(test_attr("5", with<my_tag>(10)[r], attr));
+        // x3::get returns ref to member variable of with_directive
+        BOOST_TEST(105 == attr);
+    }
+
     return boost::report_errors();
 }
--- libs\stacktrace\build\has_windbg_cached.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\stacktrace\build\has_windbg_cached.cpp	2017-08-24 16:44:48.000000000 -0700
@@ -1,21 +1,28 @@
 // Copyright Antony Polukhin, 2016-2017.
 //
 // Distributed under the Boost Software License, Version 1.0. (See
 // accompanying file LICENSE_1_0.txt or copy at
 // http://www.boost.org/LICENSE_1_0.txt)
 
+#include <boost/config.hpp>
+
+#include <string>
 #include <cstring>
 #include <windows.h>
 #include "dbgeng.h"
 
+#ifdef BOOST_NO_CXX11_THREAD_LOCAL
+#   error Your compiler does not support C++11 thread_local storage. It's impossible to build with BOOST_STACKTRACE_USE_WINDBG_CACHED.
+#endif
+
 int foo() {
-    static thread_local int i = 0;
+    static thread_local std::string i = std::string();
     
-    return i;
+    return i.size();
 }
 
 int main() {
     ::CoInitializeEx(0, COINIT_MULTITHREADED);
     
     return foo();
 }
--- libs\thread\doc\changes.qbk	2017-08-19 09:49:49.000000000 -0700
+++ libs\thread\doc\changes.qbk	2017-08-26 22:32:23.000000000 -0700
@@ -1,15 +1,58 @@
 [/
   (C) Copyright 2007-11 Anthony Williams.
-  (C) Copyright 2011-16 Vicente J. Botet Escriba.
+  (C) Copyright 2011-17 Vicente J. Botet Escriba.
   Distributed under the Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt).
 ]
 
 [section:changes History]
+
+[heading Version 4.8.0 - boost 1.66]
+
+[*Know Bugs:]
+
+* [@http://svn.boost.org/trac/boost/ticket/3926 #3926] thread_specific_ptr + dlopen library causes a SIGSEGV.
+
+* [@http://svn.boost.org/trac/boost/ticket/10964 #10964] future<future<T>>::unwrap().then() Deadlocks
+
+
+Please take a look at [@https://svn.boost.org/trac/boost/query?status=assigned&status=new&status=reopened&component=thread&type=!Feature+Requests&col=id&col=summary&order=id thread Know Bugs] to see the current state.
+
+Please take a look at [@http://www.boost.org/development/tests/master/developer/thread.html thread master regression test] to see the last regression test snapshot.
+
+[*Fixed Bugs:]
+
+* [@http://svn.boost.org/trac/boost/ticket/12949 #12949] using sleep_for in a thread context without including boost/thread/thread.hpp yields incorrect behaviour when BOOST_THREAD_HAS_CONDATTR_SET_CLOCK_MONOTONIC is defined
+* [@http://svn.boost.org/trac/boost/ticket/13019 #13019] ABI compatibility for BOOST_THREAD_PROVIDES_INTERRUPTIONS incomplete
+* [@http://svn.boost.org/trac/boost/ticket/13163 #13163] boost::detail::heap_new does not have a variadic variant
+
+* [@https://github.com/boostorg/thread/issues/130 #130] windows: Bug in boost::condition_variable on Windows
+
+[heading Version 4.7.4 - boost 1.65]
+
+[*Fixed Bugs:]
+
+* [@http://svn.boost.org/trac/boost/ticket/6787 #6787] boost::thread::sleep() hangs if system time is rolled back
+* [@http://svn.boost.org/trac/boost/ticket/12519 #12519] boost::thread::try_join_for does not return after timeout
+* [@http://svn.boost.org/trac/boost/ticket/12874 #12874] future<> extension constructor must be under BOOST_THREAD_PROVIDES_FUTURE_UNWRAP
+* [@http://svn.boost.org/trac/boost/ticket/12888 #12888] Linking with boost thread does not work on mingw/gcc 4.4
+* [@http://svn.boost.org/trac/boost/ticket/12958 #12958] sync_bounded_queue::wait_pull_front( lve ) might throw
+* [@http://svn.boost.org/trac/boost/ticket/13077 #13077] Linking to static 64bit libboost_thread fails DLL initialization
+* [@http://svn.boost.org/trac/boost/ticket/13155 #13155] log doesn't build on a system with pthreads
+
+* [@https://github.com/boostorg/thread/issues/121 #121] on_tls_prepare is broken under VS2017
+
+[heading Version 4.7.3 - boost 1.64]
+
+[*Fixed Bugs:]
+
+* [@https://github.com/boostorg/thread/issues/113 #113] Add a Thread template on all the scoped thread and thread guard classes
+* [@https://github.com/boostorg/thread/issues/117 #117] loop_executor should block on it's work_queue instead of polling
+* [@https://github.com/boostorg/thread/issues/119 #119] basic_condition_variable::relocker::~relocker can throw an exception
 
 [heading Version 4.7.2 - boost 1.63]
 
 [*Fixed Bugs:]
 
 * fix boost::synchronized_value<>::load() 
@@ -24,13 +67,13 @@
 * [@http://svn.boost.org/trac/boost/ticket/3926 #3926] thread_specific_ptr + dlopen library causes a SIGSEGV.
 
 Please define BOOST_THREAD_PATCH to apply the patch that could unfortunately results is a regression as described in [@http://svn.boost.org/trac/boost/ticket/12049 #12049].
 
 Please take a look at [@https://svn.boost.org/trac/boost/query?status=assigned&status=new&status=reopened&component=thread&type=!Feature+Requests&col=id&col=summary&order=id thread Know Bugs] to see the current state.
 
-Please take a look at [@http://www.boost.org/development/tests/master/developer/thread.html thread trunk regression test] to see the last regression test snapshot.
+Please take a look at [@http://www.boost.org/development/tests/master/developer/thread.html thread master regression test] to see the last regression test snapshot.
 
 
 [*Fixed Bugs:]
 
 * [@http://svn.boost.org/trac/boost/ticket/11097 #11097] 	test_scheduled_tp - ThreadSanitizer: heap-use-after-free
 * [@http://svn.boost.org/trac/boost/ticket/11951 #11951] 	Memory leak in boost::when_all
--- libs\thread\doc\thread.qbk	2017-08-19 09:49:49.000000000 -0700
+++ libs\thread\doc\thread.qbk	2017-08-26 22:32:23.000000000 -0700
@@ -5,16 +5,16 @@
   (See accompanying file LICENSE_1_0.txt or copy at
   http://www.boost.org/LICENSE_1_0.txt).
 ]
 
 [library Thread
     [quickbook 1.5]
-    [version 4.7.2]
+    [version 4.8.0]
     [authors [Williams, Anthony] [Botet Escriba, Vicente J.]]
     [copyright 2007-11 Anthony Williams]
-    [copyright 2011-16 Vicente J. Botet Escriba]
+    [copyright 2011-17 Vicente J. Botet Escriba]
     [purpose C++ Library for launching threads and synchronizing data between them]
     [category text]
     [license
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         [@http://www.boost.org/LICENSE_1_0.txt])
--- libs\thread\src\pthread\thread.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\thread\src\pthread\thread.cpp	2017-08-26 22:32:24.000000000 -0700
@@ -49,13 +49,13 @@
                 i->second->unlock();
                 i->first->notify_all();
             }
             for (async_states_t::iterator i = async_states_.begin(), e = async_states_.end();
                     i != e; ++i)
             {
-                (*i)->make_ready();
+                (*i)->notify_deferred();
             }
         }
 
         struct thread_exit_callback_node
         {
             boost::detail::thread_exit_function_base* func;
@@ -454,13 +454,13 @@
                   condition_variable cond;
                   cond.do_wait_for(lock, ts);
     #   endif
                 }
           }
 
-          void BOOST_THREAD_DECL sleep_until(const timespec& ts)
+          void BOOST_THREAD_DECL sleep_until_realtime(const timespec& ts)
           {
                 timespec now = boost::detail::timespec_now_realtime();
                 if (boost::detail::timespec_gt(ts, now))
                 {
                   for (int foo=0; foo < 5; ++foo)
                   {
@@ -484,13 +484,12 @@
                     {
                       return;
                     }
                   }
                 }
           }
-
         }
       }
       namespace hidden
       {
         void BOOST_THREAD_DECL sleep_for(const timespec& ts)
         {
@@ -504,24 +503,24 @@
             else
             {
               boost::this_thread::no_interruption_point::hidden::sleep_for(ts);
             }
         }
 
-        void BOOST_THREAD_DECL sleep_until(const timespec& ts)
+        void BOOST_THREAD_DECL sleep_until_realtime(const timespec& ts)
         {
             boost::detail::thread_data_base* const thread_info=boost::detail::get_current_thread_data();
 
             if(thread_info)
             {
               unique_lock<mutex> lk(thread_info->sleep_mutex);
               while(thread_info->sleep_condition.do_wait_until(lk,ts)) {}
             }
             else
             {
-              boost::this_thread::no_interruption_point::hidden::sleep_until(ts);
+              boost::this_thread::no_interruption_point::hidden::sleep_until_realtime(ts);
             }
         }
       } // hidden
     } // this_thread
 
     namespace this_thread
--- libs\thread\src\win32\thread.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\thread\src\win32\thread.cpp	2017-08-26 22:32:25.000000000 -0700
@@ -54,13 +54,13 @@
             i->second->unlock();
             i->first->notify_all();
         }
         for (async_states_t::iterator i = async_states_.begin(), e = async_states_.end();
                 i != e; ++i)
         {
-            (*i)->make_ready();
+            (*i)->notify_deferred();
         }
     }
   }
 
     namespace
     {
--- libs\thread\src\win32\tss_pe.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\thread\src\win32\tss_pe.cpp	2017-08-28 20:49:57.000000000 -0700
@@ -108,16 +108,34 @@
 #endif
 
 
 
 
     //Definitions required by implementation
-
-    typedef int (__cdecl *_PVFV)();
-    #define INIRETSUCCESS 0
-    #define PVAPI int __cdecl
+    #if (_MSC_VER < 1300) || ((_MSC_VER > 1900) && (_MSC_VER < 1910)) // 1300 == VC++ 7.0, 1900 == VC++ 14.0, 1910 == VC++ 2017
+        typedef void ( __cdecl *_PVFV_ )();
+        typedef void ( __cdecl *_PIFV_ )();
+        #define INIRETSUCCESS_V
+        #define INIRETSUCCESS_I
+        #define PVAPI_V void __cdecl
+        #define PVAPI_I void __cdecl
+    #elif (_MSC_VER >= 1910)
+        typedef void ( __cdecl *_PVFV_ )();
+        typedef int ( __cdecl *_PIFV_ )();
+        #define INIRETSUCCESS_V
+        #define INIRETSUCCESS_I 0
+        #define PVAPI_V void __cdecl
+        #define PVAPI_I int __cdecl
+    #else
+        typedef int ( __cdecl *_PVFV_ )();
+        typedef int ( __cdecl *_PIFV_ )();
+        #define INIRETSUCCESS_V 0
+        #define INIRETSUCCESS_I 0
+        #define PVAPI_V int __cdecl
+        #define PVAPI_I int __cdecl
+    #endif
 
     typedef void (NTAPI* _TLSCB)(HINSTANCE, DWORD, PVOID);
 
     //Symbols for connection to the runtime environment
 
     extern "C"
@@ -127,70 +145,70 @@
     }
 
     namespace
     {
         //Forward declarations
 
-        static PVAPI on_tls_prepare();
-        static PVAPI on_process_init();
-        static PVAPI on_process_term();
+        static PVAPI_I on_tls_prepare();
+        static PVAPI_V on_process_init();
+        static PVAPI_V on_process_term();
         static void NTAPI on_tls_callback(HINSTANCE, DWORD, PVOID);
 
         //The .CRT$Xxx information is taken from Codeguru:
         //http://www.codeguru.com/Cpp/misc/misc/threadsprocesses/article.php/c6945__2/
 
 #if (_MSC_VER >= 1400)
 #pragma section(".CRT$XIU",long,read)
 #pragma section(".CRT$XCU",long,read)
 #pragma section(".CRT$XTU",long,read)
 #pragma section(".CRT$XLC",long,read)
         __declspec(allocate(".CRT$XLC")) _TLSCB __xl_ca=on_tls_callback;
-        __declspec(allocate(".CRT$XIU"))_PVFV p_tls_prepare = on_tls_prepare;
-        __declspec(allocate(".CRT$XCU"))_PVFV p_process_init = on_process_init;
-        __declspec(allocate(".CRT$XTU"))_PVFV p_process_term = on_process_term;
+        __declspec(allocate(".CRT$XIU"))_PIFV_ p_tls_prepare = on_tls_prepare;
+        __declspec(allocate(".CRT$XCU"))_PVFV_ p_process_init = on_process_init;
+        __declspec(allocate(".CRT$XTU"))_PVFV_ p_process_term = on_process_term;
 #else
         #if (_MSC_VER >= 1300) // 1300 == VC++ 7.0
         #   pragma data_seg(push, old_seg)
         #endif
             //Callback to run tls glue code first.
             //I don't think it is necessary to run it
             //at .CRT$XIB level, since we are only
             //interested in thread detachement. But
             //this could be changed easily if required.
 
             #pragma data_seg(".CRT$XIU")
-            static _PVFV p_tls_prepare = on_tls_prepare;
+            static _PIFV_ p_tls_prepare = on_tls_prepare;
             #pragma data_seg()
 
             //Callback after all global ctors.
 
             #pragma data_seg(".CRT$XCU")
-            static _PVFV p_process_init = on_process_init;
+            static _PVFV_ p_process_init = on_process_init;
             #pragma data_seg()
 
             //Callback for tls notifications.
 
             #pragma data_seg(".CRT$XLB")
             _TLSCB p_thread_callback = on_tls_callback;
             #pragma data_seg()
             //Callback for termination.
 
             #pragma data_seg(".CRT$XTU")
-            static _PVFV p_process_term = on_process_term;
+            static _PVFV_ p_process_term = on_process_term;
             #pragma data_seg()
         #if (_MSC_VER >= 1300) // 1300 == VC++ 7.0
         #   pragma data_seg(pop, old_seg)
         #endif
 #endif
 
 #ifdef BOOST_MSVC
 #pragma warning(push)
 #pragma warning(disable:4189)
 #endif
 
-        PVAPI on_tls_prepare()
+        PVAPI_I on_tls_prepare()
         {
             //The following line has an important side effect:
             //if the TLS directory is not already there, it will
             //be created by the linker. In other words, it forces a tls
             //directory to be generated by the linker even when static tls
             //(i.e. __declspec(thread)) is not used.
@@ -219,19 +237,19 @@
                     ++pfbegin;
                 }
 
                 *pfdst = 0;
             #endif
 
-            return INIRETSUCCESS;
+            return INIRETSUCCESS_I;
         }
 #ifdef BOOST_MSVC
 #pragma warning(pop)
 #endif
 
-        PVAPI on_process_init()
+        PVAPI_V on_process_init()
         {
             //Schedule on_thread_exit() to be called for the main
             //thread before destructors of global objects have been
             //called.
 
             //It will not be run when 'quick' exiting the
@@ -242,19 +260,19 @@
             atexit(boost::on_thread_exit);
 
             //Call Boost process entry callback here
 
             boost::on_process_enter();
 
-            return INIRETSUCCESS;
+            return INIRETSUCCESS_V;
         }
 
-        PVAPI on_process_term()
+        PVAPI_V on_process_term()
         {
             boost::on_process_exit();
-            return INIRETSUCCESS;
+            return INIRETSUCCESS_V;
         }
 
         void NTAPI on_tls_callback(HINSTANCE /*h*/, DWORD dwReason, PVOID /*pv*/)
         {
             switch (dwReason)
             {
--- libs\thread\test\test_9856.cpp	2017-08-19 09:49:49.000000000 -0700
+++ libs\thread\test\test_9856.cpp	2017-08-28 20:50:00.000000000 -0700
@@ -3,13 +3,13 @@
 #include <iostream>
 
 using namespace boost;
 
 int main() {
     atomic<size_t> total(0), failures(0);
-    
+
 #pragma omp parallel shared(total, failures) num_threads(1000)
     {
       mutex mtx;
       condition_variable cond;
       unique_lock<mutex> lk(mtx);
       for (int i = 0; i < 500; i++) {
@@ -17,13 +17,13 @@
         if (cv_status::timeout != cond.wait_for(lk, chrono::milliseconds(10)))
           ++failures;
       }
     }
     if(failures)
       std::cout << "There were " << failures << " failures out of " << total << " timed waits." << std::endl;
-    if((100*failures)/total>10)
+    if((100*failures)/total>40)
     {
       std::cerr << "This exceeds 10%, so failing the test." << std::endl;
       return 1;
     }
     return 0;
 }
--- tools\build\src\engine\boehm_gc\misc.c	2017-08-19 09:49:50.000000000 -0700
+++ tools\build\src\engine\boehm_gc\misc.c	2017-08-21 15:16:58.000000000 -0700
@@ -862,13 +862,13 @@
 	    ABORT("Open of log file failed");
       }
       tmp = WriteFile(GC_stdout, buf, (DWORD)len, &written, NULL);
       if (!tmp)
 	  DebugBreak();
 #     if defined(_MSC_VER) && defined(_DEBUG)
-	  _CrtDbgReport(_CRT_WARN, NULL, 0, NULL, "%.*s", len, buf);
+	  _CrtDbgReport(_CRT_WARN, NULL, 0, NULL, "%.*s", (int)len, buf);
 #     endif
       if (GC_need_to_lock) LeaveCriticalSection(&GC_write_cs);
       return tmp ? (int)written : -1;
   }
 # undef GC_need_to_lock
 
--- tools\build\src\engine\filent.c	2017-08-19 09:49:50.000000000 -0700
+++ tools\build\src\engine\filent.c	2017-08-21 15:17:37.000000000 -0700
@@ -482,13 +482,13 @@
             if ( c = strrchr( name, '/' ) )
                 name = c + 1;
             if ( c = strrchr( name, '\\' ) )
                 name = c + 1;
         }
 
-        sprintf( buf, "%.*s", endname - name, name );
+        sprintf( buf, "%.*s", (int)( endname - name ), name );
 
         if ( strcmp( buf, "") != 0 )
         {
             file_info_t * member = 0;
 
             /* NT static libraries appear to store the objects in a sequence
--- tools\build\src\tools\builtin.jam	2017-08-19 09:49:50.000000000 -0700
+++ tools\build\src\tools\builtin.jam	2017-08-24 16:09:26.000000000 -0700
@@ -277,15 +277,16 @@
 # The specific instruction set in an architecture to compile.
 feature.feature instruction-set :
     # x86 and x86-64
     native i486 i586 i686 pentium pentium-mmx pentiumpro pentium2 pentium3
     pentium3m pentium-m pentium4 pentium4m prescott nocona core2 corei7 corei7-avx core-avx-i
     conroe conroe-xe conroe-l allendale merom merom-xe kentsfield kentsfield-xe penryn wolfdale
-    yorksfield nehalem sandy-bridge ivy-bridge haswell k6 k6-2 k6-3 athlon athlon-tbird athlon-4 athlon-xp
-    athlon-mp k8 opteron athlon64 athlon-fx k8-sse3 opteron-sse3 athlon64-sse3 amdfam10 barcelona
-    bdver1 bdver2 bdver3 btver1 btver2 winchip-c6 winchip2 c3 c3-2 atom
+    yorksfield nehalem sandy-bridge ivy-bridge haswell broadwell skylake skylake-avx512 cannonlake
+    k6 k6-2 k6-3 athlon athlon-tbird athlon-4 athlon-xp athlon-mp k8 opteron athlon64 athlon-fx
+    k8-sse3 opteron-sse3 athlon64-sse3 amdfam10 barcelona bdver1 bdver2 bdver3 bdver4 btver1
+    btver2 znver1 winchip-c6 winchip2 c3 c3-2 atom
 
     # ia64
     itanium itanium1 merced itanium2 mckinley
 
     # Sparc
     v7 cypress v8 supersparc sparclite hypersparc sparclite86x f930 f934
--- tools\build\src\tools\gcc.jam	2017-08-19 09:49:50.000000000 -0700
+++ tools\build\src\tools\gcc.jam	2017-08-24 16:03:27.000000000 -0700
@@ -1102,12 +1102,16 @@
 cpu-flags gcc OPTIONS : x86 : nehalem : -march=corei7 ;
 cpu-flags gcc OPTIONS : x86 : corei7-avx : -march=corei7-avx ;
 cpu-flags gcc OPTIONS : x86 : sandy-bridge : -march=corei7-avx ;
 cpu-flags gcc OPTIONS : x86 : core-avx-i : -march=core-avx-i ;
 cpu-flags gcc OPTIONS : x86 : ivy-bridge : -march=core-avx-i ;
 cpu-flags gcc OPTIONS : x86 : haswell : -march=core-avx-i -mavx2 -mfma -mbmi -mbmi2 -mlzcnt ;
+cpu-flags gcc OPTIONS : x86 : broadwell : -march=broadwell ;
+cpu-flags gcc OPTIONS : x86 : skylake : -march=skylake ;
+cpu-flags gcc OPTIONS : x86 : skylake-avx512 : -march=skylake-avx512 ;
+cpu-flags gcc OPTIONS : x86 : cannonlake : -march=skylake-avx512 -mavx512vbmi -mavx512ifma -msha ;
 cpu-flags gcc OPTIONS : x86 : k6 : -march=k6 ;
 cpu-flags gcc OPTIONS : x86 : k6-2 : -march=k6-2 ;
 cpu-flags gcc OPTIONS : x86 : k6-3 : -march=k6-3 ;
 cpu-flags gcc OPTIONS : x86 : athlon : -march=athlon ;
 cpu-flags gcc OPTIONS : x86 : athlon-tbird : -march=athlon-tbird ;
 cpu-flags gcc OPTIONS : x86 : athlon-4 : -march=athlon-4 ;
@@ -1123,14 +1127,16 @@
 cpu-flags gcc OPTIONS : x86 : athlon64-sse3 : -march=athlon64-sse3 ;
 cpu-flags gcc OPTIONS : x86 : amdfam10 : -march=amdfam10 ;
 cpu-flags gcc OPTIONS : x86 : barcelona : -march=barcelona ;
 cpu-flags gcc OPTIONS : x86 : bdver1 : -march=bdver1 ;
 cpu-flags gcc OPTIONS : x86 : bdver2 : -march=bdver2 ;
 cpu-flags gcc OPTIONS : x86 : bdver3 : -march=bdver3 ;
+cpu-flags gcc OPTIONS : x86 : bdver4 : -march=bdver4 ;
 cpu-flags gcc OPTIONS : x86 : btver1 : -march=btver1 ;
 cpu-flags gcc OPTIONS : x86 : btver2 : -march=btver2 ;
+cpu-flags gcc OPTIONS : x86 : znver1 : -march=znver1 ;
 cpu-flags gcc OPTIONS : x86 : winchip-c6 : -march=winchip-c6 ;
 cpu-flags gcc OPTIONS : x86 : winchip2 : -march=winchip2 ;
 cpu-flags gcc OPTIONS : x86 : c3 : -march=c3 ;
 cpu-flags gcc OPTIONS : x86 : c3-2 : -march=c3-2 ;
 ##
 cpu-flags gcc OPTIONS : x86 : atom : -march=atom ;
--- tools\build\src\tools\intel-darwin.jam	2017-08-19 09:49:50.000000000 -0700
+++ tools\build\src\tools\intel-darwin.jam	2017-08-24 16:04:12.000000000 -0700
@@ -129,15 +129,17 @@
 flags intel-darwin.compile OPTIONS <optimization>space : -O1 ; # no specific space optimization flag in icc
 
 # 
 .cpu-type-em64t    = prescott nocona core2 corei7 corei7-avx core-avx-i
                      conroe conroe-xe conroe-l allendale merom
                      merom-xe kentsfield kentsfield-xe penryn wolfdale
-                     yorksfield nehalem sandy-bridge ivy-bridge haswell ;
+                     yorksfield nehalem sandy-bridge ivy-bridge haswell
+                     broadwell skylake skylake-avx512 cannonlake ;
 .cpu-type-amd64    = k8 opteron athlon64 athlon-fx k8-sse3 opteron-sse3
-                     athlon64-sse3 amdfam10 barcelona bdver1 bdver2 bdver3 btver1 btver2 ;
+                     athlon64-sse3 amdfam10 barcelona bdver1 bdver2 bdver3
+                     bdver4 btver1 btver2 znver1 ;
 .cpu-type-x86-64   = $(.cpu-type-em64t) $(.cpu-type-amd64) ;
 
 flags intel-darwin.compile OPTIONS <instruction-set>$(.cpu-type-x86-64)/<address-model>32 : -m32 ; # -mcmodel=small ;
 flags intel-darwin.compile OPTIONS <instruction-set>$(.cpu-type-x86-64)/<address-model>64 : -m64 ; # -mcmodel=large ;
 
 flags intel-darwin.compile.c OPTIONS <warnings>off : -w0 ;
--- tools\build\src\tools\msvc.jam	2017-08-19 09:49:50.000000000 -0700
+++ tools\build\src\tools\msvc.jam	2017-08-24 14:05:58.000000000 -0700
@@ -1647,16 +1647,17 @@
 .cpu-type-g5       = i586 pentium pentium-mmx ;
 .cpu-type-g6       = i686 pentiumpro pentium2 pentium3 pentium3m pentium-m k6
                      k6-2 k6-3 winchip-c6 winchip2 c3 c3-2 ;
 .cpu-type-em64t    = prescott nocona core2 corei7 corei7-avx core-avx-i
                      conroe conroe-xe conroe-l allendale merom
                      merom-xe kentsfield kentsfield-xe penryn wolfdale
-                     yorksfield nehalem sandy-bridge ivy-bridge haswell ;
+                     yorksfield nehalem sandy-bridge ivy-bridge haswell
+                     broadwell skylake skylake-avx512 cannonlake ;
 .cpu-type-amd64    = k8 opteron athlon64 athlon-fx k8-sse3 opteron-sse3
                      athlon64-sse3 amdfam10 barcelona bdver1 bdver2 bdver3
-                     btver1 btver2 ;
+                     bdver4 btver1 btver2 znver1 ;
 .cpu-type-g7       = pentium4 pentium4m athlon athlon-tbird athlon-4 athlon-xp
                      athlon-mp $(.cpu-type-em64t) $(.cpu-type-amd64) ;
 .cpu-type-itanium  = itanium itanium1 merced ;
 .cpu-type-itanium2 = itanium2 mckinley ;
 .cpu-type-arm      = armv2 armv2a armv3 armv3m armv4 armv4t armv5 armv5t armv5te armv6 armv6j iwmmxt ep9312
                      armv7 armv7s ;
